<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基于 mpvue 的圆形进度条组件]]></title>
    <url>%2F2018%2F09%2F28%2F%E5%9F%BA%E4%BA%8Empvue%E7%9A%84%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F</url>
    <content type="text"><![CDATA[自己本身是一个小程序小白，前几天刚开始学习。碰到一个需求是要实现多个圆形带缺口的进度条，在网上没有找到相关插件后决定自己编写一个，如果能帮到需要的人那真是太好了, 下面会介绍一下自己的实现过程，如果只关心如何用的话可以传送到下面的页面 mini-circleprogress 源码 外观 过程一开始的思路是用 svg， 自己编写完毕后，发现小程序不支持直接引入 svg， 因此最终实现是使用的小程序自带的 canvas 如何画圆已经有大佬讲解过了，我就不重复劳动了，下面是链接 https://segmentfault.com/a/1190000013219501 在此说明一下此组件实现的功能和一些注意点 完全响应式适应包裹元素的宽度和高度一开始的思路是设置 canvas 的宽高为 100%，发现并没有什么用，然后想获取 canvas 动态改变其宽高，发现小程序不能操作 dom, ref 也都不能使用。因此只能设置一个 props,麻烦使用者告知一下父元素的宽高，在这里因为此图形是一个正方形，所以只需要传递一个值就可以了。 适应设备的宽度和高度canvas 中的画布单位默认都是 px，画出来的图形是不能很好的适应宽度不同的设备的，因此自己在内部实现了一个 rpx，具体实现思路如下 1234567891011getRpx () &#123; let rpx = 1 // 相对单位 return new Promise(resolve =&gt; &#123; wx.getSystemInfo(&#123; success: function (res) &#123; rpx = res.windowWidth / 375 resolve(rpx) &#125; &#125;) &#125;)&#125; 然后与之前的画布的数值相乘即可，想具体看怎么实现的可以去看下源码 有关 canvas-idcanvas 在一个页面中 id 是不能相同的，就算出现相同的也只会渲染第一个，因此需要多个 canvas 只能让其 id 各不相同。使用者想使用多个圆形进度条组件的时候，请传递 canvasId 值。]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据 url 获取图标及 title]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%A0%B9%E6%8D%AEurl%E8%8E%B7%E5%8F%96%E5%9B%BE%E6%A0%87%E5%8F%8Atitle%2F</url>
    <content type="text"><![CDATA[最近在做一个小项目有一个类似添加书签的功能，用户点击添加后，弹出输入模块，用户只需要将需要收录的链接添加进去，便可以自动生成带有此网站图标和此网站标题的卡片 设置 icon想要知道如何获取肯定要知道网站的 icon 是如何设置的，设置 icon 的方式据我了解的有两种 一般都是在 html 代码的 head 标签中设置一个 link 标签，将其 rel 属性设置为 “icon” 或者 “shortcut icon”, href 就是图标的位置。 大部分网站会在其根目录下放置一个favicon.ico 文件，也就是网站的图标。 获取 icon两条途径设置 icon，明显解析 html 要相对麻烦一点，因此我们先去网站根目录下去获取 favicon.ico, 如果不存在此文件，再解析 html，当然如果网站本身就没有 icon ，那就自己设置一个默认的图标就好了。 我的思路是拿到需要收录的链接，然后用 node 的 url 模块去解析，再用 get 方法去抓取此网页，如果不是 200 就代表根目录下没有此文件。 12345678910111213141516171819202122const express = require('express')const url = require('url')const axios = require('axios')let app = express()app.get('/',function(req, res) &#123; let targetUrl = 'https://github.com/MLuminary' let urlString = url.parse(targetUrl) let iconUrl = `$&#123;urlString.protocol&#125;//$&#123;urlString.host&#125;/favicon.ico` isHasRootIcon(iconUrl)&#125;)// 判断网站根目录下是否有 favicon.ico 文件function isHasRootIcon(url) &#123; axios.get(url).then(response=&gt;&#123; console.log(1) &#125;).catch(error=&gt;&#123; console.log(0) &#125;)&#125; 以上思路大部分网站还是可以的，但是有一些网站会遇到重定向的问题，会跳到 404 页面或者 error 页面，此时返回的 status 也是 200 ，上面的方法就也会认为已找到 icon, 但实际上链接是 html 页面，因此我就想能不能获取到重定向后的链接，判断其类型，如果重定向的类型不是 ico、png等图片类型，就也判断为没找到。找来找去发现了 request 包可以实现, 下面是具体实现 12345678910111213141516171819202122232425262728app.get('/',function(req, res) &#123; let targetUrl = 'http://www.12306.cn/mormhweb/' let urlString = url.parse(targetUrl) let iconUrl = `$&#123;urlString.protocol&#125;//$&#123;urlString.host&#125;/favicon.ico` isHasRootIcon(iconUrl).then(res=&gt;&#123;console.log(res)&#125;)&#125;)// 判断网站根目录下是否有 favicon.ico 文件function isHasRootIcon(url) &#123; let pattern = ['ico','png', 'svg', 'jpg'] return new Promise((resolve)=&gt;&#123; let returnValue = false request.get(url,function(err, res) &#123; if(res.statusCode === 200) &#123; let redirectPath = res.request.uri.path // 重定向的页面路径 pattern.forEach(item=&gt;&#123; if(redirectPath.split('.')[1]===item) &#123; // 如果结尾是 pattern 数组中的一种 则返回 true returnValue = true resolve(returnValue) &#125; &#125;) &#125; resolve(returnValue) &#125;) &#125;)&#125; 如果根目录下不存在 favicon.ico 文件，则需要解析其链接的 html ，然后提取出 icon 的路径，但是这其中还有一些问题，icon 的路径有可能是绝对路径或者是相对路径，因此在此还需要在判断一下，下面是具体代码 12345678910111213141516171819202122232425function resolveHtml(targetUrl) &#123; return new Promise(resolve=&gt;&#123; let defaultUrl = ''// 自己默认的图片链接 superagent.get(targetUrl).end(function (err, content) &#123; let $ = cheerio.load(content.text) let iconUrl = $("link[rel*='icon']").eq(0).attr('href') // 获得 icon 的链接 // 如果 iconUrl 存在 还需要判断其是否是相对位置 if(iconUrl) &#123; // 如果不存在 'http' if(iconUrl.indexOf('http') === -1 ) &#123; // 判断是否为相对路径或根路径 if(iconUrl.charAt(0) === '/') &#123; let urlString = url.parse(targetUrl) iconUrl = `$&#123;urlString.protocol&#125;//$&#123;urlString.host&#125;$&#123;iconUrl&#125;` &#125;else &#123; iconUrl = targetUrl + "/" + iconUrl &#125; &#125; resolve(iconUrl) &#125;else &#123; resolve(defaultUrl) &#125; &#125;) &#125;)&#125; 获取 icon 连接时为什么我加了一个 eq(0) 呢，是因为我发现有些网站有两种类型的 link 可以添加图标，一种是shortcunt icon 一种是 icon，因此我们只要获取其中一个就可以了，两个都获取到可能会报错。 获取title获取 title 就相当于解析 Html 获取 icon, 还是比较简单的，在此就不放代码了。 成果下面就是传入掘金首页抓取到的信息]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取百度搜索提示结果]]></title>
    <url>%2F2018%2F08%2F15%2F%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E6%8F%90%E7%A4%BA%E7%BB%93%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[最近自己想做的项目需要一个搜索框，并想实现如下搜索提示的功能 本来觉得查查 network 随便抓取一下就可以获得到数据，但事情却不是这么简单 过程在百度在随便输入字符，查看 network，找到此时请求的链接 会发现使用 get 方式传了四个值,其中 p 和 cb 都是可以固定的，剩下的就是关键字 wd 和此时的时间戳 t，自己因为本身是 vue 的项目，就用 axios 对此进行请求，结果报错为 跨域 并且 中文乱码 gzip因为发生了跨域，因此就想用 node 去修改请求头去请求，「后来发现用 node 去请求不需要修改请求头也不会跨域」，但是还有一个问题返回的中文都是乱码。然后我就去关注了一下响应头，如上面的图片，其中 content-encoding: gzip 引起了我的注意。 gzip 是什么在此我就不做过多的解释，去网上查只是说想要获取 gzip 格式的网页信息需要解压，要不然获得到的信息会是乱码，其中用到了 zlib 和 request 两个包 123456789101112131415161718 zlib = require('zlib');function response (err, res, body) &#123;//check res header it is gzip console.log(res.headers['content-encoding'])//now body it is gzip stream buffer zlib.unzip(body, function(err, buffer) &#123; console.log(buffer.toString()) &#125;&#125; request.get(&#123; url : apiUrl, headers: &#123; 'Accept-Encoding' : 'gzip', &#125;, encoding : null // it is very import!! &#125;, response) 但是我满怀期待的将其解压提取信息后获得的结果依然是乱码，make my heart cold cold gbk 最后又把目光转向响应头，感觉 charset=gbk 好像有点东西, 其中用到了 iconv-lite ，是一个转编码的工具，iconv.decode 接受到第一个参数必须是 buffer, 而 request 获取到的信息返回的也是 buffer 我就感觉冥冥之中放佛预示着什么 1234567request(&#123; url, encoding : null &#125;, function(err, response, body) &#123; res.setHeader('Content-Type', 'application/json; charset=utf-8') res.end(iconv.decode(body, 'gbk')) &#125;) 因此将响应头设置为 utf-8 并将其 gbk 编码转换为 utf-8 后成功的获得到了需要的信息, 下面就是将此 api 部署到我自己的服务器上，关于部署碰到的一些问题基本都在我另一篇文章中有谈到 记一次oneinstack配置服务器 阅读原文]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Idea</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让服务器带点绿]]></title>
    <url>%2F2018%2F07%2F28%2F%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%A6%E7%82%B9%E7%BB%BF%2F</url>
    <content type="text"><![CDATA[这段时间终于感觉自己步入正轨，也相对稳定了下来。便想搞点事情，想做一个网站，包含自己一些平时想要的工具和一些自己想关注的咨询。然后发现自己的服务器竟然一点都不绿，所以就花了一些时间绿化了自己的服务器。 nginx 上 https申请证书我自己用的是腾讯云服务器，因此证书就去腾讯云官方网站去申请，当然不是腾讯云的话还有几个比较权威的颁发证书的网站，例如 StartSSL,当然如果你的服务器是 Linux 的话，你也可以用默认安装的 OpenSSL 但是 OpenSSL 的方法我没有试过，具体可以参考 https://www.cnblogs.com/chjbbs/p/5748369.html 腾讯云的申请证书还是比较简单，打开下述链接 https://console.cloud.tencent.com/ssl 点击申请证书，然后根据其提示一步步填写，审核成功后下载证书，下载证书后里面的文件如下 打开 Nginx，里面包含着一个证书文件和一个 .key 文件。 配置 nginx打开服务器中的 nginx/conf 文件夹，在其中创建一个文件夹为 ssl，再创建一个文件夹为域名，这个完全看自己的习惯，在后面的配置项中只要路径对就可以。我的证书和 .key 文件的位置就在 nginx/conf/ssl/www.haoqinzz.cn/ 下 然后找到 nginx.conf 文件，将其中如下代码解开封印并修改为如下代码 123456789101112131415161718192021222324252627282930# HTTPS server server &#123; listen 443; server_name localhost; ssl on; ssl_certificate ssl/www.haoqinzz.cn/1_www.haoqinzz.cn_bundle.crt; ssl_certificate_key ssl/www.haoqinzz.cn/2_www.haoqinzz.cn.key; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_prefer_server_ciphers on; ssl_dhparam ssl/certs/dhparam.pem; ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;; keepalive_timeout 70; ssl_session_cache shared:SSL:10m; add_header Strict-Transport-Security max-age=63072000; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; location / &#123; root html; index index.html index.htm; &#125; &#125; 然后再重启一下 nginx 服务即可，然后输入 https://haoqinzz.cn 就可以看到 nginx 的欢迎页，但此时你输入 http://haoqinzz.cn 还是可以访问的，所以如果想要全站都上 https ，还需要修改 http 的服务，将 http 重定向到 https 中 12345server &#123; listen 80; server_name haoqinzz.cn www.haoqinzz.cn; return 301 https://haoqinzz.cn$request_uri;&#125; 这样你输入 http://haoqinzz.cn 会跳到 https://haoqinzz.cn 中，但是现在还存在一个很大的问题，就是我以前的项目也无法访问到了。。 让服务器中的项目重新运行基本项目服务器上 https 后，首页改变了，所有项目都没了，我就去看了一下 nginx 的配置文件 123456789101112131415161718192021222324252627282930# HTTPS server server &#123; listen 443; server_name localhost; ssl on; ssl_certificate ssl/www.haoqinzz.cn/1_www.haoqinzz.cn_bundle.crt; ssl_certificate_key ssl/www.haoqinzz.cn/2_www.haoqinzz.cn.key; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1; ssl_prefer_server_ciphers on; ssl_dhparam ssl/certs/dhparam.pem; ssl_ciphers &quot;EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4&quot;; keepalive_timeout 70; ssl_session_cache shared:SSL:10m; add_header Strict-Transport-Security max-age=63072000; add_header X-Frame-Options DENY; add_header X-Content-Type-Options nosniff; location / &#123; root html; index index.html index.htm; &#125; &#125; 发现 https 的 root 文件夹为 html，因此我将原本的文件迁过来就可以访问了。:fist: nginx 反向代理项目在服务器上我还有过一个用 nginx 实现反向代理的项目，升 https 后毫无疑问 api 全部都是 404 了 找到 nginx 反向代理的配置文件，将 Listen 端口 80 改为 443 ，并将以前的 http 协议都改为 https，然后此时再打开就可以找到 url ，但是会报 502 错误，经过仔细排查后发现这是因为我当时用 http 起的服务，要改为 https 并配置证书文件 123456789var https = require('https');const fs = require('fs');const options = &#123; key: fs.readFileSync('key文件'), cert: fs.readFileSync('crt文件')&#125;;var server = https.createServer(options,app); 这样数据便又可以获取到了 oneinstack 一键配置你也可以使用 Oneinstack 傻瓜式上 https ，也就是 ~/oneinstack/vhost.sh, 具体可以看 oneinstack 官网的教程]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次 oneinstack 配置服务器]]></title>
    <url>%2F2018%2F06%2F25%2F%E8%AE%B0%E4%B8%80%E6%AC%A1oneinstack%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[因为自己是大学生，所以一直都是用的腾讯云学生机，但是前几天腾讯突然告诉我腾讯云学生认证到期了，可能是当时填错了，没办法我就又申请了学生认证😂，谁让我还是学生呢，但是以前老的学生优惠的学生机就不能再按照学生优惠的方式续费了，所以我又买了一个新的服务器。买完服务器准备手动开始各种配置的时候便发现了一个神器，也就是接下来要介绍给大家的。就是 oneinstack ,可以傻瓜式「一键」安装，想看碰到的 bug 及一些解决方案可以直接跳过配置服务器部分。jump 配置服务器环境我写此博客时 oneinstack 的版本为 2018-04-24, 其使用方式如下 基本安装12345678910111213141516171819yum -y install wget screen curl python #for CentOS/Redhat# apt-get -y install wget screen curl python #for Debian/Ubuntu# 下载源码与脚本wget http://mirrors.linuxeye.com/oneinstack-full.tar.gz #包含源码，国内外均可下载# 解压tar xzf oneinstack-full.tar.gz# 如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件cd oneinstack # 如果网路出现中断，可以执行命令`screen -R oneinstack`重新连接安装窗口screen -S oneinstack # 注：请勿sh install.sh或者bash install.sh这样执行./install.sh # 接下来根据其指示和自己喜好安装需要的软件即可 node 安装oneinstack 不支持 node 环境的安装，作为一个前端er, node 还是不可获取的，以前我配置 node 都是去官网下载然后解压然后建立全局软链接的形式，这次也是换了一个更简单的方式 node.js v.8x 安装命令1#curl --silent --location https://rpm.nodesource.com/setup_8.x | bash - 安装node1yum install -y nodejs 查看 nodejs 安装版本1node -v 至此 node 就已经安装完成，也是全局变量，相比以前也省了很多时间和力气，如果需要也可以安装 nodejs 的版本管理工具，但是在这里我没有安装，正确与否我没有尝试 node.js版本管理器n安装n1npm install -g n1 安装指定版本1#n &lt;version&gt;1 安装最新版本1# n latest1 安装稳定版本1#n stable1 删除某个版本1#n rm &lt;version&gt; 1 查看所有版本1#n list 其他配置添加附加组件1./addons.sh 创建 FTP 虚拟用户账户1./pureftpd_vhost.sh 增删虚拟主机12# 增加虚拟主机./vhost.sh# 删除虚拟主机./vhost.sh 备份和自动备份1# Set backup options ./backup_setup.sh # Start backup, You can add cron jobs./backup.sh # crontab -l # Examples 0 1 * * * cd ~/oneinstack;./backup.sh &gt; /dev/null 2&gt;&amp;1 &amp; 更新版本1./upgrade.sh 卸载1./uninstall.sh 管理服务Nginx/Tengine/OpenResty: 1service nginx &#123;start|stop|status|restart|reload|configtest&#125; MySQL/MariaDB/Percona: 1service mysqld &#123;start|stop|restart|reload|status&#125; PostgreSQL: 1service postgresql &#123;start|stop|restart|status&#125; MongoDB: 1service mongod &#123;start|stop|status|restart|reload&#125; PHP: 1service php-fpm &#123;start|stop|restart|reload|status&#125; HHVM: 1service supervisord &#123;start|stop|status|restart|reload&#125; 注：hhvm进程交给supervisord管理，了解更多请访问《Supervisor管理hhvm进程》Apache: 1service httpd &#123;start|restart|stop&#125; Tomcat: 1service tomcat &#123;start|stop|status|restart&#125; Pure-Ftpd: 1service pureftpd &#123;start|stop|restart|status&#125; Redis: 1service redis-server &#123;start|stop|status|restart&#125; Memcached: 1service memcached &#123;start|stop|status|restart|reload&#125; 启用 mysql 服务oneinstack 默认仅允许主机本机链接数据库，需要远程连接数据库的话，需要打开对应端口 打开 3306 端口CentOS 系统 123iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT # 允许访问 3306service iptables save #保存 iptables 规则iptables -nvl # 查看 iptables 规则 Ubuntu/Debian 12iptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT # 允许访问 3306iptables-save &gt; /etc/iptables.up.rules #保存 iptables 规则 数据库授权MySQL8.0版本1234# mysql -uroot -p MySQL [(none)]&gt; create user db_user@'%' identified by 'db_pass'; #创建用户 MySQL [(none)]&gt; grant all privileges on db_name.* to db_user@'%' with grant option; #授权 MySQL [(none)]&gt; exit; #退出数据库控制台，特别注意有分号 其余MySQL版本1234# mysql -uroot -p MySQL [(none)]&gt; grant all privileges on db_name.* to db_user@'%' identified by 'db_pass'; #授权语句，特别注意有分号 MySQL [(none)]&gt; flush privileges; MySQL [(none)]&gt; exit; #退出数据库控制台，特别注意有分号 服务器https以前的服务器 https 都是自己上的，使用 oneinstack 可以一键让自己的服务器带点绿 :green_apple: 运行./vhost.sh 就会跳到配置虚拟环境界面，oneinstack 采用 Let’s Encrypt https 证书，免费使用为 90 天，到期后 oneinstack 会自动帮你续费，配置完毕后在默认文件夹里添加项目就可以输入网址以 https 的方式访问 遇到的问题无法访问带端口域名我自己创建了一个二级域名 api.×××× 来作为我一些 api 接口的提供网址，然后想用 oneinstack 为其上https，向服务器中上传 node 文件用 pm2 跑起来后，本来在本地 localhost:3000 可以访问的文件，到了服务器后无法通过 api.××××:3000 来访问，最开始想到了类似阿里云安全组的问题，然后我去后台看了下我的服务器的安全组，并没有禁用 3000 端口。后来脑子里自己冒出来了一个想法，用 nginx 反向代理，在这里我就不具体给出反向代理的代码了，格式很简单，就是访问 api.××××/getApi 相当于访问 api.××××:3000/getApi ,然后竟然就成功访问到了 :zap: 2018/9/10: oneinstack 默认端口都是不开放的，因此我感觉是未将 3000 端口开放的原因 引用 api 碰到的跨域问题主域名下的项目引用 api.×××× 下的 api 是要跨域的，谷歌搜索到的解决方案基本是如下代码 12345678app.all('*', function(req, res, next) &#123; res.header("Access-Control-Allow-Origin", "*") res.header("Access-Control-Allow-Headers", "Content-Type,Content-Length, Authorization, Accept,X-Requested-With") res.header("Access-Control-Allow-Methods","PUT,POST,GET,DELETE,OPTIONS") res.header("X-Powered-By",' 3.2.1') if(req.method=="OPTIONS") res.send(200)/*让options请求快速返回*/ else next()&#125;) 但是并没有解决我的跨域问题，我是在 nginx 反向代理时加入如下代码实现的 1234location / &#123; add_header Access-Control-Allow-Origin *; ...&#125; https 引用 http 下的接口报错我的 api.×××× 域名在开始的时候上 https 并没有成功，我就使用的是 http 协议，但是解决了跨域问题后又报错，报错的内容大致就是 https 下无法引用 http 中的接口，最后我其实换了一个域名又上了 https … :joy_cat: 最后最后基本项目都已部署到了服务器上，访问项目也有耀眼的小绿标，还是 hin 开心的]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Server</tag>
        <tag>Oneinstack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全]]></title>
    <url>%2F2018%2F05%2F30%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[最近一直在准备面试，被问到了解 XSS 时答出不了解还是很惭愧的，作为前端开发人员，安全这方面是必须要非常重视的，因此决定拿出了一段时间来重点了解一下关于前端的安全问题，在这里以 XSS 和 CSRF 为主 XSSXSS(Cross-site script)因为与 CSS 简写重合所以改为 XSS 其原理是向网站中插入恶意的 HTML 代码。当其他用户浏览该网站的时候，该段 HTML 代码会自动执行，从而达到攻击的目的。如盗取用户的 Cookie，页面重定向，破坏页面结构 举个:chestnut: 网站的评论系统没有过滤 XSS 攻击，当有用户添加评论为 12345&lt;script&gt; while(true) &#123; alert("1") &#125;&lt;/script&gt; 这段代码就会插入到此网站的 DOM 结构中，因为没有过滤掉或进行处理，此段代码也会执行。 XSS 分类XSS 分为两种类型：「持久型 XSS」 和 「非持久型 XSS」 持久型 XSS「存储型」 持久型 XSS 就是对客户端攻击的脚本直接植入到服务器上，从而导致每个用户访问此网站都会遭到 XSS 的攻击 非持久型 XSS「反射型」 非持久型 XSS 是对一个页面的某个参数做文章，把精心构造好的恶意脚本包装在 URL 参数中，再讲 URL 发布到网上，骗取用户访问 手段主要有 HTML 节点内容的注入 例如 添加评论 HTML 属性 例如 通过 url 传值动态修改 img 的 src javascript 代码 例如 传递的变量添加双引号并在双引号后面添加要注入的脚本 防御 XSS对于非持久型 XSS 现代浏览器都对 xss 有了一定的防范作用，但也仅限于 html 节点和属性的注入。 Web 页面渲染的所有内容和数据必须来自于服务器 尽量不使用 eval, new Function(),window.setTimeout(),innerHTML等可执行字符串的方法 前端渲染的时候要对任何字段都需要做转义 对于用户输入的要添加限制，比如用户名和密码只允许字符和数字，email 必须为 email 格式 对于富文本采用过滤，可以通过国人写的 xss 对于持久型 XSS 后端在入库的时候不相信任何前端的数据，将所有的字段统一进行转义处理 后端在传递给前端数据的时候统一做转义处理 前端不相信后端传来的数据，任何字段也都需要做转义处理 举个栗子:chestnut: 先看一下后台的代码「node.js」 12345app.get('/api/xss', function(req, res) &#123; res.setHeader('X-XSS-Protection', 0) //关闭浏览器 XSS res.json('hutchins &lt;script&gt;console.log(1)&lt;/script&gt;') //模拟XSS攻击，后台返回了带脚本的字符串&#125;) 前台代码 12345678$.ajax(&#123; type:'get', url:"http://localhost:3003/api/xss", dataType:'json', success:function(data)&#123; $('#uname').html(data) //这样在前台就会插入 script 标签 &#125;&#125;) 这样便会在前台插入脚本代码并在控制台打印 1，那么对于此类代码就需要将其转义，让其无法运行，在 success 方法中改为如下代码 12345678//进行HTML转义后便会插入正常的内容var str = datastr = str.replace(/&lt;/g,'&amp;lt')str = str.replace(/&gt;/g,'&amp;gt')$('#uname').html(str)//但其实这样也可以完美插入$('#uname').text(data) CSRFCSRF 「Cross-site request forgery」中文名称为跨站请求伪造 攻击者盗用了你的登录信息，以你的身份模拟发送各种请求。 完成 CSRF 攻击有三个条件 用户已经登录了站点 A，并且在本地保留了 cookie 在用户没有登出站点的情况下也就是 cookie 还在生效的情况下访问了攻击者提供的危险站点 B 站点 A 没有任何 CSRF 防御 CSRF 手段拿发表评论为例，就是用户登录后编写评论点击发表这种操作，如果发表评论是 get 请求 那 CSRF 攻击者可以通过在自制的 B 危险网站上面写一个 a 标签，然后由 a 标签模拟你点击评论发起的 get 请求，当你点击时，就会在 A 网站添加一个评论，这也是为什么 CSRF 叫 「one click attack 一点就爆炸」，当然也可以直接写一个图片在你不知情时发送 get 请求 那你此刻会想，那把添加评论改成 post 请求应该就安全了吧 改成 post 请求，攻击者可以在 B 网站用 js 动态生成表单，然后发送 post 请求，更高级点可以再生成一个隐藏的 iframe 让表单 target 指向其 name，让你在完全没有察觉的情况下以你的名义干一些羞羞的事情 CSRF 防御从 cookie 方面下手 禁止止第三方网站使用 cookie，使用 sameSite:Strict 目前仅有 chrome 支持 从绕过前端页面下手 在前端页面加入验证信息，可以使用 ccap 加入 token，token 在前端页面 cookie 和 后端必须保持一致，如果是 ajax 请求的话可以在前端页面 meta 处添加一个 token 属性，然后用 js 动态获取 referer 为 B 网站 验证 referer /^域名/，这里注意一下，如果你是用本地文件测试的话，file 协议是没有 referer 的]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Safe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域问题总结]]></title>
    <url>%2F2018%2F05%2F28%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[跨域问题是日常中必须要面对的，每次面试必考跨域也体现了跨域技术的重要性，跨域的文章也多的数不过来，今天这篇文章主要是用来总结自己每种跨域技术的尝试，如果有幸能帮到别人那就再好不过了 大概自己用 node 搭了两个服务器，前台设置的端口为 3002，模拟的服务端设置的端口为 3001 跨域问题的出现是由于「同源策略」引起的，「同源」就指的是三个相同，即「协议相同」、「域名相同」、「端口相同」，「同源策略」使得以下三种行为受到限制 Cookie、LocalStorage 和 IndexDB 无法获取 DOM 无法获取 Ajax 请求无法发送 具体情况还请移步浏览器同源政策及其规避方法 自己在这还是稍微总(jie)结(jian)一下，写一遍加深一下印象 对于 Cookie 和 iframe对于 Cookie 和 iframe ，如果两个网页一级域名相同，只是二级域名不同，比如 a.hutchins.com 和 b.hutchins.com ，浏览器可通过设置相同的 document.domain 1document.domain = 'hutchins.com' 服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如 1Set-Cookie: key=value; domain=hutchins.com; path=/ 这样的话二级域名和三级域名不做任何设置就可以读取这个 Cookie window.postMessageH5 引入了全新的 API :「跨文档通信 API」 1otherWindow.postMessage(message, tragetOrigin); otherWindow 窗口 message 要发送的信息 targetOrigin 指定哪些窗口可以接受到信息，* 表示无限制 接收窗口通过 message 方法接收 123window.addEventListener('message' function(e) &#123;&#125;) message 的事件对象有以下三个属性 event.source 发送消息的窗口 event.origin 消息发向的网址 event.data 发送的消息 AJAX 跨域jsonp 跨域jsonp 的原理就是动态创建 script 标签，然后用 script 的 src 属性引用外部跨域链接，通过回调函数参数接受后台传递的信息 123456789101112//原生jsvar script = document.createElement('script')script.type = 'text/javascript'//传参并指定回调函数执行函数为onBackscript.src = 'http://localhost:3001/api/jsonp?uname=hutchins&amp;callback=onBack'document.body.appendChild(script)//回调执行函数function onBack(res) &#123; console.log(JSON.stringify(res))&#125; 1234567891011//利用jquery ajax$.ajax(&#123; url: 'http://localhost:3001/api/jsonp?uname=hutchins', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: 'onBack', // 自定义回调函数名 data: &#123;&#125;, success: function(data) &#123; console.log(data) &#125;&#125;) 123456789101112//node 后台处理前端请求的函数module.exports = &#123; //jsonp jsonpf: function(req, res) &#123; var params = req.query var fn = req.query.callback res.writeHead(200, &#123; 'Content-Type': 'text/javascript' &#125;) res.write(fn + '(' + JSON.stringify(params) + ')') res.end() &#125;&#125; 但是 jsonp 只能支持 Get 请求 跨域资源共享 「CORS」请求分为「简单请求」和「非简单请求」，而处理这两种请求的方式很不同，这里只说一下「简单请求」 请求方式为以下几种 HEAD GET POST HTTP 的消息头不超出以下几种字段 Accept Accept-Language Content-Language Last-Event-ID Content-Type 只限于 application/x-www-form-ulrencoded、multipart/form-data、text/plain 1234567891011121314151617181920// 原生jsvar xhrif (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest()&#125; else &#123; xhr = new XDomainRequest() //兼容 IE8/9&#125;//前端设置 cookiexhr.withCredentials = truexhr.open('post', 'http://localhost:3001/api/cors', true)xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')xhr.send('uname=hutchins')xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log(xhr.responseText) &#125;&#125; 123456789//跨域后台设置res.writeHead(200, &#123; 'Access-Control-Allow-Credentials': 'true', //后端允许发送 cookie 'Access-Control-Allow-Origin': 'http://localhost:3002' // 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie&#125;)res.write(JSON.stringify(postData))res.end()]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>CrossDomain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FlexDisplayRoom]]></title>
    <url>%2F2018%2F05%2F25%2FFlexDisplayRoom%2F</url>
    <content type="text"><![CDATA[前段时间面试发现有很多都问 flex 布局，就觉得灰常有必要去学习一下，浏览了一遍阮一峰大神写的教程后掌握了基本理论，但始终觉得应该实践一下，偶然间看到下面这样一个网站 https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/ 应该要翻墙才能进去，这个网页在手机端需要不断的上下滑动，个人感觉有必要修改一下，就萌生了也做一个类似的想法，当然自己手机端做的也不是那么好，但是在做的过程中也学到了一些适应手机端的一些知识 项目展示地址 项目源码地址 Flex 布局的基础知识采用 flex 布局的元素，称为 Flex 容器，它的所有子元素自动成为容器成员，成为 Flex 项目 容器的属性以下属性第一个取值为默认值 flex-direction row : 主轴为水平方向，起点在左端 row-reverse : 主轴为水平方向，起点在右侧 column : 主轴为垂直方向，起点在上沿 column-reverse : 主轴为垂直方向，起点在下沿 flex-wrap nowrap : 不换行 wrap : 换行，第一行在上方 wrap-reverse: 换行，第一行在下方 flex-flow flex-flow 是 flex-direction 和 flex-wrap 的简写形式，默认值为 row nowrap justify-content flex-start : 左对齐 flex-end : 右对齐 center : 居中 space-between : 两端对齐，项目之间间隔都相等 space-around : 每个项目两侧的间隔相等 align-items stretch : 如果项目未设置高度或设为 auto ，将占满整个容器的高度 flex-start : 交叉轴的起点对齐 flex-end : 交叉轴的终点对齐 center : 交叉轴的中点对齐 baseline : 项目的第一行文字的基线对齐 align-content stretch : 轴线占满整个交叉轴 flex-start : 与交叉轴的起点对齐。 flex-end : 与交叉轴的终点对齐。 center : 与交叉轴的中点对齐。 space-between : 与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around : 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 项目的属性order 定义项目的排列顺序，属性值越小，排列越靠前，默认为 0 flex-grow 定义项目的放大比例，默认为 0 ，即如果存在剩余空间也不放大 flex-shrink 定义项目的缩小比例，默认为 1 ，即如果空间不足，项目将自动缩小，负值对该属性无效 flex-basis 定义了在分配多余空间之前，项目占据的主轴空间。默认值为 auto 即项目本来的大小 flex flex 是 flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto 该属性有两个快捷值 : auto(1 1 auto) 和 none(0 0 auto) align-self align-self 允许单个项目与其它项目有不一样的对其方式，可覆盖 align-items。默认值为 auto，表示继承父元素的 align-items 属性]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Flex</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性感慕课-在线被爬]]></title>
    <url>%2F2018%2F05%2F20%2F%E6%80%A7%E6%84%9F%E6%85%95%E8%AF%BE-%E5%9C%A8%E7%BA%BF%E8%A2%AB%E7%88%AC%2F</url>
    <content type="text"><![CDATA[在学习了 alsotang 大神的 《Node.js包教不包会》后的一个爬虫小练习，期间也碰到挺多小问题，也学到了很多小东西。「 单押×3 」:trollface: 这里是大神的教程地址 https://github.com/alsotang/node-lessons， 下面是自己的爬取效果图 imoocSpider练习源码 搭建服务器首先，搭建一个 http 服务 12345678910var http = require('http')var express = require('express')var app = express()http.createServer(app).listen(8080)app.get('/', function(req, res) &#123; //code here...&#125;) 用的是 express 搭建的，当然也可以用原生的，在这里自己比较习惯用 express 在线爬虫在这里用到的是 superagent 和 cheerio 来爬取页面，这里有相关文档可以参考: superagent中文文档、cheerio，都是来自 cnode 社区，当然英语能力较好的也可以参考原文档。在这里就只贴出这两个 爬取页面链接 https://www.imooc.com/course/list?c=fe 我们是要爬取慕课网前端开发八个页面的课程中的一些信息，但是打开此链接发现每个页面只有课程的名称，并没有老师的名称和一些课程的主要信息。因此我们还需要获取并根据每个课程的 url 进行爬取。 获取课程详情页链接 那我们先来爬取八个页面的所有课程详情页的 url 通过点击对应页面的按钮，发现每次都会发送一个新的 get 请求，请求的链接就是对应的页面，而这里的链接只有 page 属性是不同的，因此我们通过动态改变 page 就可以模拟点击对应页来获取对应页的信息 1234567891011121314151617181920212223242526var pages = 1var baseUrl = 'https://www.imooc.com/course/list/'var params = &#123; c: 'fe', page: page&#125;superagent .get(baseUrl) .query(params) .end(function(err, content) &#123; var topicUrls = [] var $ = cheerio.load(content.text) var courseCard = $('.course-card-container') courseCard.each(function(index, element) &#123; var $element = $(element) var href = url.resolve( homeUrl, $element.find('.course-card').attr('href') ) topicUrls.push(href) &#125;) console.log(topicUrls) &#125;) 这样就可以获取到了第一个页面的 25 个课程的详情页的 url，那要如何获取八个页面呢。 async 因为有些网站通常都会有安全限制，不会允许同一个域名有过大的高并发数，因此需要限制并发数，在这里用我们用到了 async 这个库。这里是其 github 我们首先把前面代码封装成一个函数 123456789101112131415161718192021222324252627282930313233var baseUrl = 'https://www.imooc.com/course/list/'var fetchUrl = function(page, callback) &#123; count++ console.log('当前并发数', count) var params = &#123; c: 'fe', page: page &#125; superagent .get(baseUrl) .query(params) .end(function(err, content) &#123; var topicUrls = [] var $ = cheerio.load(content.text) var courseCard = $('.course-card-container') courseCard.each(function(index, element) &#123; var $element = $(element) var href = url.resolve( homeUrl, $element.find('.course-card').attr('href') ) topicUrls.push(href) &#125;) callback(err, topicUrls) count-- console.log('释放并发数后当前并发数', count) &#125;) &#125; 然后用 async 控制并发数和八个页面的抓取 1234567891011121314var pages = [1, 2, 3, 4, 5, 6, 7, 8]async.mapLimit( pages, 5, function(page, callback) &#123; fetchUrl(page, callback) &#125;, function(err, result) &#123; if (err) console.log(err) console.log(result) &#125; )&#125;) 这样所有的 url 就被打印出来，这里要注意一下，async 会自动把第三个函数参数的返回值合并成一个数组给第四个函数参数的 result 参数。刚开始写的时候我把 topicUrls 声明在了全局，以至于返回成下面这组数据 爬取课程详情页的信息 在我们有了所有课程详情页的 url 后，我们开始爬取里面的内容。首先定义一个函数 12345678910111213141516171819202122232425262728var fetchMsg = function(topicUrl, callback) &#123; console.log('开启新一轮抓取') superagent .get(topicUrl) .end(function(err, content)&#123; var Item = [] var $ = cheerio.load(content.text) var title = $('.hd .l').text().trim()//课程名字 var teacher = $('.tit a').text().trim()//老师名字 var level = $('.meta-value').eq(0).text().trim()//难度 var time = $('.meta-value').eq(1).text().trim()//时长 var number = $('.meta-value').eq(2).text().trim()//学习人数 var grade = $('.meta-value').eq(3).text().trim()//评分 Item.push(&#123; title: title, teacher: teacher, level: level, time: time, number: number, grade: grade, href: topicUrl &#125;) callback(null, Item) &#125;) &#125; 然后用 async 控制并发爬取 123456789101112131415161718192021//result 为上文中的 result，下面的代码也都是在上文中的第四个参数中var topicUrls = result //获取所有 url ，但是大数组里面有 8 个小数组var Urls = []//将大数组合并for(let i=0,l=topicUrls.lengthi&lt;li++)&#123; Urls = Urls.concat(topicUrls[i])&#125;async.mapLimit( Urls, 5, function(url,callback)&#123; fetchMsg(url, callback) &#125;, function(err, result) &#123; //避免乱码 res.writeHead(200, &#123;'Content-Type': 'text/plaincharset=utf8'&#125;) res.end(JSON.stringify(result)) &#125; 这里要注意一个小问题，就是 result 获取到的 url 结构是一个大数组里面包含八个小数组，因此需要将其小数组先合并成一个大数组。 最后附上项目源码]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天这个仇先记下来了]]></title>
    <url>%2F2018%2F05%2F17%2F%E4%BB%8A%E5%A4%A9%E8%BF%99%E4%B8%AA%E4%BB%87%E5%85%88%E8%AE%B0%E4%B8%8B%E6%9D%A5%2F</url>
    <content type="text"><![CDATA[最近这个记仇图片在我的一些群里出现次数相当高，朋友们都会去用修图软件去改下面的文字，作为一个前端党就在想能不能更加便利一点，一开始想用 canvas 去画文字，后来就偶然搜到了 html2canvas，是一款截图工具，那这样就方便多了。 实现 具体实现方式就是利用 html2canvas 对一个 Div 进行截图，在这个 Div 里有记仇的图片和可编辑的文本框，然后再在下面展示并下载下来就阔以了，这部分涉及到了 base64 图片的下载，也是借用了 segmentFault 上大神的代码 体验地址项目地址更多]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[prop 和 attr 的一些理解]]></title>
    <url>%2F2017%2F11%2F24%2Fprop%E5%92%8Cattr%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前几天做一个迷你京东小项目的时候涉及到一个全选的小功能，一开始用的是 attr，但是效果完全不是自己想要的，当商品按钮点击过一次后，attr 就无法对其状态进行更改，最后谷歌了一番发现需要用 prop 来代替。虽然效果问题解决了，但是自己还是想弄懂 prop 和 attr 的区别. 版本使用不同遇到问题我一般先会去查相关的官方文档，可在 jq 的 api 中文文档中没有发现有价值的东西，只是发现适用的版本和概念有所轻微的不同。 attr : 设置或返回被选元素的属性值.版本：1.0 prop : 获取在匹配的元素集中的第一个元素的属性值。版本：1.6+ 从概念中发现操作的对象和使用也好像基本相同，然后带着疑惑去进行了一番实验并去查阅了一些相关资料 示例代码 12345678910111213&lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;input type="checkbox" class="checkAll"&gt;全选&lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt;&lt;input class="item" type="checkbox"&gt;单选&lt;/tr&gt; &lt;tr&gt;&lt;input class="item" type="checkbox"&gt;单选&lt;/tr&gt; &lt;tr&gt;&lt;input class="item" type="checkbox"&gt;单选&lt;/tr&gt; &lt;tr&gt;&lt;input class="item" type="checkbox"&gt;单选&lt;/tr&gt; &lt;tr&gt;&lt;input class="item" type="checkbox"&gt;单选&lt;/tr&gt; &lt;tr&gt;&lt;input class="item" type="checkbox"&gt;单选&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; 123$('.checkAll').click(function() &#123; $('.item').attr('checked', this.checked)&#125;) 问题描述当全选按钮选中时单选按钮全部选中，当全选按钮不选中时单选按钮全部不选中，只点全选按钮时，反复几次都没问题，但是要是点击了其中一个单选按钮，那这个单选按钮就不会在像其它单选按钮一样跟随全选按钮的状态的改变而改变。 attr 和 prop 的本质attr 是 attribute 的缩写,prop 是 property 的缩写，都有属性的意思，只不过 attr 是操作 html 文档节点属性，prop 是操作 js 对象属性. attr 在 js 中使用的是 setAttribute 和 getAttribute 而 prop 直接使用原生 js 的 element[value] 和 element[value]=key。 attr 和 prop 的区别attr 设置的属性值只能是字符串类型,如果不是字符串类型，也会调用其 toString() 方法，将其转换成字符串类型。 prop 设置的属性值可以包括数组和对象在内的任意类型 有关布尔值的属性1.6 之后, attr 返回的也是字符串类型, 选中或禁用直接返回 checked,selected,disabled。否则返回undefined。解决我问题的关键就是后面一句话 jQuery 认为：attribute 的 checked、selected、disabled 就是表示该属性初始状态的值，property 的 checked、selected、disabled 才表示该属性实时状态的值(值为 true 或 false)。 当涉及到 boolean 值时，比如 checkbox 这样的，有 true 和 false 这样的布尔值的元素属性，attributes 在页面加载的时候就被设置，并且一直保持初始值，而 properties 则存储着元素属性的当前值。 所以当我没有点击单选按钮的时候，它就是没被用户点击过的浏览器刚加载出来的初始状态，此时可以通过 attr 去设置并操控，当有用户点击的时候，当前按钮就不是初始状态，attr自然也就无法操控。]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>JQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易扫雷小游戏]]></title>
    <url>%2F2017%2F09%2F07%2F%E7%AE%80%E6%98%93%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[前阵子无聊，LOL 也不是很想玩，发现了电脑中自带的扫雷, 当时在一个神奇的地方，用的是一个 windows2000 的系统界面但是扫雷确是 win7 的样式, 这种情况，就是考验运气的时候了，但是果不其然。。。 我成功选择了有炸弹的那一个，从这里面我明白了一个道理，那就是：成功需要 99% 的努力再加上 1% 的运气。。。。。。 原理(思路)布局玩了几句搞清了游戏规则，就想自己动手做一个，因为以前做过 2048，所以首先想到的就是用二维数组布局 添加三个难度的按钮 123&lt;a class="type" href="#" data-width="9" data-height="9" data-mine="10"&gt;简单&lt;/a&gt;&lt;a class="type" href="#" data-width="16" data-height="16" data-mine="40"&gt;中级&lt;/a&gt;&lt;a class="type" href="#" data-width="30" data-height="16" data-mine="99"&gt;高级&lt;/a&gt; 点击相应按钮通过 js 获取对应的 data 属性,然后动态的生成相应的方格,然后动态计算包裹所有小方格的宽度和高度,为了以后方便操作每一个小方格,给每一个小方格按行列添加独有的 id。 盒子对象属性因为扫雷是对每个格子进行操作，因此我把每个格子都看成一个独立的个体，这个个体具有属性和方法，就相当于一个小对象。定义了两个数组 1234// 代表盒子身份的数组var boxArr = []// 用于存储周围八个格子中雷的个数var MineArr = [] 通过这两个数组,我可以知道每个格子是否是炸弹,还有每个格子周围对应八个格子中有多少个炸弹，这属于格子对象的属性。 方法盒子对象还有鼠标按下和抬起的方法，这里要注意，不要给每个盒子都添加事件。假设有 100 个盒子的话，就要添加 100 个事件，事实上高级难度下的盒子话还有更多，这样就不如在 container 上绑定事件，利用冒泡。也可以实现相同的效果，并且只需要绑定一个事件 123container.on('mousedown', '.box', function (e) &#123; $(e.target)//获取点击到的class为box的元素&#125; 有的时候格子的 MineArr 里面存的可能是 0 ,这就代表他周围 8 个方格不存在炸弹,像这种的话就直接将其周围的八个格子直接自动点开就好了,下面这幅图，我只点了一下,就是点到了 MineArr[i][j]==0 的格子,然后让他周围八个直接显示 MineArr 中的数值,如果周围八个格子还有 MineArr[i][j]==0 的情况，就继续打开去显示。 扫雷中还有一个一定要有的方法就是左右键一起按一个点开的格子，会自动判断周围格子中你标记雷的个数和你点击的这个格子的数值。如果你标记雷的个数等于左右键点击的格子中的数值，他会自动帮你点开剩下的还没点击过的格子，这些格子中可能有雷也可能没雷，这要看你自己标记的雷是不是对的。 这个也蛮好实现,右键按下的时候将周围没点击过也没被标记过雷的方格添加带有别的颜色的 class，然后记录周围八个方格标记的雷的个数，然后在右键松开的时候移除此 class,并判断刚记录的标记的雷的个数和当前点击的格子的数值是否相等，然后去做下一步处理。 成功失败判断失败很好判断，点中了 boxArr 为 1 的格子就判失败，就是点中了雷。 成功的话我是通过点击出来的格子的数量来判断的，成功显现的格子只要等于总格子减去雷的格子就判断为游戏胜利 总结虽然是一个比较简单的游戏，但是自己在做的时候还是碰到过不少的 bug,也学到了蛮多的,这里列一下。 清空问题 每次创建新的格子都要清空上次创建的所有格子 我是采用冒泡的方式给盒子添加的点击事件，是添加在 container 上的，然后 container 是不消失的，所以每次创建新格子前还要将 container 上的事件解绑 右键右键在网页上是有默认行为的，在这个游戏中要禁掉 1234//去掉默认的contextmenu事件，否则会和默认右键事件同时出现。document.oncontextmenu = function(e) &#123; e.preventDefault()&#125; each()jquery 中的 each 是不能用 break 跳出的。是用 return false 代替的 break, return true 或 return 代替的 continue 最后还有一些我思路上或者说写法中存在的小 bug,我用相应的方法去解决掉了。大家可以看源码,因为花的时间比较短,可能里面还存在一些问题,还请大佬们多多包涵,也欢迎大佬们来指正。本小白感激不尽，喜欢的话还请点个 :star: 小游戏试玩]]></content>
      <categories>
        <category>Fun</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象类型的辨别]]></title>
    <url>%2F2017%2F08%2F24%2F%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BE%A8%E5%88%AB%2F</url>
    <content type="text"><![CDATA[对象类型的判别不同于基础类型的判别，js 中又有一句话叫万物皆对象，因此对象的判别工作要比基础数据类型要稍微麻烦一点 判断一个对象是不是数组类型typeof少部分人可能首先会想到 typeof 1234567891011121314151617181920var n = 3, b = true, s = 'Hello', x = null, y, obj1 = function() &#123;&#125;, obj2 = &#123;&#125;, obj3 = [], obj4 = new Date();console.log( typeof n, //number typeof b, //boolean typeof s, //string typeof x, //object typeof y, //undefined typeof obj1, //function typeof obj2, //object typeof obj3, //object typeof obj4 //object) 可以看出 typeof 是可以判断出基本数据类型的，函数也能判断出来，但是对象、数组、日期都会返回 object ,这样就根本无法判断一个对象是不是数组类型。所以 typeof 宣告无能为力 判断其父级原型对象1234567var obj1 = &#123;&#125;, obj2 = [1, 2, 3], obj3 = new Date()console.log(obj1.__proto__ === Array.prototype) //falseconsole.log(obj2.__proto__ === Array.prototype) //trueconsole.log(obj3.__proto__ === Array.prototype) //false 但是 __proto__ 是内部属性，本不应该被访问到，我们可以用 Object.getPrototypeOf(obj) 方法来代替他，虽然这个方法其实内部原理也是他，但是还是有不同的。 123console.log(Object.getPrototypeOf(obj1) === Array.prototype) //falseconsole.log(Object.getPrototypeOf(obj2) === Array.prototype) //trueconsole.log(Object.getPrototypeOf(obj3) === Array.prototype) //false 判断其构造函数obj instanceof Array 判断 obj 是不是被构造函数 Array 创造出来的 123console.log(obj1 instanceof Array) //falseconsole.log(obj2 instanceof Array) //trueconsole.log(obj3 instanceof Array) //false 但 instanceof 不仅判断直接父类型，而是所有在原型链上的类型，都返回 true ,所以如果你创建一个对象但是把他的 __proto__ 指向 Array 的原型，然后判断其类型，也会返回 true。 12obj1.__proto__ = Array.prototypeconsole.log(obj1 instanceof Array) //true 判断对象内部的 class 属性每个对象内部，都有一个隐藏的 class 属性，记录该对象创建时的数据类型 class 属性不会随继承关系的改变而改变。（就相当于查人的 DNA，小样还想伪装） 这里有一个问题：内置类型的原型对象中几乎都重写了新的 toString()，只有最顶层的 toString() 才能输出对象的 class 属性值， 因此我们可以用 call 来使用最牛皮的身份鉴别 123456789console.log( Object.prototype.toString.call(obj1) === /*[object Object]*/ '[object Array]') //falseconsole.log( Object.prototype.toString.call(obj2) === /*[object Array]*/ '[object Array]') //trueconsole.log( Object.prototype.toString.call(obj3) === /*[object Date]*/ '[object Array]') //false Array.isArrayArray.isArray 也可以弥补 typeof 的不足 123Array.isArray(obj1) //falseArray.isArray(obj2) //trueArray.isArray(obj3) //false 但其实 isArray 的原理就是判别其内部的 class 123456if (!Array.isArray) &#123; Array.isArray = function(arg) &#123; return Object.prototype.toString.call(arg) === '[object Array]' &#125;&#125;// -- 来自 MDN]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解作用域及闭包]]></title>
    <url>%2F2017%2F08%2F20%2F%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[网络上关于作用域及闭包的文章很多，自己对于纯理论知识并不能很快的理解，但自己对于图画有很强的记忆能力，因此决定将此知识点以图画的知识表现出来，加深自身理解的同时如果能帮到正在学习的童鞋就再好不过了, 下面我以函数的整个生命周期来诉说此部分知识 函数生命周期先写一下示例代码 12345678var a = 10 function func(a) &#123; var a = 20 a++ console.log(a) &#125;func() console.log(a) 开始执行程序前 先创建 ECS，ECS 其实就是专门保存正在调用的函数的执行环境的数组，也可以说对象，其实关联数组也就相当于对象。 然后在 ECS 中添加浏览器主程序的执行环境 main 创建全局作用域对象 window main 执行环境引用 window 定义函数时 原始类型的全局变量会直接存入 window 环境当中，因为函数是引用类型，所以首先用函数名声明全局变量 然后创建函数对象，封装函数定义 函数对象的 scope 属性，指回函数创建时的作用域，意思是，函数执行时如果函数本身提供的变量不能让函数执行完全，那它便会去回它创建时的那个作用域去寻找变量。 函数名后面存入指向函数对象的地址 引用类型在其中只能存储地址，这个在此笔记谈谈值传递中有详细说明 函数调用时 向 ECS 中压入本次函数调用的执行环境元素 创建本次函数调用时使用的函数作用域对象（AO），也就是临时作用域 在 AO 中创建储存所有的局部变量，包括形参变量和函数内用 var 声明的变量 设置 AO 的 parent 属性和引用函数的 scope 属性指向父级作用域对象 函数的执行环境引用 AO 顺着那个箭头，先在 AO 中找变量，也就是局部变量，如果 AO 中没有，再顺着箭头去父级作用域中找 函数调用后 函数的执行环境出栈，AO 释放，AO 中的局部变量一同被释放掉。 我们得知整个结果之后，自然而然那两个 console 的结果也显然意见。 闭包前面我们提到过，全局变量是可重用但是污染全局，局部变量不会污染全局但是不可重用。 我自己认为闭包就是重用变量又保护变量不被污染的机制，就是为了解决这一情况而生的。 特点包裹受保护的变量和操作变量的内层函数的外层函数 外层函数要返回内层函数的对象 return function(){..} 直接给全局变量赋值一个内部 function 将内部函数保存在一个对象的属性或数组元素中 return [function function function] 或 return {fun:function(){...}} 调用外层函数，用外部变量接住返回的内层函数对象,形成闭包。 原理先贴出示例代码 123456789101112function outer() &#123; var num = 1 return function() &#123; console.log(num++) &#125; &#125;var getNum = outer() getNum() getNum() num = 1 getNum() 下面我把闭包形成的原理用画图工具画出来 window 中存入 outer 名并指向 outer 函数对象，getNum 因为声明提前也先将变量名存在 window 中。 getNum = outer() 其实包含 outer 的创建和 getNum 的赋值。 上面的图画的是 outer 函数进行到 var num = 1 ,前面都有说过，不过多重复。 创建了匿名函数，getNum 指向了匿名函数对象，匿名对象的 scope 指向它的父级作用域，也就是 outer 的作用域，那这样就形成了图中的三角关系，此时 outer 执行完毕，离开 ECS 执行环境，outer 的 AO 本也应该随着离开，但是因为这强大的三角关系，强行拉住不让其释放，也就形成了所谓的闭包。 那其实闭包的原因就是:外层函数的作用域对象无法释放 getNum=outer()getNum 其实就是一个函数 调用getNum(),会生成 getNum 的临时作用域,图中可看出,getNum 其实就是在 outer 中的匿名函数，所以他的 parent 就指向 outer 留下的作用域。当他执行 console.log(num++) 的时候，在他的作用域中没有 num 变量他就会顺着作用域链去寻找，最终在 outer 中的作用域中找到 num 并对其进行自加操作。所以当下次调用 getNum 的时候 num 会从 2 开始，不会是一开始的 1。 num 不是全局变量，还实现了 num 变量的重复调用。就达到了闭包的目的。 设置 num = 1 只是在 window 对象上添加存储 num 的值，当下次调用 getNum 的时候 js 引擎还会从 getNum 作用域开始顺着作用域链寻找 num,在 outerAO 就会寻找到 num,所以根本不会影响到 window 中的 num,也不会受其影响。因此此段代码输出的结果为 1 2 3。 缺点当然闭包也有其缺点 比普通函数占用更多内存，因为外层函数的作用域对象（AO）始终存在 容易造成内存泄漏 解决办法将引用内存函数对象的外部变量重置为 null 1getNum = null getNum 指向 outer 函数对象的那根线就会断掉，三角关系破裂，那函数对象和 outerAO 也会相继被销毁。]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Deep</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js 函数基础]]></title>
    <url>%2F2017%2F08%2F17%2Fjs%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[每天都在和函数打交道，到底函数是个啥，还有啥隐藏的秘密吗 函数的定义函数其实就是一个封装一段代码段的对象，函数名其实仅是用来引用函数对象的一个普通变量,写代码的时候我们避免不了要重复用一些代码，一直重复写很耗时，而且不美观也不利于维护，因此函数的出现就是来让代码重用，便于维护。一段可能被反复使用的代码，就可以定义为函数，然后调用函数来使用这段代码。 函数的创建function 声明 1234function 函数名(参数列表) &#123; 函数体 return 返回值&#125; 直接量声明 1234var 函数名 = function(参数列表) &#123; 函数体 return 返回值&#125;; 用 new 创建 因为 Function 是内置类型，本身有一个 Function 的构造函数，所以是可以 new 的 1var 函数名 = new Function("参数名1","参数名2",...,"函数体; return 返回值") 这里注意，参数和函数体都要用引号引起来，但是一般函数的创建都不会这样创建，以前面的两种为主，那其实前面两种的创建是存在一定的差别的，下面会提到 函数的参数函数执行时必须的数据变量，它分为「 显示参数 」(Parameters)与「 隐式参数 」(Arguments) 显示参数123function fun(name, id) &#123; //函数体&#125; 这种直接传进来的 name 和 id 就是显示参数，也就是你能看到的。其实函数传递的参数就相当于在函数体内又声明了一个局部变量 123456var i = 10function fun(i) &#123; i++ console.log(i)&#125;fun(i) 上面的代码，就相当于下面的代码 1234567var i = 10function fun() &#123; var i = 10 //这个值就是传进来的参数的值 i++ console.log(i)&#125;fun(i) //在此处传入i 隐式参数每个 JavaScript 函数内部都有一个对象 arguments 对象,其实是一个类数组的对象,它会自动接受所有传入函数的参数值。 123function func( ) &#123; //arguments[ ]&#125; 值得一说的是, arguments 有下标有长度，可以通过下标来获得传入的参数，比如 arguments[0] 就是第一个参数, length 就可以遍历这个类数组对象，但是，毕竟他不是数组，所以不能进行一些数组特有的操作，比如 sort 声明提前在开始执行程序前,js 引擎会首先查找 var 声明的变量和 function 声明的函数，将其提前到当前作用域的顶部集中创建，而将赋值操作保留在原地,这里特别说一下, 未用 var 声明的变量不会声明提前. 12console.log(a) //a is not defineda = 10 123console.log(a) //undefinedvar a = 10console.log(a) //10 因为声明提前,其实代码会变成下面这个样子 1234var aconsole.log(a)a = 10console.log(a) 这样看，一切都变得很合理。。 函数也是一样 12345678function fun() &#123; console.log(1)&#125;fun() //2function fun() &#123; console.log(2)&#125;fun() //2 控制台会输出两个 2,因为 function 声明的函数也会声明提前,代码其实是下面这个样子 12345678function fun() &#123; console.log(1)&#125;function fun() &#123; console.log(2)&#125;fun() //2fun() //2 第二次声明因为与第一次声明方法名字一样，后者覆盖了前者，所以再调用的时候就会调用最后这个 但是声明提前会增加程序解读的难度，因此我们在写程序时，尽量避免声明提前所带来的危害 声明提前的解决方法那我们既然知道会有声明提前这种操作，就在变量和函数的声明时都放在当前作用域的顶部。 在 ES6 中 可以用 let 代替 var,不过要求在当前作用域中 let 变量之前不允许出现声明的变量, 也可以用直接量声明变量的方法 12345678var fun = function() &#123; console.log(1)&#125;fun() //1var fun = function() &#123; console.log(2)&#125;fun() //2 这种当然也会声明提前，那我们看一下声明提前后的代码 12345678910var funvar funfun = function() &#123; console.log(1)&#125;fun() //1fun = function() &#123; console.log(2)&#125;fun() //2 声明提前但是赋值还是留在原地，所以虽然有声明提前，但是并不会改变我们原本想要的结果。也就解决了声明提前带来的危害。 匿名函数函数创建时没有指定函数名,匿名函数使用后自动释放,会节约内存,他会划分临时作用域，避免全局变量污染全局。 用处callback 将一个函数作为参数传入另一个函数内，被其他函数调用 举个:chestnut: 123arr.sort(function(a, b) &#123; return a - b&#125;) 1str.replace(/reg/g, function(kw,$1,$2,...)&#123;return 替换值&#125;) 自调 定义函数后自己调用自己，调用结束后，立刻释放，不占内存 举个:chestnut: 1234(function(参数列表) &#123; 函数体 return 返回值&#125;)(参数值列表) 会定义一个临时的作用域，减少使用全局变量，避免全局污染。 重载相同函数名，不同参数列表的多个函数。在调用时，根据传入参数的不同，自动选择匹配的函数执行。这样可以减少 api 的数量，减轻调用者的负担。 听起来很诱人，但是 Js 语法不支持重载，原因是 Js 不允许多个同名函数同时存在，后声明的函数会覆盖前面声明的,但是可以通过某些方法实现，这个方法就是利用 arguments 123456789function test() &#123; if (arguments.length == 0) &#123; //不传值的操作 &#125; else if (arguments.length == 1) &#123; //传一个值进行的操作 &#125; else &#123; //....等等 &#125;&#125; 其实也不是真正意义上的重载，因为并没有创建同名的多个函数，但是实现的效果是和重载差不多的。]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你好！BFC!]]></title>
    <url>%2F2017%2F08%2F09%2F%E4%BD%A0%E5%A5%BD%EF%BC%81BFC%2F</url>
    <content type="text"><![CDATA[BFC 这个名字听过很多次了，文章中总是说触发 BFC 然后怎样怎样，开始的时候觉得 BFC 很神秘，应该很难，当时只为解决眼前问题的我，就没有选择去了解一下 BFC，只是知道有 BFC 的存在，但并不认识他，今天终于鼓起勇气想他打个招呼，认识认识这位看似神秘的朋友. 文档流我们常说的文档流分为三种，普通流，浮动流和定位流。在这里简单的介绍一下。 在「普通流」中，元素按照在 HTML 中的先后位置至上而下布局，块级元素从上到下依次排列，框之间的垂直距离由框的垂直 margin 计算得到。行内元素在一行中水平布置，直到占满一行则换行 「浮动流」就是元素被设置了浮动属性，一开始还是按照普通流布局，但是会根据浮动的方向移动。 「定位流」就是设置了定位属性，元素完全脱离普通流。 BFC 定义BFC(Block Formating Context),直译过来就是「 块级格式化上下文 」(在 CSS3 中，BFC 叫做 Flow Root)。FC 就是其实就是普通流的意思，是一块渲染区域，有他的渲染规则。那 B 就是 block 就是块级元素。简单的理解来说，有一块独立的渲染区域，只有 block 元素，这些 block 元素按照此渲染区域的规则布局，并且不受这个区域外部的其它元素影响。 BFC 的触发 根元素 浮动元素 绝对定位和固定定位 display 为 inline-block||table-cell||table-caption||flex||inline-flex overflow 不是 visible 满足以上任意一个条件都可以触发 BFC，这里注意一下，触发 BFC 不是元素本身变成了 BFC，而是这个元素带有了 BFC 的规则。 BFC 的规则为什么要触发 BFC，那 BFC 到底有什么规则，有什么好处呢？ Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 的区域不会与 float box 重叠。 计算 BFC 的高度时，浮动元素也参与计算 作用其实 BFC 完全贯彻的一点就是，BFC 是一个独立的不受外部影响的一个渲染区域，他也不会去影响别的元素。，记住并理解这句话也就是理解了 BFC ，因为 BFC 的作用都是根据这一规则产生的 margin 重叠123456.box &#123; background-color: red; margin: 100px; width: 100px; height: 100px;&#125; 12&lt;div class="box"&gt;box1&lt;/div&gt;&lt;div class="box"&gt;box2&lt;/div&gt; 我们知道两个 box1 和 box2 的中间间距会发生 margin 重叠并只有 100px,那是因为他们同在 html 下的一个大的 BFC 中的一个渲染区域中，我们只要让他们两个的 BFC 区域不同，他们两个就不会发生 margin 重叠. 在 box2 添加 div 包裹层,然后在此包裹层中添加任意规则属性，就会发现 margin 重叠问题已经解决.因为此时 box2 身处的 BFC 和 box1 就不相同了。 清除浮动剩下两个规则都与浮动有关，其实我听说 BFC 这个名词也是因为清除浮动，因为 BFC 不能影响外部的布局，所以计算高度时，浮动也参加运算，因此就解决了高度塌陷这个问题。 总结前端之路还在继续，认识了 BFC 以后也会去多多了解磨合。总之现在严格记住的一点就是他是一个独立的不影响外部也不受外部影响的区域，那其他的特性都是建立在此基础上的。]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈值传递]]></title>
    <url>%2F2017%2F07%2F25%2F%E8%B0%88%E8%B0%88%E5%80%BC%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[ECMAScript 变量可能包含两种不同的数据类型：「基本数据类型」和「引用数据类型」，这两种类型的值传递是存在不同的.在我们谈这两种数据类型的值传递前，为了便于理解，我想首先谈一下这两种数据类型有关复制操作存在的不同 数据类型的复制基本类型12345var num1 = 10 var num2 = num1 num2 = 11 console.log(num1) //10console.log(num2) //11 基本数据类型从一个复制到另一个，会在变量对象上创建一个新值，然后把该值复制到新变量分配的位置上，改变其中一个不会影响另一个。 本小白用拙劣的画功演示一下 一开始声明变量 num1 并赋值为 10,它便以图中的形式存放在栈内存中，当用 num1 的值来初始化 num2 的时候，此时就相当于声明变量 num2 并赋值为 num1 中的值，该值只是 num1 中的一个副本，赋值结束，这两个变量便再无瓜葛，进行后面的操作也不会相互影响 引用类型引用类型我们采用数组来讲解，数组的声明有两种方式，一种为 var 数组名 = [] 另一种为 var 数组名 = new array() 12345var arr1 = [1, 2, 3, 4] var arr2 = arr1 arr2[0] = 10 console.log(arr1) //[10,2,3,4]console.log(arr2) //[10,2,3,4] 可以看出输出的结果都为 [10,2,3,4]， 和基本数据类型完全不同。数组的存储方式如下图所示 当声明数组变量并赋值的时候，同样也会存入一个栈结构当中，但是这个栈结构不能存 [1,2,3,4] 这种引用类型的数据，要存到堆内存中去，就是图片右边那个圆形的区域，但是存入的数据还是要找到它，因为每个存储位置都有其相应的地址，所以它在栈内存中存入的是一个指向数组对象数据的这样的一个地址。 因此当复制引用类型变量的时候，同样也会将存储在栈内存中的地址值复制一份放到为新变量分配的空间中去，只不过因为这个值的副本是一个指向堆中原数组对象数据的地址，两个变量名就相当于引用了同一个地址中的内容。因此，改变其中的一个，就相当于改变了另一个。 再看下面这个:chestnut: 12345var arr3 = [1, 2, 3, 4] var arr4 = arr3 arr4 = [5, 6, 7, 8] console.log(arr3) //[1,2,3,4]console.log(arr4) //[5,6,7,8] 这个相比于前面那个，只是在第三行代码中出现了不同，arr4 = [] 这样也是创建数组的一种方式，因此 arr4 = [5,6,7,8] 其实是将一个新创建的数组对象赋给变量 arr4 ,这时 arr4 后的地址就改变了,也就指向了新的数组对象，这两个变量也就完全不相同了. 方便理解可以看下下面的代码 1console.log(new Array(1,2) === new Array(1,2)) //false 那好，现在有了这些铺垫，我们再来谈我们今天的主要内容. 数据类型的值传递基本类型123456789var num = 10 function change(num) &#123; num = 11 console.log(num) //11&#125;change(num) console.log(num) //10 在向参数传递基本类型的值时，被传递的值会被先复制给一个局部变量，其实就可以理解为基本数据类型的赋值。以上的代码也可以写为这样 12345678910var num = 10 function change() &#123; var num = 10 //look num = 11 console.log(num) //11&#125;change(num) console.log(num) //10 在 look 处，函数会将参数先声明并赋值，值就为下面传入的参数的值，num 的值为 10,因此赋得值也为 10。但此时函数中的 num 和函数外部的 num 其实是毫不相关的，因此并不会相互影响 引用类型123456789var arr = [1, 2, 3, 4] function change(arr) &#123; arr[0] = 10 console.log(arr) //[10,2,3,4]&#125;change(arr) console.log(arr) //[10,2,3,4] 引用类型也如此，也可以理解为引用类型的复制操作，在函数的开头就会将 arr 赋值为传来的数值，虽然也是一开始声明的引用类型的副本，但是因为引用类型传来的数值是地址，因此函数中的 arr 和函数外面的 arr 都将引用同一个地址中的数组对象，因为 arr 指向的数组对象在堆中只有一个，又是全局变量，因此这两个 arr 是相同的，同样我们再看那一种声明数组并赋值的. 123456789var arr = [1, 2, 3, 4] function change(arr) &#123; arr = [4, 5, 6, 7] console.log(arr) //[4,5,6,7]&#125;change(arr) console.log(arr) //[1,2,3,4] 那这个也就应该可以理解了，虽然在传参的时候传入的确实是一开始声明的数组对象的地址的副本，但是因为在函数内部又声明了一个新的数组对象，在这里 arr 引用的就是一个局部的数组对象了，而这个局部对象就会在函数结束后立即被销毁，不会影响函数外部的数组对象]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Js</tag>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于css实现div居中问题]]></title>
    <url>%2F2017%2F07%2F18%2F%E5%85%B3%E4%BA%8Ecss%E5%AE%9E%E7%8E%B0div%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[自己最近在做有关 css 居中时发现自己不能准确的找到居中的解决方案，虽然最后也能试出解决方案，但是感觉必须深入其中，了解各个居中方案的适用场景，才能准确的写出不多余又正确的 css 代码 示例代码123&lt;div class="header"&gt; &lt;div class="nav"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011* &#123; margin: 0; padding: 0;&#125;.header &#123; height: 70px;&#125;.nav &#123; height: 70px; background: red;&#125; 当需要居中的 div 设置了固定宽度margin123456.nav &#123; height: 70px; background: red; width: 300px; margin: 0 atuo;&#125; auto 可以理解为一样的意思，如果左右都设置 auto，意思就是这个 div 离左面的距离和右面的距离是一样的,但是此方法只适用于设置了宽度的块级元素。 但是如果你设置了以下几种属性时，其居中效果便会消失 postion: absolute float display:inline 块级元素始终独占一行，无论是否设置了宽度，未设置宽度时他会自动充满，设置了宽度时，虽然他看起来这一行并不都是他的「地盘」，但是你如果在他后面添加元素的时候，你会发现元素会被挤到下一行去。 1234&lt;div class="header"&gt; &lt;div class="nav"&gt;&lt;/div&gt; 咋回事啊&lt;/div&gt; 怎么肥四，为森么会发生这种情况呢，看一下下面一张图 可以看到，虽然 div 设置了宽度，但是他有一种无形的力量占据了他所在的行的剩下的空间，以至于其它元素无法与其在一行。而这一块橙色区域也就是 margin: 0 auto 可调控区域，auto 会根据这一部分的大小及时分配左右的距离，达到居中的效果，当设置了绝对定位、浮动或将其设置为行内元素的时候，他这种「威慑力」便会消失，auto 可分配的区域便会消失 可以看到，此时那块黄色的区域已经消失，margin: 0 atuo 也就随之失效了 不过也有一种例外 123456789.nav &#123; height: 70px; background: red; width: 300px; position: absolute; left: 0; right: 0; margin: 0 atuo;&#125; 此时虽然已经设置绝对定位，div 也已经脱离了标准文档流，但是 left:0 right:0 又让其具有了那种「威慑力」，margin: 0 auto 也就又拥有了可调控的区域 绝对定位12345678.nav &#123; height: 70px; background: red; width: 300px; position: absolute; left: 50%; margin-left: -150px;&#125; 设置绝对定位让其 left 属性起作用，然后设定 left:50%，但是因为此 div 本身还有宽度，因此还要添加 margin-left:-此div宽度的一半px; 让其真正的居中 需要居中的 div 没有宽度很多状况下我们要居中的元素是不知道宽度的，有时候可能宽度也不是固定的，因为里面的内容有可能以后要增加，或者随着浏览器的变化此宽度可能也要跟随变化，下面将示例代码的 css 改为如下形式 1234.nav &#123; height: 70px; background: red;&#125; 可以看到，当不设置宽度的时候，此 div 默认是充满整个浏览器的，这样的话就无所谓居中或不居中了，通常我们要居中这个 div，是想让这个 div 中的一些信息居中，为了便于演示，我在 html 和 css 中多添加了几行代码 12345678910&lt;div class="header"&gt; &lt;div class="nav"&gt; &lt;ul&gt; &lt;li&gt;热爱前端&lt;/li&gt; &lt;li&gt;热爱编程&lt;/li&gt; &lt;li&gt;热爱生活&lt;/li&gt; &lt;li&gt;渴望知识&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920* &#123; margin: 0; padding: 0;&#125;.header &#123; height: 70px;&#125;.nav &#123; height: 70px; background: red; line-height: 70px; color: #fff;&#125;ul &#123; list-style: none;&#125;li &#123; float: left; margin-left: 30px;&#125; 效果图 此时我们应该想办法让 div 的宽度不是充满整个浏览器，让它的宽度仅仅就是里面内容的宽度，这样我们才能让它居中。在块状元素下，如果不设置宽度，它始终是要充满整个屏幕的。 1234567.nav &#123; height: 70px; background: red; line-height: 70px; color: #fff; display: inline-block;&#125; 当设置 nav 为行内元素，或者 table 元素的时候他的宽度就默认不是最大化，而是根据包裹的内容改变，也就是最小化。设置为 position 或者 display:table 也一样。 text-align:center用 text-align:center 实现元素居中，这个属性不是只能让文本元素居中，它可以让行内元素居中，所以只要把要居中的元素设置为行内元素，然后向其父元素添加 text-align:center 属性，就可以实现居中 1234567891011.header &#123; height: 70px; text-align: center;&#125;.nav &#123; height: 70px; background: red; line-height: 70px; color: #fff; display: inline-block;&#125; display:table设置 nav 为 display:table ,nav 就相当于说就具有了 table 的属性，那我们都知道 table 的宽度是根据其内容的多少而变化的，也就是宽度最小化，而此时 nav 便也可以使用 margin:0 auto 来居中 12345678.nav &#123; height: 70px; background: red; line-height: 70px; color: #fff; display: table; margin: 0 auto;&#125;]]></content>
      <categories>
        <category>Explore</category>
      </categories>
      <tags>
        <tag>Css</tag>
        <tag>Base</tag>
      </tags>
  </entry>
</search>
