{"componentChunkName":"component---src-templates-post-detail-tsx","path":"/series/design-pattern/post-1565302837000","result":{"data":{"site":{"siteMetadata":{"title":"Silence","author":"默尝"}},"markdownRemark":{"id":"667cecf1-40be-56b3-8ee9-1107bda25881","excerpt":"单一职责原则 SRP「Single responsibility principle…","html":"<blockquote>\n<p>单一职责原则 SRP「Single responsibility principle」：就一个类而言，应该仅有一个引起它变化的原因。修改代码总是一件危险的事情，特别是当两个职责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏。因此一个对象（方法）只做一件事情</p>\n</blockquote>\n<h2>何时应该分离职责</h2>\n<p>要明确的是，并不是所有的职责都应该一一分离</p>\n<p>一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 请求几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开</p>\n<p>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦 合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的 时候再进行分离也不迟</p>\n<h2>优缺点</h2>\n<h3>优点</h3>\n<p>降低了单个类或者对象的复杂度，按照职责把对象分解成更小的粒度，这有助于代码的复用，也有利于进行单元测试。当一个职责需要变更的时候，不会影响到其他的职责</p>\n<h3>缺点</h3>\n<p>明显的增加编写代码的复杂度。当我们按照职责把对象分解成更小的粒度后，实际上也增大了这些对象之间相互联系的难度。</p>\n<p>jQuery 的 attr 是个非常庞大的方法，既负责赋值又负责取值，这对于 JQuery 的维护者来说，会带来一些困难，但对于 jQuery 的用户来说，却简化了用户的使用</p>","frontmatter":{"title":"单一职责原则","date":"August 08, 2019"}}},"pageContext":{"slug":"/design-pattern/dan-yi-zhi-ze-yuan-ze/","previous":{"fileAbsolutePath":"/Users/test/gitMaster/Silence/content/series/design-pattern/shi-pei-qi-mo-shi.md","frontmatter":{"date":"2019-08-07T22:20:37.000Z","title":"适配器模式"},"fields":{"slug":"/design-pattern/shi-pei-qi-mo-shi/"}},"next":{"fileAbsolutePath":"/Users/test/gitMaster/Silence/content/series/design-pattern/zui-shao-zhi-shi-yuan-ze.md","frontmatter":{"date":"2019-08-09T22:20:37.000Z","title":"最少知识原则"},"fields":{"slug":"/design-pattern/zui-shao-zhi-shi-yuan-ze/"}},"prePath":"/series/design-pattern/post-1565216437000","nextPath":"/series/design-pattern/post-1565389237000"}},"staticQueryHashes":["1747850863","63159454"]}