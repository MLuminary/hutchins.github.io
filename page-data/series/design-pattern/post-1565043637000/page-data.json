{"componentChunkName":"component---src-templates-post-detail-tsx","path":"/series/design-pattern/post-1565043637000","result":{"data":{"site":{"siteMetadata":{"title":"Silence","author":"默尝"}},"markdownRemark":{"id":"8dc97e7e-5a32-5296-9b27-b69a9c76c930","excerpt":"装饰者模式也称为包装模式「Wrapper Pattern…","html":"<blockquote>\n<p>装饰者模式也称为包装模式「Wrapper Pattern」：给对象动态的增加职责的方式称为装饰者模式，装饰者模式能够在不改变对象自身的基础上，在程序运行期间给对象动态地添加职责。跟继承相比，装饰者是一种更轻便灵活的做法，这是一种「即用即付」的方式，比如天冷了就多穿一件外套</p>\n</blockquote>\n<h2>模式动机</h2>\n<p>在传统的面向对象语言中，给对象添加功能常常使用继承的方式，但是继承的方式并不灵活， 还会带来许多问题：一方面会导致超类和子类之间存在强耦合性，当超类改变时，子类也会随之改变；另一方面，继承这种功能复用方式通常被称为「白箱复用」，「白箱」是相对可见性而言的， 在继承方式中，超类的内部细节是对子类可见的，继承常常被认为破坏了封装性。</p>\n<h2>实现</h2>\n<p>假设有一个登录 <code class=\"language-text\">button</code>, 点击 <code class=\"language-text\">button</code> 会弹出登录浮层，与此同时要进行数据上报，来统计有多少用户点击了这个登录 <code class=\"language-text\">button</code></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showLogin</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">'打开登录浮层'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">log</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">'上报数据'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\nbutton<span class=\"token punctuation\">.</span>onclick <span class=\"token operator\">=</span> showLogin</code></pre></div>\n<p>我们看到在 <code class=\"language-text\">showLogin</code> 函数里，既要负责打开登录浮层，又要负责数据上报，这是两个层面的功能，在此处却被耦合在一个函数里。而且我们当不需要统计的时候还必须在 <code class=\"language-text\">showLogin</code> 里找到 <code class=\"language-text\">log()</code> 并删除掉，假如多出都进行统计，这样是很麻烦的事情。</p>\n<h3>AOP 装饰函数</h3>\n<p>首先提供 <code class=\"language-text\">after</code> 与 <code class=\"language-text\">before</code> 两个方法，可以在不改变函数本身的情况下动态给此函数添加新功能</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">before</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">beforefn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> __self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span> <span class=\"token comment\">// 保存原函数的引用</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">beforefn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 执行新函数，且保证 this 不被劫持，新函数接受的参数也会被原封不动地传入原函数，新函数在原函数之前执行</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">__self</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span> <span class=\"token comment\">// 执行原函数并返回原函数的执行结果</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token class-name\">Function</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function-variable function\">after</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">afterfn</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> __self <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> ret <span class=\"token operator\">=</span> <span class=\"token function\">__self</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span>\n    <span class=\"token function\">afterfn</span><span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> ret\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>分离业务代码和数据统计代码，无论在什么语言中，都是 AOP 的经典应用之一。在项目开发的结尾阶段难免要加上很多统计数据的代码，这些过程可能让我们被迫改动早已封装好的函数，当有了装饰函数，上面的代码就可以写成如下这般</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">showLogin</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">'打开登录浮层'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">log</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">info</span><span class=\"token punctuation\">(</span><span class=\"token string\">'上报数据'</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\nbutton<span class=\"token punctuation\">.</span>click <span class=\"token operator\">=</span> showLogin<span class=\"token punctuation\">.</span><span class=\"token function\">after</span><span class=\"token punctuation\">(</span>log<span class=\"token punctuation\">)</span></code></pre></div>\n<p>可以看到我们无需改动 <code class=\"language-text\">showLogin</code> 就可以在点击 <code class=\"language-text\">button</code> 时既打开登录浮层又计数。</p>\n<h2>小结</h2>\n<h3>优点</h3>\n<p>可以提供比继承更多的<strong>灵活性</strong>，可以通过一种<strong>动态的</strong>方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类。</p>\n<h3>缺点</h3>\n<p>使用装饰模式进行系统设计时将产生<strong>很多小对象</strong>，而且装饰模式比继承更加易于出错，<strong>排错也很困难</strong>，对于多次装饰的对象，调试时寻找错误可能需要<strong>逐级排查</strong>，较为烦琐。</p>","frontmatter":{"title":"装饰者模式","date":"August 05, 2019"}}},"pageContext":{"slug":"/design-pattern/zhuang-shi-zhe-mo-shi/","previous":{"fileAbsolutePath":"/Users/test/gitMaster/Silence/content/series/design-pattern/zhong-jie-zhe-mo-shi.md","frontmatter":{"date":"2019-08-04T22:20:37.000Z","title":"中介者模式"},"fields":{"slug":"/design-pattern/zhong-jie-zhe-mo-shi/"}},"next":{"fileAbsolutePath":"/Users/test/gitMaster/Silence/content/series/design-pattern/zhuang-tai-mo-shi.md","frontmatter":{"date":"2019-08-06T22:20:37.000Z","title":"状态模式"},"fields":{"slug":"/design-pattern/zhuang-tai-mo-shi/"}},"prePath":"/series/design-pattern/post-1564957237000","nextPath":"/series/design-pattern/post-1565130037000"}},"staticQueryHashes":["1747850863","63159454"]}