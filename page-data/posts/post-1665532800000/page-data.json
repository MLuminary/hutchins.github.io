{"componentChunkName":"component---src-templates-post-detail-tsx","path":"/posts/post-1665532800000","result":{"data":{"site":{"siteMetadata":{"title":"Silence","author":"默尝"}},"markdownRemark":{"id":"faa51817-3da4-5008-ba03-2d04f9f98046","excerpt":"react 是用于构建用户界面的 JavaScript 库 结构 React 仓库中与 web 开发相关的核心包只有四个 react: 在编写 React 应用时，引用的函数基本都来自这个包，提供了编写 React 组件必备的函数 scheduler: 调度机制的核心实现，负责调度不同优先级的任务 react…","html":"<blockquote>\n<p>react 是<strong>用于构建用户界面的 JavaScript 库</strong></p>\n</blockquote>\n<h2>结构</h2>\n<p>React 仓库中与 web 开发相关的核心包只有四个</p>\n<ul>\n<li>react: 在编写 React 应用时，引用的函数基本都来自这个包，提供了编写 React 组件必备的函数</li>\n<li>scheduler: 调度机制的核心实现，负责调度不同优先级的任务</li>\n<li>react-reconciler:  接受 react 包提供的函数调用的输入，生成任务由 scheduler 调度，最终产物交给 react-dom</li>\n<li>react-dom: react 渲染器之一，负责将 react-reconciler 的产物输出到 web 界面中</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/dcb21d56455b158b6a9f1f486c9e407a/88463/react.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.756756756756754%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABhklEQVQY00WR204TURRA++c+GU30QSUGTUkaDSUqeAUjilNa2mlaaLCFQsBgqLbYuZ05Z+bMrSVmeYoPfsBee629S739nO2thP63gijNkEmBkpLgYBPfXkdNLhDpnCTJGTguK6cDqucnXKkYGaeEaY7X7fNr4yNeo0tpd6egWklpNQriLEOZYRUKhFVGfHqA/DFgLDS+F2JfTbh1aHPv6ICRkLi+xDNQ9/Meo6UKzpttSo3ajNdr17RbBVJrgigjFAG69Zyk9gQ1GiKya1Kd03Wm3D09ZOn8iLEx1MZa5TN8y8ZdeYH3YWcBLNiozrGbBdNAMHYEgecSN58RW8tEBiiLP+TZ7AZ456THozNjrSIDNBIG6BmgU17DfW+AdWvG+uqcdnORbDZm/5LjvQraeoy6PMbTM7RJ6zi/uT3s8fCsz0+pCJVGGEv/awvnaRX33RdKzXrB25dzOu3/T5ELoL2KrpcJL4dMzA2DQLJvDO+b5OXvxzc3nLoCN0rwdzs4lVd4WzX+Aivrqe+Ub6o0AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"React 包结构@2x.png\"\n        title=\"React 包结构@2x.png\"\n        src=\"/static/dcb21d56455b158b6a9f1f486c9e407a/fcda8/react.png\"\n        srcset=\"/static/dcb21d56455b158b6a9f1f486c9e407a/12f09/react.png 148w,\n/static/dcb21d56455b158b6a9f1f486c9e407a/e4a3f/react.png 295w,\n/static/dcb21d56455b158b6a9f1f486c9e407a/fcda8/react.png 590w,\n/static/dcb21d56455b158b6a9f1f486c9e407a/efc66/react.png 885w,\n/static/dcb21d56455b158b6a9f1f486c9e407a/c83ae/react.png 1180w,\n/static/dcb21d56455b158b6a9f1f486c9e407a/88463/react.png 3656w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h2>React</h2>\n<p>React 中包含所有<a href=\"https://zh-hans.reactjs.org/docs/react-api.html#react\">全局 <code class=\"language-text\">React</code> API</a>，比如：React.createElement</p>\n<p>我们日常编写的 JSX 在编译时就会转化为 <code class=\"language-text\">React.createElement</code> 方法，这也是为什么在每个 JSX 的文件中你必须显示声明</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">import</span> React <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span></code></pre></div>\n<p><code class=\"language-text\">React.createELement</code> 最终会调用 <code class=\"language-text\">ReactElement</code> 方法返回一个包含组件数据的对象，也就是 <code class=\"language-text\">React Element</code> 对象</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token function\">createElement</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> config<span class=\"token punctuation\">,</span> children</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> propName<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">const</span> props <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">let</span> key <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> ref <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> self <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">let</span> source <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>config <span class=\"token operator\">!=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 将 config 处理后赋值给 props</span>\n    <span class=\"token comment\">// ...省略</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> childrenLength <span class=\"token operator\">=</span> arguments<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 处理 children，会被赋值给props.children</span>\n  <span class=\"token comment\">// ...省略</span>\n\n  <span class=\"token comment\">// 处理 defaultProps</span>\n  <span class=\"token comment\">// ...省略</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token function\">ReactElement</span><span class=\"token punctuation\">(</span>\n    <span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span>\n    key<span class=\"token punctuation\">,</span>\n    ref<span class=\"token punctuation\">,</span>\n    self<span class=\"token punctuation\">,</span>\n    source<span class=\"token punctuation\">,</span>\n    ReactCurrentOwner<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">,</span>\n    props<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ReactElement</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">type<span class=\"token punctuation\">,</span> key<span class=\"token punctuation\">,</span> ref<span class=\"token punctuation\">,</span> self<span class=\"token punctuation\">,</span> source<span class=\"token punctuation\">,</span> owner<span class=\"token punctuation\">,</span> props</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> element <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 标记这是个 React Element</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token constant\">REACT_ELEMENT_TYPE</span><span class=\"token punctuation\">,</span>\n\n    <span class=\"token keyword\">type</span><span class=\"token operator\">:</span> <span class=\"token keyword\">type</span><span class=\"token punctuation\">,</span>\n    key<span class=\"token operator\">:</span> key<span class=\"token punctuation\">,</span>\n    ref<span class=\"token operator\">:</span> ref<span class=\"token punctuation\">,</span>\n    props<span class=\"token operator\">:</span> props<span class=\"token punctuation\">,</span>\n    _owner<span class=\"token operator\">:</span> owner<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> element<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>React 核心只包含定义组件必要的 API</strong>。它不包含 Reconciler 算法或者其他平台特定的代码。它同时适用于 React DOM 和 React Native 组件</p>\n<h2>React Dom</h2>\n<p>服务于 Dom 的渲染器，<strong>作用就是将 React 组件渲染成 Dom</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\">ReactDOM<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">App</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">,</span> document<span class=\"token punctuation\">.</span><span class=\"token function\">getElementById</span><span class=\"token punctuation\">(</span><span class=\"token string\">'root'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p>这行代码的意思就是将名为 <code class=\"language-text\">App</code> 的 React 组件渲染到 <code class=\"language-text\">id</code> 为 <code class=\"language-text\">root</code> 的根 dom 节点中去，此时 React DOM 拿到所有 <code class=\"language-text\">ReactElements</code> 就会去交给 reconciler ，最后拿到 reconciler 的输出再负责最后的渲染，<strong>因此 React Dom 在此起到了一个连接点的作用</strong>。</p>\n<p>Fiber 树的渲染可以划分为三阶段，即渲染前，渲染，渲染后。想知道 Fiber 树如何构建的可以先移步下面的 React Reconciler </p>\n<h3>渲染前</h3>\n<p>这一阶段主要是为真正的渲染做一些准备</p>\n<ol>\n<li>处理 blur 和 focus 相关逻辑</li>\n<li>设置全局状态</li>\n<li>重置全局变量</li>\n<li>调用该阶段生命周期方法，例如<code class=\"language-text\">getSnapshotBeforeUpdate</code></li>\n<li>调度 <code class=\"language-text\">useEffect</code> （注意是调度，不是调用）</li>\n</ol>\n<h3>渲染</h3>\n<p>该阶段将发生真正的 Dom 操作</p>\n<ol>\n<li>根据 <code class=\"language-text\">effectList</code> 对 Dom 进行增删改</li>\n<li>对 fiber 进行删除时，解绑 ref，类组件调用 <code class=\"language-text\">componetWillUnmount</code> 方法</li>\n<li>函数式组件调用 <code class=\"language-text\">useLayoutEffect</code>  的销毁函数</li>\n<li><strong>同步</strong>调用 <code class=\"language-text\">componentDidMount</code> 和 <code class=\"language-text\">useLayoutEffect</code> 等，此时浏览器还没开始绘制</li>\n</ol>\n<h3>渲染后</h3>\n<p>浏览器渲染完毕后，浏览器通知 React 自己处于空闲状态。<strong>此阶段已经可以访问真实的 Dom</strong></p>\n<ol>\n<li>调用 <code class=\"language-text\">useEffect</code></li>\n<li>数据清除操作</li>\n</ol>\n<h2>React Reconciler</h2>\n<p>reconciler 运作流程有四个步骤，目的就是<strong>产出一种稳定结构供渲染器渲染</strong></p>\n<ol>\n<li>输入函数 <code class=\"language-text\">scheduleUpdateOnFiber</code>，只要涉及到需要改变 fiber 的操作(无论是<strong>首次渲染</strong>\n或<strong>后续更新</strong>操作), 最后都会间接调用<code class=\"language-text\">scheduleUpdateOnFiber</code></li>\n<li>与 scheduler 交互，注册调度任务（其中涉及<strong>优先级管理</strong>、<strong>时间切片</strong>等复杂逻辑</li>\n<li>执行任务回调，在内存中构造 Fiber 树</li>\n<li>输出结果提供给渲染器进行渲染</li>\n</ol>\n<h3>Fiber 树构建</h3>\n<p>Fiber 树的构建分为两种情况，初次构建与对比更新</p>\n<p><strong>初次构建</strong></p>\n<p>入口：<code class=\"language-text\">ReactDom.render</code> → <code class=\"language-text\">updateContainer</code> →<code class=\"language-text\">scheduleUpdateOnFiber</code></p>\n<p><strong>对比更新</strong></p>\n<p>入口: </p>\n<ol>\n<li><code class=\"language-text\">Class</code>组件中调用<code class=\"language-text\">setState</code></li>\n<li><code class=\"language-text\">Function</code>组件中调用<code class=\"language-text\">hook</code>对象暴露出的<code class=\"language-text\">dispatchAction</code></li>\n<li>在<code class=\"language-text\">container</code>节点上重复调用<code class=\"language-text\">render</code>(<a href=\"https://reactjs.org/docs/rendering-elements.html#react-only-updates-whats-necessary\">官网示例</a>)</li>\n</ol>\n<p>当发生更新时，创建新 Fiber 之前需要和旧 Fiber 进行对比。最后构造的 Fiber 树有可能是全新的, 也可能是部分更新的。</p>\n<p>reconciler 的主要内容就是 fiber 树的构建，而 Fiber Reconciler 是从 Stack Reconciler 重构而来，重点的优化就是<strong>实现了可中断的的递归遍历</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// performSyncWorkOnRoot 会调用该方法</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoopSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token comment\">// performConcurrentWorkOnRoot 会调用该方法</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoopConcurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token comment\">// shouldYield 可暂停循环</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">shouldYield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>在 Fiber Reconciler 中，<code class=\"language-text\">performUnitOfWork</code> 分为两个阶段，探寻阶段 <code class=\"language-text\">beginWork</code> 与回溯阶段 <code class=\"language-text\">completeWork</code>，以上两个阶段是每个 Fiber 节点都会经历，也正是这两个阶段完成了 Fiber 树的构建</p>\n<p><strong>beginWork</strong></p>\n<p>从根节点开始深度优先遍历，对遍历到的 Fiber 节点执行 beginWork，整体流程大致如下图所示</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/babfec194db6a21395f3cc80d40e9d2c/3126c/beginwork.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 86.48648648648648%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsSAAALEgHS3X78AAAD8UlEQVQ4y22SS0xcdRTGcWlMXFWjTWrcadLETTduXbjoojEmLozVRiGyqKk10LSJJDRtYrRqEUlLoJSAQFtaagvDo6UwdOxAWwrIUGCAGR5T5sHMMDP3zr135s6Tn2cGaHzd5Mv533Pv/zvf+c4pUcMbaJ5ZYmtzRFclClQ5a8/mUZUYqpFA1XWB8R8ohikxiSJQC2dBScTt4OnNOp72NPLkxgWmb9WzcqcZ4/F1CsViKVASguS/ILki2Q7Rc8KCMs/Qb3juX2Nt5Corw1cIjt4gPmEhvrGEHrBg+LrRd2D4ezC8N9GCdiHL/I/CZQeu3gYhbWPTfg2vtZ31oRaij3rQPUOE+vfgt7wqsYBXCPS9RqD7RZTHH6AWlBZa/zuh4l9FnR1Bc9qJFzGKtvAA1fkYxT+NOl1KbKKMaBGlRCe/RJk4THzxnCjMocQ1FE1INV2IE0IorIqRKiKdyZDLZshmt6OWTBUvpbbymFsZFNMgSx49nZfL0m5qCzUnXmZ3YOaFUOTGjSSReJKWRyHOWzeovb/BrwJXUMdMm1iHDK626XR2xOlsN1hyGSSyOSIzI2wO1rNpvczmvXqiS0+2CbWESVDGduCnJfZWO3nru0X2VDnpmfSjxiNUVeh8fDDB118k+fRQgn5LjFDSwNfyDcGKfYTOvkvg+OuEB2p3FZpFhXXWAKct65ztK8DHvDdOwkzSa9FobtDoaJXYqDE3r6NnsoTH+wje/p6ApYaQxMicnZLCZHanhDiUw8TM63LOoae2v+W3xCi2niOZTssQREhefJNMQLzU2PaxZJcsJjsw1uln8MIady+uYr20jnctjiGX+6b/pMlmpdX+h8QR5td9ks+xMe7Ae3OA1a5+fL/fITy7tNNy0iQcNqh6Y4yKl+x8u/chX71gY+z2M2LJOB/WnWP/6eO893M1+06W0zZqk1mD60wtC4dKcX9eyfzBI6zVt+8olKFEYgmuVy7Q9ImD5iMzNH82g9sRxcxl+KG/m6MdTZzsaqestR6bc560dO+53o/7TB3LNc24q2vx3Rv9p4cZqWpI7WjOpOCalkoTE6+KL+JP1khTeFJmVvIJdPGz4HYwmyBR+F+8fu6hIj+sTc/ifPCIWdsoy+NThEMRWe40Nu86na5Fbiwu0LXiwrUZxZBifkeM1f4gS7IRnjshgovqrodpIhGFvhMn6D12jLunTnGrvJzlqWlSou79e7d5u+8K7wx08nLXJS4754rTflLhZni/g5EDT7n75hRzNeu7HqZkyjqjDY3cr/kF+4WLDJ/7Ea97RVYkT/XkQw4/GKRsbJiPbAMMeTxk8lmcLT4mjrqZqlxmvNzFSk+QvwAA2JbBiiFEPgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"beginWork@2x.png\"\n        title=\"beginWork@2x.png\"\n        src=\"/static/babfec194db6a21395f3cc80d40e9d2c/fcda8/beginwork.png\"\n        srcset=\"/static/babfec194db6a21395f3cc80d40e9d2c/12f09/beginwork.png 148w,\n/static/babfec194db6a21395f3cc80d40e9d2c/e4a3f/beginwork.png 295w,\n/static/babfec194db6a21395f3cc80d40e9d2c/fcda8/beginwork.png 590w,\n/static/babfec194db6a21395f3cc80d40e9d2c/efc66/beginwork.png 885w,\n/static/babfec194db6a21395f3cc80d40e9d2c/c83ae/beginwork.png 1180w,\n/static/babfec194db6a21395f3cc80d40e9d2c/3126c/beginwork.png 1876w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p><code class=\"language-text\">beginWork</code> 会根据 <code class=\"language-text\">ReactElement</code> 对象创建所有的 Fiber 节点，最终构造出 Fiber 树的整体结构（通过设置 <code class=\"language-text\">return</code> 与 <code class=\"language-text\">sibling</code> )，在 Update 阶段时会确立好要更新的 Fiber 节点的方式存储到 <code class=\"language-text\">effectTag</code> 中，便于 render 阶段时处理。</p>\n<p>你可以从<strong><a href=\"https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/react-reconciler/src/ReactSideEffectTags.js\">这里 (opens new window)</a></strong>看到<code class=\"language-text\">effectTag</code>对应的<code class=\"language-text\">DOM</code>操作，比如：</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// DOM需要插入到页面中</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Placement <span class=\"token operator\">=</span> <span class=\"token comment\">/*                */</span> <span class=\"token number\">0b00000000000010</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// DOM需要更新</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Update <span class=\"token operator\">=</span> <span class=\"token comment\">/*                   */</span> <span class=\"token number\">0b00000000000100</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// DOM需要插入到页面中并更新</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> PlacementAndUpdate <span class=\"token operator\">=</span> <span class=\"token comment\">/*       */</span> <span class=\"token number\">0b00000000000110</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// DOM需要删除</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> Deletion <span class=\"token operator\">=</span> <span class=\"token comment\">/*                 */</span> <span class=\"token number\">0b00000000001000</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>completeWork</strong></p>\n<p>从叶子结点开始向上回溯，对 Fiber 节点执行 <code class=\"language-text\">completeWork</code> 方法。<code class=\"language-text\">beginWork</code> 会创建完 Fiber 节点并且将对该节点的改动添加到该节点的 <code class=\"language-text\">effectTag</code> 中，但在渲染阶段我们是要将其转化为 Dom 节点并执行 Dom 操作的，所以在 <code class=\"language-text\">completeWork</code> 阶段将会为渲染层准备好这些数据</p>\n<ol>\n<li>生成当前节点的 Dom 节点，将子孙的 Dom 节点插入到当前节点，设置 <code class=\"language-text\">Fiber.stateNode</code> 指向当前的 Dom 实例</li>\n<li>为 Dom 节点设置属性，绑定事件</li>\n<li>将 <code class=\"language-text\">beginWork</code> 设置的 <code class=\"language-text\">effectTag</code> 设置到父节点的 <code class=\"language-text\">effectList</code> 中</li>\n</ol>\n<p>通过上述几个步骤，<strong>要生成的 Dom 树与要执行的副作用变都被回溯到了根节点上</strong>，<strong>commit 阶段时便不需要再深度优先遍历去确认</strong></p>\n<p>至此，fiber 树构建完成，只需要将根节点  <code class=\"language-text\">FiberRootNode</code> 交给 commit 阶段的方法即可。也就是 React-dom 中的渲染</p>\n<p>reconciler 本身不与 DOM 绑定。挂载的确切结果（在源代码中有时叫做 “挂载映像”）取决于 renderer，可以是一个 DOM 节点（React DOM），一个字符串（React DOM Server），或是一个表示原生视图的数字（React Native）。</p>\n<h2>Scheduler</h2>\n<blockquote>\n<p>React 内部对于优先级的管理体系。</p>\n</blockquote>\n<p><strong>可中断渲染</strong>、<strong>时间切片</strong>、<strong>异步渲染</strong>等特性，都依赖 Scheduler</p>\n<h3>调度内核</h3>\n<p>Scheduler 需要满足以下两个功能</p>\n<ol>\n<li><strong>暂停 Js 执行</strong>，将主线程还给浏览器，让浏览器有机会更新页面</li>\n<li><strong>在未来某个时刻继续调度任务</strong>，执行上次还未执行完的任务</li>\n</ol>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/528fe8ea1676916c1a879c91f30a705b/92e9f/scheduler.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 52.70270270270271%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACEUlEQVQoz52SW0tUURTHz/forQ/gF6mQHoJxAhkCQXsRRhQrLSp6ClKJHnoKglBGUTRjHhK0i0mldrGmGRvNzKm5njm3OefMzZ9rnzTKsIcefqy1F2v/Wfu/l1YFnDrsFC3cJqiz5dbQrQqmW0U3bFLPFtlYXg3OhuNRtl1MiXbF/wNV06zJQYypKxQmJE5expq+ip3bxvDqGHJxYWiY0VCIsXCY5bEYdq0Z1EvCd8Mis4/KCzKElrvVSv5OmOLdCPnbIfIjZyh/TVJwG6TfrRFrb+dhNMpUZyfT3d18y2RxbI8HqQTHJu/RMjtKy6NRjk/fp/f1c7Tq+zDOahvWssSVELUPEWz9M2V3l8zWNhMdHYxHIsGE8UsDFMUCx/F5kdmh59VTLorIBaFPiKVTaN7KCfSlU+QXWyWexH9zWgRTlMVYq1onMf+EmWgP8YFBttYSwZOVh05F3Bbv6/4uDYEaeOKxZsrTbLeOLZ6paAoHxiuUQF43+VEyxNdaMGHRdIQKWb3M4/g483MzFKSuS792cPEwv4uqxmzJJKcQ8ayIlyyPZPIjNwfOMXytiy9bm1gylKZ+7C8cJeT9EjX21ySg8hPVY/sN1tc/sbGZDnLVq6lLR3F40sNYrk+u7JAXVK6G+KfgUail9+tNYrNztHX1cfZ8P/GFJTyp/begW20wv7RC7/Uh+m+M8PJtgopsxR5cjRFx9s3L6QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"scheduler@2x.png\"\n        title=\"scheduler@2x.png\"\n        src=\"/static/528fe8ea1676916c1a879c91f30a705b/fcda8/scheduler.png\"\n        srcset=\"/static/528fe8ea1676916c1a879c91f30a705b/12f09/scheduler.png 148w,\n/static/528fe8ea1676916c1a879c91f30a705b/e4a3f/scheduler.png 295w,\n/static/528fe8ea1676916c1a879c91f30a705b/fcda8/scheduler.png 590w,\n/static/528fe8ea1676916c1a879c91f30a705b/efc66/scheduler.png 885w,\n/static/528fe8ea1676916c1a879c91f30a705b/c83ae/scheduler.png 1180w,\n/static/528fe8ea1676916c1a879c91f30a705b/92e9f/scheduler.png 2620w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>微任务会在一次事件循环的最后执行，并不能让出主线程给浏览器，因此只能用宏任务去实现，这里的 <code class=\"language-text\">MessageChannel</code> 的作用就是<strong>生成宏任务</strong>（ <code class=\"language-text\">setTimeout</code> 也可以生成宏任务，因为 <code class=\"language-text\">setTimeout</code> 并不稳定，嵌套调用时存在最小延迟 4ms</p>\n<h3>任务队列</h3>\n<p>调度的目的是消费任务，scheduler 中维护了一个 <code class=\"language-text\">taskQueue</code>，任务队列的管理便是围绕这个 <code class=\"language-text\">taskQueue</code> 来展开</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// Tasks are stored on a min heap</span>\n<span class=\"token keyword\">var</span> taskQueue <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p><strong>创建任务</strong></p>\n<p>将任务创建完成后添加到任务队列中，然后触发调度申请</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// 省略部分无关代码</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">unstable_scheduleCallback</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">priorityLevel<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> options</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 1. 获取当前时间</span>\n  <span class=\"token keyword\">var</span> currentTime <span class=\"token operator\">=</span> <span class=\"token function\">getCurrentTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> startTime<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> options <span class=\"token operator\">===</span> <span class=\"token string\">'object'</span> <span class=\"token operator\">&amp;&amp;</span> options <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 从函数调用关系来看, 在v17.0.2中,所有调用 unstable_scheduleCallback 都未传入options</span>\n    <span class=\"token comment\">// 所以省略延时任务相关的代码</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    startTime <span class=\"token operator\">=</span> currentTime<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token comment\">// 2. 根据传入的优先级, 设置任务的过期时间 expirationTime</span>\n  <span class=\"token keyword\">var</span> timeout<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>priorityLevel<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">case</span> ImmediatePriority<span class=\"token operator\">:</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token constant\">IMMEDIATE_PRIORITY_TIMEOUT</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> UserBlockingPriority<span class=\"token operator\">:</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token constant\">USER_BLOCKING_PRIORITY_TIMEOUT</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> IdlePriority<span class=\"token operator\">:</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token constant\">IDLE_PRIORITY_TIMEOUT</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> LowPriority<span class=\"token operator\">:</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token constant\">LOW_PRIORITY_TIMEOUT</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">case</span> NormalPriority<span class=\"token operator\">:</span>\n    <span class=\"token keyword\">default</span><span class=\"token operator\">:</span>\n      timeout <span class=\"token operator\">=</span> <span class=\"token constant\">NORMAL_PRIORITY_TIMEOUT</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">var</span> expirationTime <span class=\"token operator\">=</span> startTime <span class=\"token operator\">+</span> timeout<span class=\"token punctuation\">;</span>\n  <span class=\"token comment\">// 3. 创建新任务</span>\n  <span class=\"token keyword\">var</span> newTask <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    id<span class=\"token operator\">:</span> taskIdCounter<span class=\"token operator\">++</span><span class=\"token punctuation\">,</span>\n    callback<span class=\"token punctuation\">,</span>\n    priorityLevel<span class=\"token punctuation\">,</span>\n    startTime<span class=\"token punctuation\">,</span>\n    expirationTime<span class=\"token punctuation\">,</span>\n    sortIndex<span class=\"token operator\">:</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>startTime <span class=\"token operator\">></span> currentTime<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 省略无关代码 v17.0.2中不会使用</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    newTask<span class=\"token punctuation\">.</span>sortIndex <span class=\"token operator\">=</span> expirationTime<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 4. 加入任务队列</span>\n    <span class=\"token function\">push</span><span class=\"token punctuation\">(</span>taskQueue<span class=\"token punctuation\">,</span> newTask<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 5. 请求调度</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isHostCallbackScheduled <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>isPerformingWork<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      isHostCallbackScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n      <span class=\"token function\">requestHostCallback</span><span class=\"token punctuation\">(</span>flushWork<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> newTask<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>消费任务</strong></p>\n<p>收到调度申请后开始循环处理任务队列中的任务</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// 省略无关代码</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">flushWork</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">hasTimeRemaining<span class=\"token punctuation\">,</span> initialTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 1. 做好全局标记, 表示现在已经进入调度阶段</span>\n  isHostCallbackScheduled <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  isPerformingWork <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> previousPriorityLevel <span class=\"token operator\">=</span> currentPriorityLevel<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 2. 循环消费队列</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span>hasTimeRemaining<span class=\"token punctuation\">,</span> initialTime<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// 3. 还原全局标记</span>\n    currentTask <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n    currentPriorityLevel <span class=\"token operator\">=</span> previousPriorityLevel<span class=\"token punctuation\">;</span>\n    isPerformingWork <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>主要逻辑都在 workLoop 中</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token comment\">// 省略部分无关代码</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">hasTimeRemaining<span class=\"token punctuation\">,</span> initialTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> currentTime <span class=\"token operator\">=</span> initialTime<span class=\"token punctuation\">;</span> <span class=\"token comment\">// 保存当前时间, 用于判断任务是否过期</span>\n  currentTask <span class=\"token operator\">=</span> <span class=\"token function\">peek</span><span class=\"token punctuation\">(</span>taskQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 获取队列中的第一个任务</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>currentTask <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      currentTask<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">></span> currentTime <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasTimeRemaining <span class=\"token operator\">||</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 虽然currentTask没有过期, 但是执行时间超过了限制(毕竟只有5ms, shouldYieldToHost()返回true). 停止继续执行, 让出主线程</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> currentTask<span class=\"token punctuation\">.</span>callback<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> callback <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      currentTask<span class=\"token punctuation\">.</span>callback <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n      currentPriorityLevel <span class=\"token operator\">=</span> currentTask<span class=\"token punctuation\">.</span>priorityLevel<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> didUserCallbackTimeout <span class=\"token operator\">=</span> currentTask<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">&lt;=</span> currentTime<span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 执行回调</span>\n      <span class=\"token keyword\">const</span> continuationCallback <span class=\"token operator\">=</span> <span class=\"token function\">callback</span><span class=\"token punctuation\">(</span>didUserCallbackTimeout<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      currentTime <span class=\"token operator\">=</span> <span class=\"token function\">getCurrentTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token comment\">// 回调完成, 判断是否还有连续(派生)回调</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">typeof</span> continuationCallback <span class=\"token operator\">===</span> <span class=\"token string\">'function'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 产生了连续回调(如fiber树太大, 出现了中断渲染), 保留currentTask</span>\n        currentTask<span class=\"token punctuation\">.</span>callback <span class=\"token operator\">=</span> continuationCallback<span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// 把currentTask移出队列</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currentTask <span class=\"token operator\">===</span> <span class=\"token function\">peek</span><span class=\"token punctuation\">(</span>taskQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span>taskQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 如果任务被取消(这时currentTask.callback = null), 将其移出队列</span>\n      <span class=\"token function\">pop</span><span class=\"token punctuation\">(</span>taskQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token comment\">// 更新currentTask</span>\n    currentTask <span class=\"token operator\">=</span> <span class=\"token function\">peek</span><span class=\"token punctuation\">(</span>taskQueue<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>currentTask <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 如果task队列没有清空, 返回true. 等待调度中心下一次回调</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// task队列已经清空, 返回false.</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>每一次 while 循环的退出就是一个时间切片</strong>，退出条件有两个</p>\n<ol>\n<li>没有更多任务了</li>\n<li>在消费任务队列时，执行下一个 task 的 callback 之前，都会进行检测，所以检测是以 task 为单位</li>\n</ol>\n<h2>参考链接</h2>\n<p><a href=\"https://zh-hans.reactjs.org/\">React 官方中文文档 - 用于构建用户界面的 JavaScript 库</a></p>\n<p><a href=\"https://7kms.github.io/react-illustration-series\">图解React原理系列 - 图解React</a></p>\n<p><a href=\"https://react.iamkasong.com/\">React技术揭秘</a></p>","frontmatter":{"title":"React 核心包概览","date":"October 12, 2022"}}},"pageContext":{"slug":"/React 核心包概览/","previous":{"fields":{"slug":"/React 合成事件/"},"frontmatter":{"title":"React 合成事件","date":"2022-10-16"}},"next":{"fields":{"slug":"/性能优化专题/性能优化专题/"},"frontmatter":{"title":"性能优化专题","date":"2022-06-12"}},"prePath":"/posts/post-1665878400000","nextPath":"/posts/post-1654992000000"}},"staticQueryHashes":["1747850863","63159454"]}