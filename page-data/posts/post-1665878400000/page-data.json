{"componentChunkName":"component---src-templates-post-detail-tsx","path":"/posts/post-1665878400000","result":{"data":{"site":{"siteMetadata":{"title":"Silence","author":"默尝"}},"markdownRemark":{"id":"61ba1178-ad5f-5e0e-9b6e-3322d61e2e93","excerpt":"React 合成事件 React 合成事件（SyntheticEvent）是 React 模拟原生 Dom 事件所有能力的事件对象 目的 解决兼容性问题，保证在各个浏览器的一致性 采用事件委托，减少开销 方便 React 对于事件的统一管理「优先级管理」 事件绑定 react 合成事件在 1…","html":"<h1>React 合成事件</h1>\n<blockquote>\n<p>React 合成事件（SyntheticEvent）是 React 模拟原生 Dom 事件所有能力的事件对象</p>\n</blockquote>\n<h2>目的</h2>\n<ol>\n<li>解决兼容性问题，保证在各个浏览器的一致性</li>\n<li>采用事件委托，减少开销</li>\n<li>方便 React 对于事件的统一管理「优先级管理」</li>\n</ol>\n<h2>事件绑定</h2>\n<p>react 合成事件在 17 之前全部委托在 document 中，17 及以后全部都委托在了挂载的容器上了。原因就是因为如果页面上有多个 React，都会被附加在 document 中。</p>\n<p>当 React 组件要被挂载或者更新时，都会触发 <code class=\"language-text\">enqueuePutListener</code> ，这个方法负责两件事</p>\n<ol>\n<li>找到 <strong>react 事件与之对应的浏览器原生事件</strong>并<strong>注册到挂载容器的节点</strong></li>\n<li>将事件与该组件关联并存储起来，为了在事件触发时能找到对应的事件去调用</li>\n</ol>\n<h2>事件触发</h2>\n<p>利用事件委托机制，当事件触发时，都会触发在 document 或者挂载容器上注册的事件。无论什么事件，都会统一的调用 <code class=\"language-text\">dispatchEvent</code> 函数。</p>\n<p>然后便是找到对应的事件</p>\n<ol>\n<li>通过原生事件找到原生 Dom</li>\n<li>通过 Dom 元素找到对应的 React Component</li>\n<li>通过事件类型与 React Component 找到需要调用的事件</li>\n<li>从该 React Component 向上回溯，沿路收集对应的事件并存储</li>\n<li>构造对应的合成事件</li>\n<li>按一定顺序批量处理事件</li>\n</ol>","frontmatter":{"title":"React 合成事件","date":"October 16, 2022"}}},"pageContext":{"slug":"/React 合成事件/","previous":{"fields":{"slug":"/React Hooks/"},"frontmatter":{"title":"React Hooks","date":"2022-10-23"}},"next":{"fields":{"slug":"/React 核心包概览/"},"frontmatter":{"title":"React 核心包概览","date":"2022-10-12"}},"prePath":"/posts/post-1666483200000","nextPath":"/posts/post-1665532800000"}},"staticQueryHashes":["1747850863","63159454"]}