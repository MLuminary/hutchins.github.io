[{"title":"基于 mpvue 的圆形进度条组件","url":"%2F2018%2F09%2F28%2F%E5%9F%BA%E4%BA%8Empvue%E7%9A%84%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F","content":"\n> 自己本身是一个小程序小白，前几天刚开始学习。碰到一个需求是要实现多个圆形带缺口的进度条，在网上没有找到相关插件后决定自己编写一个，如果能帮到需要的人那真是太好了, 下面会介绍一下自己的实现过程，如果只关心如何用的话可以传送到下面的页面\n\n[mini-circleprogress 源码](https://github.com/MLuminary/subentry/tree/master/mini-circleProgress)\n\n<!--more-->\n\n\n## 外观\n\n![基于 mpvue 的圆形进度条](基于mpvue的圆形进度条/default.jpg)\n\n![基于 mpvue 的圆形进度条](基于mpvue的圆形进度条/gap.jpg)\n\n## 过程\n\n一开始的思路是用 svg， 自己编写完毕后，发现小程序不支持直接引入 svg， 因此最终实现是使用的小程序自带的 canvas\n\n如何画圆已经有大佬讲解过了，我就不重复劳动了，下面是链接\n\nhttps://segmentfault.com/a/1190000013219501\n\n在此说明一下此组件实现的功能和一些注意点\n\n## 完全响应式\n\n### 适应包裹元素的宽度和高度\n\n一开始的思路是设置 canvas 的宽高为 100%，发现并没有什么用，然后想获取 canvas 动态改变其宽高，发现小程序不能操作 dom, `ref` 也都不能使用。因此只能设置一个 `props`,麻烦使用者告知一下父元素的宽高，在这里因为此图形是一个正方形，所以只需要传递一个值就可以了。\n\n### 适应设备的宽度和高度\n\ncanvas 中的画布单位默认都是 px，画出来的图形是不能很好的适应宽度不同的设备的，因此自己在内部实现了一个 rpx，具体实现思路如下\n\n```js\ngetRpx () {\n  let rpx = 1 // 相对单位\n  return new Promise(resolve => {\n    wx.getSystemInfo({\n      success: function (res) {\n        rpx = res.windowWidth / 375\n        resolve(rpx)\n      }\n    })\n  })\n}\n```\n\n然后与之前的画布的数值相乘即可，想具体看怎么实现的可以去看下源码\n\n## 有关 canvas-id\n\ncanvas 在一个页面中 id 是不能相同的，就算出现相同的也只会渲染第一个，因此需要多个 canvas 只能让其 id 各不相同。使用者想使用多个圆形进度条组件的时候，请传递 `canvasId` 值。\n\n","tags":["Idea"],"categories":["Fun"]},{"title":"根据 url 获取图标及 title","url":"%2F2018%2F09%2F07%2F%E6%A0%B9%E6%8D%AEurl%E8%8E%B7%E5%8F%96%E5%9B%BE%E6%A0%87%E5%8F%8Atitle%2F","content":"\n> 最近在做一个小项目有一个类似添加书签的功能，用户点击添加后，弹出输入模块，用户只需要将需要收录的链接添加进去，便可以自动生成带有此网站图标和此网站标题的卡片\n\n<!--more-->\n\n## 设置 icon\n\n想要知道如何获取肯定要知道网站的 icon 是如何设置的，设置 icon 的方式据我了解的有两种\n\n- 一般都是在 `html` 代码的 `head` 标签中设置一个 `link` 标签，将其 `rel` 属性设置为 \"icon\" 或者 \"shortcut icon\",  `href` 就是图标的位置。\n- 大部分网站会在其根目录下放置一个`favicon.ico` 文件，也就是网站的图标。\n\n![pg1](根据url获取图标及title/pg1.png)\n\n## 获取 icon\n\n两条途径设置 icon，明显解析 html 要相对麻烦一点，因此我们先去网站根目录下去获取 favicon.ico, 如果不存在此文件，再解析 html，当然如果网站本身就没有 icon ，那就自己设置一个默认的图标就好了。\n\n我的思路是拿到需要收录的链接，然后用 `node` 的 `url` 模块去解析，再用 `get` 方法去抓取此网页，如果不是 `200` 就代表根目录下没有此文件。\n\n```js\nconst express = require('express')\nconst url = require('url')\nconst axios = require('axios')\n\nlet app = express()\n\n\napp.get('/',function(req, res) {\n  let targetUrl = 'https://github.com/MLuminary'\n  let urlString = url.parse(targetUrl)\n  let iconUrl = `${urlString.protocol}//${urlString.host}/favicon.ico`\n  isHasRootIcon(iconUrl)\n})\n\n// 判断网站根目录下是否有 favicon.ico 文件\nfunction isHasRootIcon(url) {\n   axios.get(url).then(response=>{\n     console.log(1)\n   }).catch(error=>{\n     console.log(0)\n   })\n}\n```\n\n**以上思路大部分网站还是可以的**，但是有一些网站会遇到重定向的问题，会跳到 404 页面或者 error 页面，**此时返回的 `status` 也是 `200` **，上面的方法就也会认为已找到 icon, 但实际上链接是 `html` 页面，因此我就想能不能获取到重定向后的链接，判断其类型，如果重定向的类型不是 ico、png等图片类型，就也判断为没找到。找来找去发现了 `request` 包可以实现, 下面是具体实现\n\n```js\napp.get('/',function(req, res) {\n  let targetUrl = 'http://www.12306.cn/mormhweb/'\n  let urlString = url.parse(targetUrl)\n  let iconUrl = `${urlString.protocol}//${urlString.host}/favicon.ico`\n  isHasRootIcon(iconUrl).then(res=>{console.log(res)})\n})\n\n// 判断网站根目录下是否有 favicon.ico 文件\nfunction isHasRootIcon(url) {\n  let pattern = ['ico','png', 'svg', 'jpg']\n\n  return new Promise((resolve)=>{\n    let returnValue = false\n    request.get(url,function(err, res) {\n      if(res.statusCode === 200) {\n        let redirectPath = res.request.uri.path // 重定向的页面路径\n        pattern.forEach(item=>{\n          if(redirectPath.split('.')[1]===item) {\n            // 如果结尾是 pattern 数组中的一种 则返回 true\n            returnValue = true\n            resolve(returnValue)\n          }\n        })\n      }\n      resolve(returnValue)\n    })\n  })\n}\n```\n\n如果根目录下不存在 favicon.ico 文件，则需要解析其链接的 html ，然后提取出 icon 的路径，但是这其中还有一些问题，**icon 的路径有可能是绝对路径或者是相对路径**，因此在此还需要在判断一下，下面是具体代码\n\n```js\nfunction resolveHtml(targetUrl) {\n  return new Promise(resolve=>{\n    let defaultUrl = ''// 自己默认的图片链接\n    superagent.get(targetUrl).end(function (err, content) {\n      let $ = cheerio.load(content.text)\n      let iconUrl = $(\"link[rel*='icon']\").eq(0).attr('href') // 获得 icon 的链接\n      // 如果 iconUrl 存在 还需要判断其是否是相对位置\n      if(iconUrl) {\n        // 如果不存在 'http'\n        if(iconUrl.indexOf('http') === -1 ) {\n          // 判断是否为相对路径或根路径\n          if(iconUrl.charAt(0) === '/') {\n            let urlString = url.parse(targetUrl)\n            iconUrl = `${urlString.protocol}//${urlString.host}${iconUrl}`\n          }else {\n            iconUrl = targetUrl + \"/\" + iconUrl\n          }\n        }\n        resolve(iconUrl)\n      }else {\n        resolve(defaultUrl)\n      }\n    })\n  })\n}\n```\n\n获取 icon 连接时为什么我加了一个 `eq(0)` 呢，是因为我发现有些网站有两种类型的 `link` 可以添加图标，一种是`shortcunt icon` 一种是 `icon`，因此我们只要获取其中一个就可以了，两个都获取到可能会报错。\n\n## 获取title\n\n获取 title 就相当于解析 Html 获取 icon, 还是比较简单的，在此就不放代码了。\n\n## 成果\n\n下面就是传入掘金首页抓取到的信息\n\n![pg2](根据url获取图标及title/pg2.png)","tags":["Idea"],"categories":["Fun"]},{"title":"获取百度搜索提示结果","url":"%2F2018%2F08%2F15%2F%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E6%8F%90%E7%A4%BA%E7%BB%93%E6%9E%9C%2F","content":"\n> 最近自己想做的项目需要一个搜索框，并想实现如下搜索提示的功能\n\n![pg1](获取百度搜索提示结果/pg1.jpg)\n\n本来觉得查查 network 随便抓取一下就可以获得到数据，但事情却不是这么简单\n\n<!--more-->\n\n### 过程\n\n在百度在随便输入字符，查看 network，找到此时请求的链接\n\n![pg2](获取百度搜索提示结果/pg2.png)\n\n会发现使用 get 方式传了四个值,其中 `p` 和 `cb` 都是可以固定的，剩下的就是关键字 `wd` 和此时的时间戳 `t`，自己因为本身是 vue 的项目，就用 `axios` 对此进行请求，结果报错为 **跨域** 并且 **中文乱码**\n\n#### gzip\n\n因为发生了跨域，因此就想用 `node` 去修改请求头去请求，「后来发现用 `node` 去请求不需要修改请求头也不会跨域」，但是还有一个问题返回的中文都是乱码。然后我就去关注了一下响应头，如上面的图片，其中 `content-encoding: gzip` 引起了我的注意。\n\ngzip 是什么在此我就不做过多的解释，去网上查只是说想要**获取 gzip 格式的网页信息需要解压，要不然获得到的信息会是乱码**，其中用到了 `zlib` 和 `request` 两个包\n\n```js\n  zlib = require('zlib');\n\nfunction response (err, res, body) {\n//check res header it is gzip\n console.log(res.headers['content-encoding'])\n//now body it is gzip stream buffer\n      zlib.unzip(body, function(err, buffer) {\n             console.log(buffer.toString())\n       }\n\n}\n    request.get({\n        url : apiUrl,\n        headers: {\n            'Accept-Encoding' : 'gzip',\n          },\n        encoding : null  // it is very import!!\n    }, response)\n```\n\n但是我满怀期待的将其解压提取信息后获得的结果依然是乱码，make my heart cold cold\n\n**gbk**\n\n最后又把目光转向响应头，感觉 `charset=gbk` 好像有点东西, 其中用到了 `iconv-lite` ，是一个转编码的工具，`iconv.decode` 接受到第一个参数必须是 `buffer`, 而 `request` 获取到的信息返回的也是 `buffer` 我就感觉冥冥之中放佛预示着什么\n\n```js\nrequest({\n        url,\n        encoding : null\n    }, function(err, response, body) {\n        res.setHeader('Content-Type', 'application/json; charset=utf-8')\n        res.end(iconv.decode(body, 'gbk'))\n    })\n```\n\n因此将响应头设置为 utf-8 并将其 gbk 编码转换为 utf-8 后成功的获得到了需要的信息, 下面就是将此 api 部署到我自己的服务器上，关于部署碰到的一些问题基本都在我另一篇文章中有谈到 [记一次oneinstack配置服务器](https://github.com/MLuminary/Blog/issues/15)\n\n[阅读原文](https://github.com/MLuminary/Blog/issues/16)\n\n","tags":["Node"],"categories":["Fun"]},{"title":"让服务器带点绿","url":"%2F2018%2F07%2F28%2F%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%A6%E7%82%B9%E7%BB%BF%2F","content":"\n> 这段时间终于感觉自己步入正轨，也相对稳定了下来。便想搞点事情，想做一个网站，包含自己一些平时想要的工具和一些自己想关注的咨询。然后发现自己的服务器竟然一点都不绿，所以就花了一些时间绿化了自己的服务器。\n\n<!--more-->\n\n## nginx 上 https\n\n### 申请证书\n\n我自己用的是腾讯云服务器，因此证书就去腾讯云官方网站去申请，当然不是腾讯云的话还有几个比较权威的颁发证书的网站，例如 [StartSSL](https://www.startcomca.com),当然如果你的服务器是 Linux 的话，你也可以用默认安装的 OpenSSL\n\n但是 OpenSSL 的方法我没有试过，具体可以参考 \n\nhttps://www.cnblogs.com/chjbbs/p/5748369.html\n\n腾讯云的申请证书还是比较简单，打开下述链接\n\nhttps://console.cloud.tencent.com/ssl\n\n点击申请证书，然后根据其提示一步步填写，审核成功后下载证书，下载证书后里面的文件如下\n\n![pg1](让服务器带点绿/pg1.png)\n\n打开 Nginx，里面包含着一个证书文件和一个 .key 文件。\n\n### 配置 nginx\n\n打开服务器中的 nginx/conf 文件夹，在其中创建一个文件夹为 ssl，再创建一个文件夹为域名，这个完全看自己的习惯，在后面的配置项中只要路径对就可以。我的证书和 .key 文件的位置就在 nginx/conf/ssl/www.haoqinzz.cn/ 下\n\n然后找到 nginx.conf 文件，将其中如下代码解开封印并修改为如下代码\n\n```conf\n# HTTPS server\n    \n    server {\n       listen       443;\n       server_name  localhost;\n\n       ssl                  on;\n       ssl_certificate      ssl/www.haoqinzz.cn/1_www.haoqinzz.cn_bundle.crt;\n       ssl_certificate_key  ssl/www.haoqinzz.cn/2_www.haoqinzz.cn.key;\n\n       ssl_session_timeout  5m;\n\n       ssl_protocols  SSLv2 SSLv3 TLSv1;\n       ssl_prefer_server_ciphers   on;\n       \n       ssl_dhparam ssl/certs/dhparam.pem;\n       ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\";\n       keepalive_timeout 70;\n       ssl_session_cache shared:SSL:10m;\n\n       add_header Strict-Transport-Security max-age=63072000;\n       add_header X-Frame-Options DENY;\n       add_header X-Content-Type-Options nosniff;\n\n\n       location / {\n           root   html;\n           index  index.html index.htm;\n       }\n    }\n```\n\n然后再重启一下 nginx 服务即可，然后输入 https://haoqinzz.cn 就可以看到 nginx 的欢迎页，但此时你输入 http://haoqinzz.cn 还是可以访问的，所以如果想要全站都上 https ，还需要修改 http 的服务，将 http 重定向到 https 中\n\n```conf\nserver {\n    listen       80;\n    server_name  haoqinzz.cn www.haoqinzz.cn;\n    return 301 https://haoqinzz.cn$request_uri;\n}\n```\n\n这样你输入 http://haoqinzz.cn 会跳到 https://haoqinzz.cn 中，但是现在还存在一个很大的问题，就是我以前的项目也无法访问到了。。\n\n## 让服务器中的项目重新运行\n\n### 基本项目\n\n服务器上 https 后，首页改变了，所有项目都没了，我就去看了一下 nginx 的配置文件\n\n```conf\n# HTTPS server\n    \n    server {\n       listen       443;\n       server_name  localhost;\n\n       ssl                  on;\n       ssl_certificate      ssl/www.haoqinzz.cn/1_www.haoqinzz.cn_bundle.crt;\n       ssl_certificate_key  ssl/www.haoqinzz.cn/2_www.haoqinzz.cn.key;\n\n       ssl_session_timeout  5m;\n\n       ssl_protocols  SSLv2 SSLv3 TLSv1;\n       ssl_prefer_server_ciphers   on;\n       \n       ssl_dhparam ssl/certs/dhparam.pem;\n       ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\";\n       keepalive_timeout 70;\n       ssl_session_cache shared:SSL:10m;\n\n       add_header Strict-Transport-Security max-age=63072000;\n       add_header X-Frame-Options DENY;\n       add_header X-Content-Type-Options nosniff;\n\n\n       location / {\n           root   html;\n           index  index.html index.htm;\n       }\n    }\n```\n\n发现 https 的 root 文件夹为 html，因此我将原本的文件迁过来就可以访问了。:fist:\n\n### nginx 反向代理项目\n\n在服务器上我还有过一个用 nginx 实现反向代理的项目，升 https 后毫无疑问 api 全部都是 404 了\n\n找到 nginx 反向代理的配置文件，将 Listen 端口 80 改为 443 ，并将以前的 http 协议都改为 https，然后此时再打开就可以找到 url ，但是会报 502 错误，经过仔细排查后发现这是因为我当时用 http 起的服务，要改为 https 并配置证书文件\n\n```js\nvar https = require('https');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('key文件'),\n  cert: fs.readFileSync('crt文件')\n};\n\nvar server = https.createServer(options,app);\n```\n\n这样数据便又可以获取到了\n\n### oneinstack 一键配置\n\n你也可以使用 Oneinstack 傻瓜式上 https ，\b\b也就是 `~/oneinstack/vhost.sh`, 具体可以看 oneinstack 官网的[教程](https://oneinstack.com/install/)","tags":["Server"],"categories":["Explore"]},{"title":"记一次 oneinstack 配置服务器","url":"%2F2018%2F06%2F25%2F%E8%AE%B0%E4%B8%80%E6%AC%A1oneinstack%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F","content":"\n> 因为自己是大学生，所以一直都是用的腾讯云学生机，但是前几天腾讯突然告诉我腾讯云学生认证到期了，可能是当时填错了，没办法我就又申请了学生认证😂，谁让我还是学生呢，但是以前老的学生优惠的学生机就不能再按照学生优惠的方式续费了，所以我又买了一个新的服务器。买完服务器准备手动开始各种配置的时候便发现了一个神器，也就是接下来要介绍给大家的。就是 [oneinstack](https://oneinstack.com/) ,可以傻瓜式「一键」安装，想看碰到的 bug 及一些解决方案可以直接跳过配置服务器部分。<a href=\"#遇到的问题\">jump</a>\n\n<!--more-->\n\n## 配置服务器环境\n\n我写此博客时 oneinstack 的版本为 2018-04-24, 其使用方式如下\n\n### 基本安装\n\n```shell\nyum -y install wget screen curl python #for CentOS/Redhat\n# apt-get -y install wget screen curl python #for Debian/Ubuntu\n\n# 下载源码与脚本\nwget http://mirrors.linuxeye.com/oneinstack-full.tar.gz #包含源码，国内外均可下载\n\n# 解压\ntar xzf oneinstack-full.tar.gz\n\n# 如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件\ncd oneinstack \n\n# 如果网路出现中断，可以执行命令`screen -R oneinstack`重新连接安装窗口\nscreen -S oneinstack \n\n# 注：请勿sh install.sh或者bash install.sh这样执行\n./install.sh \n\n# 接下来根据其指示和自己喜好安装需要的软件即可\n```\n\n### node 安装\n\noneinstack 不支持 node 环境的安装，作为一个前端er, node 还是不可获取的，以前我配置 node 都是去官网下载然后解压然后建立全局软链接的形式，这次也是换了一个更简单的方式\n\n#### node.js v.8x 安装命令\n\n```shell\n#curl --silent --location https://rpm.nodesource.com/setup_8.x | bash -\n```\n\n#### 安装node\n\n```shell\nyum install -y nodejs\n```\n\n#### 查看 nodejs 安装版本\n\n```shell\nnode -v\n```\n\n至此 node 就已经安装完成，也是全局变量，相比以前也省了很多时间和力气，如果需要也可以安装 nodejs 的版本管理工具，但是在这里我没有安装，正确与否我没有尝试\n\n### node.js版本管理器n\n\n#### 安装n\n\n```\nnpm install -g n1\n```\n\n#### 安装指定版本\n\n```\n#n <version>1\n```\n\n#### 安装最新版本\n\n```\n# n latest1\n```\n\n#### 安装稳定版本\n\n```\n#n stable1\n```\n\n#### 删除某个版本\n\n```\n#n rm <version> 1\n```\n\n#### 查看所有版本\n\n```\n#n list\n```\n\n## 其他配置\n\n### 添加附加组件\n\n```shell\n./addons.sh\n```\n\n### 创建 FTP 虚拟用户账户\n\n```shell\n./pureftpd_vhost.sh\n```\n\n### 增删虚拟主机\n\n```shell\n# 增加虚拟主机./vhost.sh# 删除虚拟主机\n./vhost.sh\n```\n\n### 备份和自动备份\n\n```shell\n# Set backup options ./backup_setup.sh # Start backup, You can add cron jobs./backup.sh # crontab -l # Examples 0 1 * * * cd ~/oneinstack;./backup.sh  > /dev/null 2>&1 &\n```\n\n### 更新版本\n\n```shell\n./upgrade.sh\n```\n\n### 卸载\n\n```shell\n./uninstall.sh\n```\n\n## 管理服务\n\nNginx/Tengine/OpenResty:\n\n```\nservice nginx {start|stop|status|restart|reload|configtest}\n```\n\nMySQL/MariaDB/Percona:\n\n```\nservice mysqld {start|stop|restart|reload|status}\n```\n\nPostgreSQL:\n\n```\nservice postgresql {start|stop|restart|status}\n```\n\nMongoDB:\n\n```\nservice mongod {start|stop|status|restart|reload}\n```\n\nPHP:\n\n```\nservice php-fpm {start|stop|restart|reload|status}\n```\n\nHHVM:\n\n```\nservice supervisord {start|stop|status|restart|reload}\n```\n\n**注**：hhvm进程交给supervisord管理，了解更多请访问《[Supervisor管理hhvm进程](https://blog.linuxeye.com/408.html)》\nApache:\n\n```\nservice httpd {start|restart|stop}\n```\n\nTomcat:\n\n```\nservice tomcat {start|stop|status|restart}\n```\n\nPure-Ftpd:\n\n```\nservice pureftpd {start|stop|restart|status}\n```\n\nRedis:\n\n```\nservice redis-server {start|stop|status|restart}\n```\n\nMemcached:\n\n```\nservice memcached {start|stop|status|restart|reload}\n```\n\n## 启用 mysql 服务\n\noneinstack 默认仅允许主机本机链接数据库，需要远程连接数据库的话，需要打开对应端口\n\n### 打开 3306 端口\n\nCentOS 系统\n\n```shell\niptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT # 允许访问 3306\nservice iptables save #保存 iptables 规则\niptables -nvl # 查看 iptables 规则\n```\n\nUbuntu/Debian \n\n```shell\niptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT # 允许访问 3306\niptables-save > /etc/iptables.up.rules #保存 iptables 规则\n```\n\n### 数据库授权\n\n#### MySQL8.0版本\n\n```shell\n# mysql -uroot -p\n MySQL [(none)]> create user db_user@'%' identified by 'db_pass'; #创建用户\n MySQL [(none)]> grant all privileges on db_name.* to db_user@'%' with grant option; #授权\n MySQL [(none)]> exit; #退出数据库控制台，特别注意有分号\n```\n\n#### 其余MySQL版本\n\n```shell\n# mysql -uroot -p\n MySQL [(none)]> grant all privileges on db_name.* to db_user@'%' identified by 'db_pass'; #授权语句，特别注意有分号\n MySQL [(none)]> flush privileges;\n MySQL [(none)]> exit; #退出数据库控制台，特别注意有分号\n```\n\n## 服务器https\n\n以前的服务器 https 都是自己上的，使用 oneinstack 可以一键让自己的服务器带点绿 :green_apple: \n\n运行`./vhost.sh` 就会跳到配置虚拟环境界面，oneinstack 采用 Let's Encrypt https 证书，免费使用为 90 天，到期后 oneinstack 会自动帮你续费，配置完毕后在默认文件夹里添加项目就可以输入网址以 https 的方式访问\n\n## 遇到的问题\n\n### 无法访问带端口域名\n\n我自己创建了一个二级域名 api.×××× 来作为我一些 api 接口的提供网址，然后想用 oneinstack 为其上https，向服务器中上传 node 文件用 pm2 跑起来后，本来在本地 localhost:3000 可以访问的文件，到了服务器后无法通过 api.××××:3000 来访问，最开始想到了类似阿里云安全组的问题，然后我去后台看了下我的服务器的安全组，并没有禁用 3000 端口。后来脑子里自己冒出来了一个想法，用 nginx 反向代理，在这里我就不具体给出反向代理的代码了，格式很简单，就是访问 api.××××/getApi 相当于访问 api.××××:3000/getApi ,然后竟然就成功访问到了 :zap:\n\n2018/9/10: oneinstack 默认端口都是不开放的，因此我感觉是未将 3000 端口开放的原因\n\n### 引用 api 碰到的跨域问题\n\n主域名下的项目引用 api.×××× 下的 api 是要跨域的，谷歌搜索到的解决方案基本是如下代码\n\n```js\napp.all('*', function(req, res, next) {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\")\n    res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\")\n    res.header(\"X-Powered-By\",' 3.2.1')\n    if(req.method==\"OPTIONS\") res.send(200)/*让options请求快速返回*/\n    else  next()\n})\n```\n\n但是并没有解决我的跨域问题，我是在 nginx 反向代理时加入如下代码实现的\n\n```conf\nlocation / {  \n    add_header Access-Control-Allow-Origin *;\n\t...\n} \n```\n\n### https 引用 http 下的接口报错\n\n我的 api.×××× 域名在开始的时候上 https 并没有成功，我就使用的是 http 协议，但是解决了跨域问题后又报错，报错的内容大致就是 https 下无法引用 http 中的接口，最后我其实换了一个域名又上了 https ... :joy_cat:\n\n## 最后\n\n最后基本项目都已部署到了服务器上，访问项目也有耀眼的小绿标，还是 hin 开心的","tags":["Oneinstack"],"categories":["Explore"]},{"title":"前端安全","url":"%2F2018%2F05%2F30%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F","content":"\n> 最近一直在准备面试，被问到了解 XSS 时答出不了解还是很惭愧的，作为前端开发人员，安全这方面是必须要非常重视的，因此决定拿出了一段时间来重点了解一下关于前端的安全问题，在这里以 XSS 和 CSRF 为主\n\n<!--more-->\n\n## XSS\n\nXSS(Cross-site script)因为与 CSS 简写重合所以改为 XSS\n\n其原理是**向网站中插入恶意的 HTML 代码**。当其他用户浏览该网站的时候，该段 HTML 代码会自动执行，从而达到攻击的目的。如盗取用户的 Cookie，页面重定向，破坏页面结构\n\n**举个**:chestnut:\n\n网站的评论系统没有过滤 XSS 攻击，当有用户添加评论为\n\n```js\n<script>\n  while(true) {\n    alert(\"1\")\n  }\n</script>\n```\n\n这段代码就会插入到此网站的 DOM 结构中，因为没有过滤掉或进行处理，此段代码也会执行。\n\n### XSS 分类\n\nXSS 分为两种类型：「持久型 XSS」 和 「非持久型 XSS」\n\n**持久型 XSS**「存储型」\n\n持久型 XSS 就是对客户端攻击的脚本直接植入到服务器上，从而导致每个用户访问此网站都会遭到 XSS 的攻击\n\n**非持久型 XSS**「反射型」\n\n非持久型 XSS 是对一个页面的某个参数做文章，把精心构造好的恶意脚本包装在 URL 参数中，再讲 URL 发布到网上，骗取用户访问\n\n手段主要有\n\n* HTML 节点内容的注入 例如 添加评论\n* HTML 属性 例如 通过 url 传值动态修改 `img` 的 `src`\n* javascript 代码 例如 传递的变量添加双引号并在双引号后面添加要注入的脚本\n\n### 防御 XSS\n\n对于非持久型 XSS\n\n* 现代浏览器都对 xss 有了一定的防范作用，但也仅限于 html 节点和属性的注入。\n* Web 页面渲染的所有内容和数据必须来自于服务器\n* 尽量不使用 `eval`, `new Function()`,`window.setTimeout()`,`innerHTML`等可执行字符串的方法\n* 前端渲染的时候要对任何字段都需要做转义\n* 对于用户输入的要添加限制，比如用户名和密码只允许字符和数字，email 必须为 email 格式\n* 对于富文本采用**过滤**，可以通过国人写的 [xss](https://github.com/leizongmin/js-xss)\n\n对于持久型 XSS\n\n* 后端在入库的时候不相信任何前端的数据，将所有的字段统一进行转义处理\n* 后端在传递给前端数据的时候统一做转义处理\n* 前端不相信后端传来的数据，任何字段也都需要做转义处理\n\n**举个栗子**:chestnut:\n\n先看一下后台的代码「node.js」\n\n```js\napp.get('/api/xss', function(req, res) {\n  res.setHeader('X-XSS-Protection', 0) //关闭浏览器 XSS\n\n  res.json('hutchins <script>console.log(1)</script>') //模拟XSS攻击，后台返回了带脚本的字符串\n})\n```\n\n前台代码\n\n```js\n$.ajax({\n  type:'get',\n  url:\"http://localhost:3003/api/xss\",\n  dataType:'json',\n  success:function(data){\n    $('#uname').html(data) //这样在前台就会插入 script 标签\n  }\n})\n```\n\n这样便会在前台插入脚本代码并在控制台打印 `1`，那么对于此类代码就需要将其转义，让其无法运行，在 `success` 方法中改为如下代码\n\n```js\n//进行HTML转义后便会插入正常的内容\nvar str = data\nstr = str.replace(/</g,'&lt')\nstr = str.replace(/>/g,'&gt')\n$('#uname').html(str)\n\n//但其实这样也可以完美插入\n$('#uname').text(data) \n```\n\n## CSRF\n\nCSRF 「Cross-site request forgery」中文名称为跨站请求伪造\n\n攻击者盗用了你的登录信息，以你的身份模拟发送各种请求。\n\n完成 CSRF 攻击有**三个条件**\n\n* 用户已经登录了站点 A，并且在本地保留了 cookie\n* 在用户没有登出站点的情况下**也就是 cookie 还在生效的情况下**访问了攻击者提供的危险站点 B\n* 站点 A 没有任何 CSRF 防御\n\n### CSRF 手段\n\n拿发表评论为例，就是用户登录后编写评论点击发表这种操作，如果发表评论是 `get` 请求\n\n那 CSRF 攻击者可以通过在自制的 B 危险网站上面写一个 `a` 标签，然后由 `a` 标签模拟你点击评论发起的 `get` 请求，当你点击时，就会在 A 网站添加一个评论，这也是为什么 CSRF 叫 「one click attack 一点就爆炸」，当然也可以直接写一个图片在你不知情时发送 `get` 请求\n\n那你此刻会想，那把添加评论改成 `post` 请求应该就安全了吧\n\n改成 `post` 请求，攻击者可以在 B 网站用 js 动态生成表单，然后发送 `post` 请求，更高级点可以再生成一个隐藏的 `iframe` 让表单 `target` 指向其 `name`，让你在完全没有察觉的情况下以你的名义干一些羞羞的事情\n\n### CSRF 防御\n\n**从 cookie 方面下手**\n\n* 禁止止第三方网站使用 cookie，使用 `sameSite:Strict` 目前仅有 chrome 支持\n\n**从绕过前端页面下手**\n\n* 在前端页面加入验证信息，可以使用 [ccap](https://github.com/DoubleSpout/ccap)\n* 加入 token，token 在前端页面 `cookie` 和 后端必须保持一致，如果是 `ajax` 请求的话可以在前端页面 `meta` 处添加一个 `token` 属性，然后用 `js` 动态获取\n\n**referer 为 B 网站**\n\n验证 referer `/^域名/`，这里注意一下，如果你是用本地文件测试的话，`file` 协议是没有 referer 的\n","tags":["Safe"],"categories":["Explore"]},{"title":"跨域问题总结","url":"%2F2018%2F05%2F28%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F","content":"\n> 跨域问题是日常中必须要面对的，每次面试必考跨域也体现了跨域技术的重要性，跨域的文章也多的数不过来，今天这篇文章主要是用来总结自己每种跨域技术的尝试，如果有幸能帮到别人那就再好不过了\n\n<!--more-->\n\n## 大概\n\n自己用 node 搭了两个服务器，前台设置的端口为 3002，模拟的服务端设置的端口为 3001\n\n跨域问题的出现是由于「同源策略」引起的，「同源」就指的是三个相同，即「协议相同」、「域名相同」、「端口相同」，「同源策略」使得以下三种行为受到限制\n\n* Cookie、LocalStorage 和 IndexDB 无法获取\n* DOM 无法获取\n* Ajax 请求无法发送\n\n具体情况还请移步[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)\n\n自己在这还是稍微总(jie)结(jian)一下，写一遍加深一下印象\n\n## 对于 Cookie 和 iframe\n\n对于 Cookie 和 iframe ，如果两个网页一级域名相同，只是二级域名不同，比如 `a.hutchins.com` 和 `b.hutchins.com` ，浏览器可通过设置相同的 `document.domain`\n\n```js\ndocument.domain = 'hutchins.com'\n```\n\n服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如\n\n```js\nSet-Cookie: key=value; domain=hutchins.com; path=/\n```\n\n这样的话二级域名和三级域名不做任何设置就可以读取这个 Cookie\n\n## window.postMessage\n\nH5 引入了全新的 API :「跨文档通信 API」\n\n```js \notherWindow.postMessage(message, tragetOrigin);\n```\n\n* `otherWindow` 窗口\n* `message` 要发送的信息\n* `targetOrigin` 指定哪些窗口可以接受到信息，`*` 表示无限制\n\n接收窗口通过 `message` 方法接收\n\n```js\nwindow.addEventListener('message' function(e) {\n\n})\n```\n\n`message` 的事件对象有以下三个属性\n\n* event.source 发送消息的窗口\n* event.origin 消息发向的网址\n* event.data 发送的消息\n\n## AJAX 跨域\n\n### jsonp 跨域\n\njsonp 的原理就是动态创建 `script` 标签，然后用 `script` 的 `src` 属性引用外部跨域链接，通过**回调函数参数**接受后台传递的信息\n\n```js\n//原生js\nvar script = document.createElement('script')\nscript.type = 'text/javascript'\n\n//传参并指定回调函数执行函数为onBack\nscript.src = 'http://localhost:3001/api/jsonp?uname=hutchins&callback=onBack'\ndocument.body.appendChild(script)\n\n//回调执行函数\nfunction onBack(res) {\n  console.log(JSON.stringify(res))\n}\n```\n\n```js\n//利用jquery ajax\n$.ajax({\n  url: 'http://localhost:3001/api/jsonp?uname=hutchins',\n  type: 'get',\n  dataType: 'jsonp', // 请求方式为jsonp\n  jsonpCallback: 'onBack', // 自定义回调函数名\n  data: {},\n  success: function(data) {\n    console.log(data)\n  }\n})\n```\n\n```js\n//node 后台处理前端请求的函数\nmodule.exports = {\n  //jsonp\n  jsonpf: function(req, res) {\n    var params = req.query\n    var fn = req.query.callback\n\n    res.writeHead(200, { 'Content-Type': 'text/javascript' })\n    res.write(fn + '(' + JSON.stringify(params) + ')')\n    res.end()\n  }\n}\n```\n\n但是 jsonp 只能支持 Get 请求\n\n### 跨域资源共享 「CORS」\n\n请求分为「简单请求」和「非简单请求」，而处理这两种请求的方式很不同，这里只说一下「简单请求」\n\n请求方式为以下几种\n\n* HEAD\n* GET\n* POST\n\nHTTP 的消息头不超出以下几种字段\n\n* Accept\n* Accept-Language\n* Content-Language\n* Last-Event-ID\n* Content-Type 只限于 application/x-www-form-ulrencoded、multipart/form-data、text/plain\n\n```js\n// 原生js\nvar xhr\nif (window.XMLHttpRequest) {\n  xhr = new XMLHttpRequest()\n} else {\n  xhr = new XDomainRequest() //兼容 IE8/9\n}\n\n//前端设置 cookie\nxhr.withCredentials = true\n\nxhr.open('post', 'http://localhost:3001/api/cors', true)\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('uname=hutchins')\n\nxhr.onreadystatechange = function() {\n  if (xhr.readyState == 4 && xhr.status == 200) {\n    console.log(xhr.responseText)\n  }\n}\n```\n\n```js\n//跨域后台设置\nres.writeHead(200, {\n  'Access-Control-Allow-Credentials': 'true', //后端允许发送 cookie\n  'Access-Control-Allow-Origin': 'http://localhost:3002'\n  // 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie\n})\n\nres.write(JSON.stringify(postData))\nres.end()\n```\n","tags":["CrossDomain"],"categories":["Explore"]},{"title":"FlexDisplayRoom","url":"%2F2018%2F05%2F25%2FFlexDisplayRoom%2F","content":"\n> 前段时间面试发现有很多都问 flex 布局，就觉得灰常有必要去学习一下，浏览了一遍[阮一峰大神写的教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$)后掌握了基本理论，但始终觉得应该实践一下，偶然间看到下面这样一个网站\n\n<!--more-->\n\nhttps://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/ \n\n**应该要翻墙**才能进去，这个网页在手机端需要不断的上下滑动，个人感觉有必要修改一下，就萌生了也做一个类似的想法，当然自己手机端做的也不是那么好，但是在做的过程中也学到了一些适应手机端的一些知识\n\n[项目展示地址](http://www.haoqinzz.cn/FlexDisplayRoom/)\n\n[项目源码地址](https://github.com/MLuminary/subentry/tree/master/FlexDisplayRoom)\n\n## Flex 布局的基础知识\n\n采用 flex 布局的元素，称为 Flex 容器，它的所有子元素自动成为容器成员，成为 Flex 项目\n\n### 容器的属性\n\n以下属性第一个取值为默认值\n\n**flex-direction**\n\n- row : 主轴为水平方向，起点在左端\n- row-reverse : 主轴为水平方向，起点在右侧\n- column : 主轴为垂直方向，起点在上沿\n- column-reverse : 主轴为垂直方向，起点在下沿\n\n**flex-wrap**\n\n- nowrap : 不换行\n- wrap : 换行，第一行在上方\n- wrap-reverse: 换行，第一行在下方\n\n**flex-flow**\n\n`flex-flow` 是 `flex-direction` 和 `flex-wrap` 的简写形式，默认值为 `row nowrap`\n\n**justify-content**\n\n- flex-start :  左对齐\n- flex-end : 右对齐\n- center : 居中\n- space-between : 两端对齐，项目之间间隔都相等\n- space-around : 每个项目两侧的间隔相等\n\n**align-items**\n\n- stretch : 如果项目未设置高度或设为 auto ，将占满整个容器的高度\n- flex-start : 交叉轴的起点对齐\n- flex-end : 交叉轴的终点对齐\n- center : 交叉轴的中点对齐\n- baseline : 项目的第一行文字的基线对齐\n\n**align-content**\n\n- stretch : 轴线占满整个交叉轴\n- flex-start : 与交叉轴的起点对齐。\n- flex-end : 与交叉轴的终点对齐。\n- center : 与交叉轴的中点对齐。\n- space-between : 与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around : 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n\n### 项目的属性\n\n**order**\n\n定义项目的排列顺序，属性值越小，排列越靠前，默认为 0\n\n**flex-grow**\n\n定义项目的放大比例，默认为 0 ，即如果存在剩余空间也不放大\n\n**flex-shrink**\n\n定义项目的缩小比例，默认为 1 ，即如果空间不足，项目将自动缩小，负值对该属性无效\n\n**flex-basis**\n\n定义了在分配多余空间之前，项目占据的主轴空间。默认值为 `auto` 即项目本来的大小\n\n**flex**\n\n`flex` 是 `flex-grow`、`flex-shrink` 和 `flex-basis` 的简写，默认值为 `0 1 auto` \n\n该属性有两个快捷值 : `auto`(`1 1 auto`) 和 `none`(`0 0 auto`)\n\n**align-self**\n\n`align-self` 允许单个项目与其它项目有不一样的对其方式，可覆盖 `align-items`。默认值为 `auto`，表示继承父元素的 `align-items` 属性\n","tags":["Css"],"categories":["Fun"]},{"title":"性感慕课-在线被爬","url":"%2F2018%2F05%2F20%2F%E6%80%A7%E6%84%9F%E6%85%95%E8%AF%BE-%E5%9C%A8%E7%BA%BF%E8%A2%AB%E7%88%AC%2F","content":"\n> 在学习了 alsotang 大神的 《Node.js包教不包会》后的一个爬虫小练习，期间也碰到挺多小问题，也学到了很多小东西。「 单押×3 」:trollface: <br> 这里是大神的教程地址 https://github.com/alsotang/node-lessons，\n\n<!--more-->\n\n下面是自己的爬取效果图\n\n![spider2](性感慕课-在线被爬/spider2.png)\n\n[imoocSpider练习源码](https://github.com/MLuminary/subentry/blob/master/easySpider/imoocSpider/app.js)\n\n\n## 搭建服务器\n\n首先，搭建一个 http 服务\n\n```js\nvar http = require('http')\nvar express = require('express')\n\nvar app = express()\n\nhttp.createServer(app).listen(8080)\n\napp.get('/', function(req, res) {\n  //code here...\n})\n```\n\n用的是 `express` 搭建的，当然也可以用原生的，在这里自己比较习惯用 [express](http://www.expressjs.com.cn/)\n\n## 在线爬虫\n\n在这里用到的是 `superagent` 和 `cheerio` 来爬取页面，这里有相关文档可以参考: [superagent中文文档](https://cnodejs.org/topic/5378720ed6e2d16149fa16bd)、[cheerio](https://cnodejs.org/topic/5203a71844e76d216a727d2e)，都是来自 cnode 社区，当然英语能力较好的也可以参考原文档。在这里就只贴出这两个\n\n爬取页面链接 https://www.imooc.com/course/list?c=fe\n\n我们是要爬取慕课网前端开发八个页面的课程中的一些信息，但是打开此链接发现每个页面只有课程的名称，并没有老师的名称和一些课程的主要信息。因此我们还需要获取并根据每个课程的 url 进行爬取。\n\n**获取课程详情页链接**\n\n那我们先来爬取八个页面的所有课程详情页的 `url`\n\n通过点击对应页面的按钮，发现每次都会发送一个新的 get 请求，请求的链接就是对应的页面，而这里的链接只有 `page` 属性是不同的，因此我们通过动态改变 `page` 就可以模拟点击对应页来获取对应页的信息\n\n```js\nvar pages = 1\nvar baseUrl = 'https://www.imooc.com/course/list/'\n\nvar params = {\n  c: 'fe',\n  page: page\n}\n\nsuperagent\n  .get(baseUrl)\n  .query(params)\n  .end(function(err, content) {\n    var topicUrls = []\n    var $ = cheerio.load(content.text)\n    var courseCard = $('.course-card-container')\n    courseCard.each(function(index, element) {\n      var $element = $(element)\n      var href = url.resolve(\n        homeUrl,\n        $element.find('.course-card').attr('href')\n      )\n\n      topicUrls.push(href)\n    })\n    console.log(topicUrls)\n  })\n```\n\n这样就可以获取到了第一个页面的 25 个课程的详情页的 url，那要如何获取八个页面呢。\n\n**async**\n\n因为有些网站通常都会有安全限制，不会允许同一个域名有过大的高并发数，因此需要限制并发数，在这里用我们用到了 `async` 这个库。这里是其 [github](https://github.com/caolan/async)\n\n我们首先把前面代码封装成一个函数\n\n```js\nvar baseUrl = 'https://www.imooc.com/course/list/'\nvar fetchUrl = function(page, callback) {\n    count++\n    console.log('当前并发数', count)\n\n    var params = {\n      c: 'fe',\n      page: page\n    }\n\n    superagent\n      .get(baseUrl)\n      .query(params)\n      .end(function(err, content) {\n        var topicUrls = []\n        var $ = cheerio.load(content.text)\n        var courseCard = $('.course-card-container')\n        courseCard.each(function(index, element) {\n          var $element = $(element)\n          var href = url.resolve(\n            homeUrl,\n            $element.find('.course-card').attr('href')\n          )\n\n          topicUrls.push(href)\n        })\n\n        callback(err, topicUrls)\n        count--\n        console.log('释放并发数后当前并发数', count)\n        \n      })\n  }\n```\n\n然后用 `async` 控制并发数和八个页面的抓取\n\n```js\nvar pages = [1, 2, 3, 4, 5, 6, 7, 8]\nasync.mapLimit(\n    pages, \n    5,\n    function(page, callback) {\n      fetchUrl(page, callback)\n    },\n    function(err, result) {\n      if (err) console.log(err)\n\n      console.log(result)\n    }\n  )\n})\n```\n\n这样所有的 url 就被打印出来，这里要注意一下，`async` 会自动把第三个函数参数的返回值合并成一个数组给第四个函数参数的 `result` 参数。刚开始写的时候我把 `topicUrls` 声明在了全局，以至于返回成下面这组数据\n\n![spider1](性感慕课-在线被爬/spider1.png)\n\n**爬取课程详情页的信息**\n\n在我们有了所有课程详情页的 url 后，我们开始爬取里面的内容。首先定义一个函数\n\n```js\nvar fetchMsg = function(topicUrl, callback) {\n    console.log('开启新一轮抓取')\n    superagent\n      .get(topicUrl)\n      .end(function(err, content){\n        var Item = []\n        var $ = cheerio.load(content.text)\n        var title = $('.hd .l').text().trim()//课程名字\n        var teacher = $('.tit a').text().trim()//老师名字\n        var level = $('.meta-value').eq(0).text().trim()//难度\n        var time = $('.meta-value').eq(1).text().trim()//时长\n        var number = $('.meta-value').eq(2).text().trim()//学习人数\n        var grade = $('.meta-value').eq(3).text().trim()//评分\n\n        Item.push({\n          title: title,\n          teacher: teacher,\n          level: level,\n          time: time,\n          number: number,\n          grade: grade,\n          href: topicUrl\n        })\n\n\n        callback(null, Item)\n      })\n  }\n```\n\n然后用 `async` 控制并发爬取\n\n```js\n//result 为上文中的 result，下面的代码也都是在上文中的第四个参数中\n\nvar topicUrls = result //获取所有 url ，但是大数组里面有 8 个小数组\n\nvar Urls = []\n//将大数组合并\nfor(let i=0,l=topicUrls.lengthi<li++){\n  Urls = Urls.concat(topicUrls[i])\n}\n\nasync.mapLimit(\n  Urls,\n  5,\n  function(url,callback){\n    fetchMsg(url, callback)\n  },\n  function(err, result) {\n    //避免乱码\n    res.writeHead(200, {'Content-Type': 'text/plaincharset=utf8'})\n    res.end(JSON.stringify(result))\n  }\n```\n\n这里要注意一个小问题，就是 `result` 获取到的 url 结构是一个大数组里面包含八个小数组，因此需要将其小数组先合并成一个大数组。\n\n## 最后\n\n附上[项目源码](https://github.com/MLuminary/subentry/blob/master/easySpider/imoocSpider/app.js)\n","tags":["Node"],"categories":["Fun"]},{"title":"今天这个仇先记下来了","url":"%2F2018%2F05%2F17%2F%E4%BB%8A%E5%A4%A9%E8%BF%99%E4%B8%AA%E4%BB%87%E5%85%88%E8%AE%B0%E4%B8%8B%E6%9D%A5%2F","content":"\n![jichou](今天这个仇先记下来/jichou.jpg)\n\n<!--more-->\n\n最近这个记仇图片在我的一些群里出现次数相当高，朋友们都会去用修图软件去改下面的文字，作为一个前端党就在想能不能更加便利一点，一开始想用 `canvas` 去画文字，后来就偶然搜到了 [html2canvas](http://html2canvas.hertzen.com/)，是一款截图工具，那这样就方便多了。\n\n## 实现\n\n![anpai](今天这个仇先记下来/anpai.jpg)\n\n具体实现方式就是利用 html2canvas 对一个 Div 进行截图，在这个 Div 里有记仇的图片和可编辑的文本框，然后再在下面展示并下载下来就阔以了，这部分涉及到了 base64 图片的下载，也是借用了 segmentFault 上[大神的代码](https://segmentfault.com/q/1010000005816241) \n\n[体验地址](http://www.haoqinzz.cn/jichou/)\n[项目地址](https://github.com/MLuminary/subentry/tree/master/%E4%BB%8A%E5%A4%A9%E8%BF%99%E4%B8%AA%E4%BB%87%E5%85%88%E8%AE%B0%E4%B8%8B%E6%9D%A5)\n[更多](https://www.v2ex.com/t/455984#reply42)","tags":["Canvas"],"categories":["Fun"]},{"title":"LeanJs「 ES6 」-- 正则的扩展","url":"%2F2018%2F01%2F31%2FLeanJS%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%2F","content":"\n![Js](LeanJS正则的扩展/js.png)\n\n<!--more-->\n\n## RegExp 构造函数\n\nES5 中的 `RegExp` 构造函数只有两种情况\n\n```js\n//第一种\nvar regex = new RegExp('xyz', 'i');\n\n//第二种\nvar regex = new RegExp(/xyz/i);\n\n//等价于\nvar  regex = /xyz/i\n```\n\n但是 ES5 中不允许下面这种情况\n\n```js\nvar regex = new RegExp(/xyz/,'i')\n```\n\nES6 改变了这种情况，如果第一个参数为正则对象时，可以使用第二个参数为指定修饰符。但是返回的正则表达式会忽略掉原有的正则的修饰符\n\n```js\nvar regex = new RegExp(/xyz/ig,'i')\n\n等价于\nvar regex = /xyz/i\n```\n\n## u 修饰符\n\nES6 添加 `u` 修饰符来正确处理四个字节的 UTF-16 的编码，加上 `u` 字符就是识别其为一个字符\n\n```js\n/^\\uD83D/u.test('\\uD83D\\uDC2A') // false\n/^\\uD83D/.test('\\uD83D\\uDC2A') // true\n```\n\n一旦加上 `u` 修饰符，就会修改下面这些正则表达式的行为\n\n### 点字符\n\n点 `.` 字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 `0xFFFF` 的 Unicode 字符，点字符不能识别，必须加上 `u` 修饰符。\n\n```js\nvar s = '𠮷';\n\n/^.$/.test(s) // false\n/^.$/u.test(s) // true\n```\n上面代码表示，如果不添加 `u` 修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。\n\n### Unicode 字符表示法\n\nES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 `u` 修饰符，才能识别当中的大括号，否则会被解读为量词。\n\n```js\n/\\u{61}/.test('a') // false\n/\\u{61}/u.test('a') // true\n/\\u{20BB7}/u.test('𠮷') // true\n```\n\n上面代码表示，如果不加 `u` 修饰符，正则表达式无法识别 `\\u{61}` 这种表示法，只会认为这匹配 `61` 个连续的 `u`。\n\n### 量词\n\n使用 `u` 修饰符后，所有量词都会正确识别码点大于 `0xFFFF` 的 Unicode 字符。\n\n```js\n/a{2}/.test('aa') // true\n/a{2}/u.test('aa') // true\n/𠮷{2}/.test('𠮷𠮷') // false\n/𠮷{2}/u.test('𠮷𠮷') // true\n```\n\n### 预定义模式\n\n`u` 修饰符也影响到预定义模式，能否正确识别码点大于 `0xFFFF` 的 Unicode 字符。\n\n```js\n/^\\S$/.test('𠮷') // false\n/^\\S$/u.test('𠮷') // true\n```\n\n上面代码的 `\\S` 是预定义模式，匹配所有不是空格的字符。只有加了 `u` 修饰符，它才能正确匹配码点大于 `0xFFFF` 的 Unicode 字符。\n\n### i 修饰符\n\n有些 Unicode 字符的编码不同，但是字型很相近，比如，`\\u004B` 与 `\\u212A` 都是大写的 `K`。\n\n```js\n/[a-z]/i.test('\\u212A') // false\n/[a-z]/iu.test('\\u212A') // true\n```\n \n上面代码中，不加 `u` 修饰符，就无法识别非规范的 `K` 字符。\n\n## y 修饰符\n\n「粘连」（sticky）修饰符。\n\n`y` 修饰符的作用与 `g` 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，`g` 修饰符只要剩余位置中存在匹配就可，而 `y` 修饰符确保匹配必须从剩余的第一个位置开始，这也就是「粘连」的涵义。\n\n```js\nvar s = 'aaa_aa_a';\nvar r1 = /a+/g;\nvar r2 = /a+/y;\n\nr1.exec(s) // [\"aaa\"]\nr2.exec(s) // [\"aaa\"]\n\nr1.exec(s) // [\"aa\"]\nr2.exec(s) // null\n```\n\n因为剩下的字符串中 `a` 不是开头，所以返回 `null`\n\n`y` 修饰符同样遵守 `lastIndex` 属性，但是要求必须在 `lastIndex` 指定的位置发现匹配。\n\n```js\nconst REGEX = /a/y;\n\n// 指定从2号位置开始匹配\nREGEX.lastIndex = 2;\n\n// 不是粘连，匹配失败\nREGEX.exec('xaya') // null\n\n// 指定从3号位置开始匹配\nREGEX.lastIndex = 3;\n\n// 3号位置是粘连，匹配成功\nconst match = REGEX.exec('xaxa');\nmatch.index // 3\nREGEX.lastIndex // 4\n```\n\n实际上，`y` 修饰符号隐含了头部匹配的标志 `^`。\n\n```js\n/b/y.exec('aba')\n// null\n```\n\n单单一个 `y` 修饰符对 `match` 方法，只能返回第一个匹配，必须与 `g` 修饰符联用，才能返回所有匹配。\n\n```js\n'a1a2a3'.match(/a\\d/y) // [\"a1\"]\n'a1a2a3'.match(/a\\d/gy) // [\"a1\", \"a2\", \"a3\"]\n```\n\n## sticky 属性\n\n与 `y` 修饰符相匹配，ES6 的正则对象多了 `sticky` 属性，表示是否设置了 `y` 修饰符。\n\n```js\nvar r = /hello\\d/y;\nr.sticky // true\n```\n\n## flags 属性\n\nES6 为正则表达式新增了 `flags` 属性，会返回正则表达式的修饰符。\n\n```js\n// ES5 的 source 属性\n// 返回正则表达式的正文\n/abc/ig.source\n// \"abc\"\n\n// ES6 的 flags 属性\n// 返回正则表达式的修饰符\n/abc/ig.flags\n// 'gi'\n```\n\n## s 修饰符 dotAll 模式\n\n正则表达式中，点 `.` 是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 `u` 修饰符解决；另一个是 「行终止符」（line terminator character）。\n\n```js\n/foo.bar/.test('foo\\nbar')\n// false\n\n/foo.bar/s.test('foo\\nbar')\n// true\n```\n\n添加 `s` 修饰符 ，`.` 就可以代表任意一个单字字符，也被成为 `dotAll` 模式，意为 「点代表所有」。还有一个 `dotAll` 属性，来判别正则表达式是否在 `dotAll` 模式中\n\n## 后行断言\n\nJavaScript 语言的正则表达式，只支持「先行断言」（lookahead）和 「先行否定断言」（negative lookahead），不支持「后行断言」（lookbehind）和 「后行否定断言」（negative lookbehind）。ES2018 引入 「后行断言」，V8 引擎 4.9 版（Chrome 62）已经支持。\n\n「先行断言」为 `x` 只有在 `y` 前面才匹配，必须写成 `/x(?=y)/`，「先行否定断言」指的是，`x` 只有不在 `y` 前面才匹配，必须写成 `/x(?!y)/`\n\n```js\n/\\d+(?=%)/.exec('100% of US presidents have been male')  // [\"100\"]\n/\\d+(?!%)/.exec('that’s all 44 of them')                 // [\"44\"]\n```\n\n上面分别匹配在 `%` 前的数字和不在 `%` 前的数字，`(?=%)` 不计入返回部分\n\n「后行断言」和「前行断言」正好相反，`x` 只有在 `y` 后面才匹配，必须写成 `/(?<=y)x/` 。比如，只匹配美元符号之后的数字，要写成 `/(?<=\\$)\\d+/` 。「后行否定断言」则与「先行否定断言」相反，`x` 只有不在 `y` 后面才匹配，必须写成 `/(?<!y)x/`。比如，只匹配不在美元符号后面的数字，要写成 `/(?<!\\$)\\d+/`。\n\n同样也是不返回`()`中的部分。所以**「前行断言」返回前面部分，判断后面部分，「后行断言」返回后面部分，判断前面部分**\n\n## Unicode 属性类\n\nES2018 引入了一种新的类的写法 `\\p{...}` 和 `\\P{...}`，允许正则表达式匹配符合 Unicode 某种属性的所有字符。\n\n```js\nconst regexGreekSymbol = /\\p{Script=Greek}/u;\nregexGreekSymbol.test('π') // true\n```\n\n上面代码中，`\\p{Script=Greek}` 指定匹配一个希腊文字母，所以匹配 `π` 成功。\n\nUnicode 属性类要指定属性名和属性值。\n\n```js\n\\p{UnicodePropertyName=UnicodePropertyValue}\n```\n\n对于某些属性，可以只写属性名，或者只写属性值。\n\n```js\n\\p{UnicodePropertyName}\n\\p{UnicodePropertyValue}\n```\n\n`\\P{…}` 是 `\\p{…}` 的反向匹配，即匹配不满足条件的字符。\n\n因为匹配的是 Unicode 字符，所以需要带上 `u` 字符\n\n## 具名组匹配\n\n### 基本用法\n\n正则表达式用圆括号来实现组的匹配\n\n```js\nconst RE_DATE = /(\\d{4})-(\\d{2})-(\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj[1]; // 1999\nconst month = matchObj[2]; // 12\nconst day = matchObj[3]; // 31\n```\n\n但是每一组匹配的含义不容易看出来，而且也只能用数字序号引用，要是组的顺序变了，就无法正确取到想取的值\n\nES2018 引入了「具名组匹配」（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。\n\n```js\nconst RE_DATE = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/;\n\nconst matchObj = RE_DATE.exec('1999-12-31');\nconst year = matchObj.groups.year; // 1999\nconst month = matchObj.groups.month; // 12\nconst day = matchObj.groups.day; // 31\n```\n\n假如没有匹配到数据，那将返回 `undefined`\n\n### 解构赋值和替换\n\n有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。\n\n```js\nlet {groups: {one, two}} = /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar');\none  // foo\ntwo  // bar\n```\n\n这里因为 ` /^(?<one>.*):(?<two>.*)$/u.exec('foo:bar')` 返回 `groups: {one: \"foo\", two: \"bar\"}`，因此其实左面的写法是固定的\n\n字符串替换时，使用 `$<组名>` 引用具名组。\n\n```js\nlet re = /(?<year>\\d{4})-(?<month>\\d{2})-(?<day>\\d{2})/u;\n\n'2015-01-02'.replace(re, '$<day>/$<month>/$<year>')\n// '02/01/2015'\n```\n\n上面代码中，`replace` 方法的第二个参数是一个字符串，而不是正则表达式。\n\n### 引用\n\n如果要在正则表达式内部引用某个「具名组匹配」，可以使用 `\\k<组名>` 的写法。\n\n```js\nconst RE_TWICE = /^(?<word>[a-z]+)!\\k<word>$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n```\n\n数字引用 `\\1` 依然有效。\n\n```js\nconst RE_TWICE = /^(?<word>[a-z]+)!\\1$/;\nRE_TWICE.test('abc!abc') // true\nRE_TWICE.test('abc!ab') // false\n```\n\n这两种引用语法还可以同时使用。\n\n```\nconst RE_TWICE = /^(?<word>[a-z]+)!\\k<word>!\\1$/;\nRE_TWICE.test('abc!abc!abc') // true\nRE_TWICE.test('abc!abc!ab') // false\n```\n\n## String.prototype.matchAll\n\n如果一个正则表达式在字符串里面有多个匹配，现在一般使用 `g` 修饰符或 `y` 修饰符，在循环里面逐一取出。\n\n```js\nvar regex = /t(e)(st(\\d?))/g;\nvar string = 'test1test2test3';\n\nvar matches = [];\nvar match;\nwhile (match = regex.exec(string)) {\n  matches.push(match);\n}\n\nmatches\n// [\n//   [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"],\n//   [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"],\n//   [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n// ]\n```\n\n上面代码中，`while` 循环取出每一轮的正则匹配，一共三轮。\n\n目前有一个提案，增加了 `String.prototype.matchAll` 方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。\n\n```js\nconst string = 'test1test2test3';\n\n// g 修饰符加不加都可以\nconst regex = /t(e)(st(\\d?))/g;\n\nfor (const match of string.matchAll(regex)) {\n  console.log(match);\n}\n// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]\n// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]\n// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"]\n```\n\n上面代码中，由于 `string.matchAll(regex)` 返回的是遍历器，所以可以用 `for...of`  循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。\n\n\n","tags":["ES6"],"categories":["Note"]},{"title":"LeanJs「 ES6 」-- 字符串的扩展","url":"%2F2018%2F01%2F30%2FLeanJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F","content":"![Js](LeanJS字符串的扩展/js.png)\n\n<!--more-->\n\n## 字符的 Unicode 表示法\n\nJavaScript 采用 `\\uxxxx` 表示一个字符， `xxxx` 表示字符的 Unicode 码点，但是这种方法只能表示 `\\u0000`~`\\uffff`之间的字符。一旦超出这个范围，就必须用两个字节表示\n\n上面代码表示，如果直接在 `\\u` 后面跟上超过 `0xFFFF` 的数值（比如 `\\u20BB7`），JavaScript 会理解成 `\\u20BB+7`。由于 `\\u20BB` 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 `7`。\n\nES6 中对此做出改进，只要将大码点放入大括号，就可正确解读\n\n```js\n\"\\u{20BB7}\"\n// \"𠮷\"\n\n\"\\uD842\\uDFB7\"\n// \"𠮷\"\n\n\"\\uD842\\uDFB7\" === \"\\u{20BB7}\"//true\n```\n\n## codePointAt()\n\nJavaScript 内部，字符已 UTF-16 的格式存储，每个字符固定为 `2` 个字节，但是 Unicode 码点大于 `0xFFFF` 会以四个字节存储，JavaScript 会认为为两个字符\n\n```js\nvar s = \"𠮷\";\n\ns.length // 2\ns.charAt(0) // ''\ns.charAt(1) // ''\ns.charCodeAt(0) // 55362\ns.charCodeAt(1) // 57271\n```\n\n对于这种需要四个字节存储的字符，`charAt` 方法无法读取，`charCodeAt` 方法只能分别返回前两个字节和后两个字节的值，ES6 提供了 `codePointAt` 可以正确处理四个字节储存的字符\n\n```js\nlet s = '𠮷a';\n\ns.codePointAt(0) // 134071\ns.codePointAt(1) // 57271\n\ns.codePointAt(2) // 97\n```\n\n对于 `𠮷` ，JavaScript 还会认为其长度为 2，`codePointAt(0)` 正确返回了它的十进制码，`codePointAt(1)` 返回了 `𠮷` 的后两个字节的十进制码，`a` 的处理与 `charCodeAt` 相同，但是 `codePointAt` 的参数确是不对的。解决这个问题的一个办法使用 `for..of`\n\n```js\nlet s = '𠮷a';\nfor (let ch of s) {\n  console.log(ch.codePointAt(0).toString(16));\n}\n// 20bb7\n// 61\n```\n\n`codePointAt` 也是检查一个字符是否是双字节存储还是四字节存储的一个好方法\n\n```js\nfunction is32Bit(s){\n  return s.codePointAt(0) > 0xFFFF;\n}\n\nis32Bit(\"𠮷\") // true\n```\n\n## String.fromCodePoint()\n\nES5 `String.fromCharCode` 不能返回 32 位 UTF-16 字符（ Unicode 大于 `0xFFFF` ）\n\n使用 `String.fromCodePoint()` 可以，如果其中有多个参数，会把所有参数合并成一个字符串\n\n注意，`fromCodePoint` 方法定义在 `String` 对象上，而 `codePointAt` 方法定义在字符串的实例对象上。\n\n## 字符串的遍历器接口\n\nES6 为字符串添加了遍历器接口，使得字符串可以被 `for...of` 循环遍历。`for...of` 也会正确识别 32 位的 UTF-16 字符\n\n## at()\n\n目前，有一个提案，提出字符串实例的 `at` 方法，可以识别 Unicode 编号大于 `0xFFFF` 的字符，返回正确的字符。\n\n```js\n'abc'.at(0) // \"a\"\n'𠮷'.at(0) // \"𠮷\"\n```\n\n## normalize()\n\nES6 提供字符串实例的 `normalize()` 方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。\n\n## includes(), startsWith(), endsWith()\n\n传统上，JavaScript 只有 `indexOf` 方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。\n\n- `includes()` ：返回布尔值，表示是否找到了参数字符串。\n- `startsWith()` ：返回布尔值，表示参数字符串是否在原字符串的头部。\n- `endsWith()` ：返回布尔值，表示参数字符串是否在原字符串的尾部。\n\n```js\nlet s = 'Hello world!';\n\ns.startsWith('Hello') // true\ns.endsWith('!') // true\ns.includes('o') // true\n```\n\n这三个方法都支持第二个参数，即开始搜索的位置。`endsWith` 的行为与其他两个方法有所不同。它针对前 `n` 个字符，而其他两个方法针对从第 `n` 个位置直到字符串结束。\n\n## repeat() \n\n`repeat` 方法返回一个新字符串，表示将原字符串重复 `n` 次，碰到小数会取整，碰到字符串会尝试转换成数字，`NaN` 视为 `0`\n\n```js\n'x'.repeat(3) // \"xxx\"\n\n'na'.repeat(0) // \"\"\n```\n\n## padStart()，padEnd()\n\n`padStart()` 用于头部补全，`padEnd()` 用于尾部补全\n\n```js\n'x'.padStart(5, 'ab') // 'ababx'\n'x'.padStart(4, 'ab') // 'abax'\n\n'x'.padEnd(5, 'ab') // 'xabab'\n'x'.padEnd(4, 'ab') // 'xaba'\n```\n\n上面代码中，`padStart` 和 `padEnd` 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。\n\n如果原字符的长度大于或者等于指定的字符串长度，则返回原字符串\n\n```js\n'xxx'.padStart(2, 'ab') // 'xxx'\n'xxx'.padEnd(2, 'ab') // 'xxx'\n```\n\n如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。\n\n```js\n'abc'.padStart(10, '0123456789')\n// '0123456abc'\n```\n\n如果省略第二个参数，默认使用空格补全长度。\n\n```js\n'x'.padStart(4) // '   x'\n'x'.padEnd(4) // 'x   '\n```\n\n`padStart` 的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。\n\n```js\n'1'.padStart(10, '0') // \"0000000001\"\n'12'.padStart(10, '0') // \"0000000012\"\n'123456'.padStart(10, '0') // \"0000123456\"\n```\n\n另一个用途是提示字符串格式。\n\n```js\n'12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-MM-12\"\n'09-12'.padStart(10, 'YYYY-MM-DD') // \"YYYY-09-12\"\n```\n\n## 模板字符串\n\n模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。\n\n如果想在模板字符串用反引号，需要用反斜杠转义\n\n```js\n`yo \\` `\n```\n\n模板字符串中的格式空格都会保留，去除空格可以用 `trim()`\n\n```js\n$('#list').html(`\n<ul>\n  <li>first</li>\n  <li>second</li>\n</ul>\n`.trim());\n```\n\n模板字符串中嵌入变量需要写在 `${}` 中，但是不能放入未声明的变量\n\n```js\n// 变量place没有声明\nlet msg = `Hello, ${place}`;\n// 报错\n```\n\n模板字符串甚至还能嵌套。\n\n```js\nconst tmpl = addrs => `\n  <table>\n  ${addrs.map(addr => `\n    <tr><td>${addr.first}</td></tr>\n    <tr><td>${addr.last}</td></tr>\n  `).join('')}\n  </table>\n`;\n```\n\n## 标签模板\n\n模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为「标签模板」功能（tagged template）。\n\n```js\nalert`123`\n// 等同于\nalert(123)\n```\n\n但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。\n\n```js\nlet a = 5;\nlet b = 10;\n\ntag`Hello ${ a + b } world ${ a * b }`;\n// 等同于\ntag(['Hello ', ' world ', ''], 15, 50);\n```\n\n上面代码中，模板字符串前面有一个标识名 `tag` ，它是一个函数。整个表达式的返回值，就是 `tag` 函数处理模板字符串后的返回值。\n\n函数 `tag` 依次会接收到多个参数。\n\n```js\nfunction tag(stringArr, value1, value2...){\n  // ...\n}\n```\n\n`tag` 函数的第一个参数为一个数组，该数组的成员是那些没有变量替换的部分，后面的值为变量\n\n下面一个更复杂的值\n\n```js\nlet total = 30;\nlet msg = passthru`The total is ${total} (${total*1.05} with tax)`;\n\nfunction passthru(literals) {\n  let result = '';\n  let i = 0;\n\n  while (i < literals.length) {\n    result += literals[i++];\n    if (i < arguments.length) {\n      result += arguments[i];\n    }\n  }\n\n  return result;\n}\n\nmsg // \"The total is 30 (31.5 with tax)\"\n```\n\n`passthru` 只接受一个参数，就是那个接受未被变量替换的数组，在本例中也就是 `[\"The total is \", \" (\", \" with tax)\"]`，而 `arguments` 就为该函数的所有参数。\n\n## String.raw()\n\nES6 还为原生的 String 对象，提供了一个 `raw` 方法。\n\n`String.raw` 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。\n\n```js\nString.raw`Hi\\n${2+3}!`;\n// 返回 \"Hi\\\\n5!\"\n```\n\n如果原字符串的斜杠已经转义，那么 `String.raw` 会进行再次转义。\n\n```js\nString.raw`Hi\\\\n`\n// 返回 \"Hi\\\\\\\\n\"\n```\n\n`String.raw` 方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。\n\n`String.raw` 方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有 `raw` 属性的对象，且 `raw` 属性的值应该是一个数组。\n\n```js\nString.raw({ raw: 'test' }, 0, 1, 2);\n// 't0e1s2t'\n\n// 等同于\nString.raw({ raw: ['t','e','s','t'] }, 0, 1, 2);\n```\n\n作为函数，`String.raw` 的代码实现基本如下。\n\n```js\nString.raw = function (strings, ...values) {\n  let output = '';\n  let index;\n  for (index = 0; index < values.length; index++) {\n    output += strings.raw[index] + values[index];\n  }\n\n  output += strings.raw[index]\n  return output;\n}\n```\n\n\n\n","tags":["ES6"],"categories":["Note"]},{"title":"LeanJs「 ES6 」-- 变量的解构赋值","url":"%2F2018%2F01%2F29%2FLeanJS%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E4%B8%8E%E8%B5%8B%E5%80%BC%2F","content":"![Js](LeanJS变量的解构与赋值/js.png)\n\n<!--more-->\n\n## 数组的解构赋值\n\n### 基本用法\n\n>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）\n\n本质上来说就是一种「模式匹配」，如果右边不是可遍历的结构，即本身不具有 Iterator 接口，或者转换为对象也不具备 Iterator 接口，才会报错\n\n```js\n//ES6\nlet [a, b, c] = [1, 2, 3];\n\n//ES5\nvar a = 1,\n    b = 2,\n    c = 3;\n```\n\n如果等号左边的值多于等号右边的值，就会匹配不成功\n\n```js\nlet [a, b] = [4];\n\na //4\nb //undefiend\n```\n\n匹配不成功，变量的值就为 `undefined`，将上述代码转换成 ES5 后可以看清原理\n\n```js\n\"use strict\";\n\nvar _ref = [4],\n    a = _ref[0],\n    b = _ref[1];\n```\n\n如果等号左边的值少于等号右边的值，为不完全解构\n\n```js\nlet [x, y] = [1, 2, 3];\nx // 1\ny // 2\n```\n\n### 默认值\n\n结构赋值允许指定默认值\n\n```js\nlet [a, b = 4] = [3]\nb//4\nlet [a, b = 4] = [3, 3]\nb//3\n```\n\n工作原理如下\n\n```js\n\"use strict\";\n\nvar _ref = [3],\n    a = _ref[0],\n    _ref$ = _ref[1],\n    b = _ref$ === undefined ? 4 : _ref$;\n```\n\n只有右边相对应的值是 `undefined` ，才会为默认值\n\n```js\nlet [b = 4] = [null]\nb//null\n```\n\n因为 `null` 不严格等于 `undefined` 所以默认值不会生效\n\n默认值也可以是一个表达式，也可以引用解构赋值的其它变量\n\n```js\nlet [x = 1, y = x] = [];     // x=1; y=1\nlet [x = y, y = 1] = [];     // ReferenceError: y is not defined\n```\n\n## 对象的解构赋值\n\n### 基本用法\n\n对象的解构与数组有一个重要的不同，数组是按照次序，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名才能相互匹配\n\n```js\nlet {bar , foo} = {foo : 'aaa',bar : 'bbb'}\nbar // 'bbb'\nfoo // 'aaa'\n```\n\n以上代码可以看出，对象的解构赋值完全不受次序影响，转换为 ES5 代码如下\n\n```js\nvar _foo$bar = { foo: 'aaa', bar: 'bbb' },\n    bar = _foo$bar.bar,\n    foo = _foo$bar.foo;\n```\n\n但其实以上代码是下面代码的简写形式\n\n```js\nlet {bar: bar ,foo: foo} = {foo : 'aaa',bar : 'bbb'}\n```\n\n为什么这么说嘞，请看下面的代码\n\n```js\nlet {baz: a, foo: b} = {foo : 'aaa',bar : 'bbb'}\n\nfoo //foo is not defined\nb //'aaa'\n```\n\n上面的代码转换成 ES5 的代码为\n\n```js\nvar _foo$bar = { foo: 'aaa', bar: 'bbb' },\n    a = _foo$bar.baz,\n    b = _foo$bar.foo;\n```\n\n也就是说对象赋值的内部机制，是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者，而不是前者。因此上面的代码中，`foo` 只是模式匹配，`a` 才是真正被赋值的变量\n\n解构也可以用于嵌套结构的对象\n\n```js\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\n```\n\n但是 `p` 为匹配的模式，不是变量，因此不会赋值。如果 `p` 要赋值，可以写成下面这样\n\n```js\nlet obj = {\n  p: [\n    'Hello',\n    { y: 'World' }\n  ]\n};\n\nlet { p, p: [x, { y }] } = obj;\nx // \"Hello\"\ny // \"World\"\np // [\"Hello\", {y: \"World\"}]\n```\n\n看下面这个例子\n\n```js\nconst node = {\n  loc: {\n    start: {\n      line: 1,\n      column: 5\n    }\n  }\n};\n\nlet { loc, loc: { start }, loc: { start: { line }} } = node;\nline // 1\nloc  // Object {start: Object}\nstart // Object {line: 1, column: 5}\n```\n\n上面代码有三次解构赋值，分别是对 `loc` 、`start` 、`line` 三个属性的解构赋值。注意，最后一次对 `line` 属性的解构赋值之中，只有 `line` 是变量，`loc` 和 `start` 都是模式，不是变量。\n\n对象的解构也可以指定默认值，默认值生效的条件是，相对应的对象的属性严格等于　`undefined`\n\n如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。\n\n```js\nlet {foo: {bar}} = {baz: 'baz'};\n```\n\n原因就是等号左边的 `foo` 属性对应了一个对象，如果想给 `bar` 赋值需要经过这样的步骤\n\n```js\nlet _tmp = {baz: 'baz'};\n_tmp.foo.bar // 报错\n```\n\n因为 `_tmp.foo` 为 `undefined`，当然就会报错\n\n如果要将一个已经声明的变量用于解构赋值，必须非常小心。\n\n```js\n// 错误的写法\nlet x;\n{x} = {x: 1};\n// SyntaxError: syntax error\n```\n\n上面代码的写法会报错，因为 JavaScript 引擎会将 `{x}` 理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。\n\n```js\n// 正确的写法\nlet x;\n({x} = {x: 1});\n```\n\n## 字符串的解构赋值\n\n字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。\n\n```js\nconst [a, b, c, d, e] = 'hello';\na // \"h\"\nb // \"e\"\nc // \"l\"\nd // \"l\"\ne // \"o\"\n```\n\n类似数组的对象都有一个 `length` 属性，因此还可以对这个属性解构赋值。\n\n```js\nlet {length : len} = 'hello';\nlen // 5\n```\n\n## 数值和布尔值解构赋值\n\n解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。\n\n解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于 `undefined` 和 `null` 无法转为对象，所以对它们进行解构赋值，都会报错。\n\n## 函数参数的解构赋值\n\n```js\nfunction add([x, y]){\n  return x + y;\n}\n\nadd([1, 2]); // 3\n```\n\n函数的参数的解构也可以使用默认值\n\n```js\nfunction move({x = 0, y = 0} = {}) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, 0]\nmove({}); // [0, 0]\nmove(); // [0, 0]\n```\n\n注意，下面的写法会得到不一样的结果。\n\n```js\nfunction move({x, y} = { x: 0, y: 0 }) {\n  return [x, y];\n}\n\nmove({x: 3, y: 8}); // [3, 8]\nmove({x: 3}); // [3, undefined]\nmove({}); // [undefined, undefined]\nmove(); // [0, 0]\n```\n\n上面代码是为函数 `move` 的参数指定默认值，而不是为变量 `x` 和 `y` 指定默认值，所以会得到与前一种写法不同的结果。\n\n## 圆括号问题\n\n解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。\n\n由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。\n\n但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。\n\n### 不能使用圆括号\n\n#### 变量声明语句\n\n```js\n// 全部报错\nlet [(a)] = [1];\n\nlet {x: (c)} = {};\nlet ({x: c}) = {};\nlet {(x: c)} = {};\nlet {(x): c} = {};\n\nlet { o: ({ p: p }) } = { o: { p: 2 } };\n```\n\n#### 函数参数\n\n```js\n// 报错\nfunction f([(z)]) { return z; }\n// 报错\nfunction f([z,(x)]) { return x; }\n```\n\n#### 赋值语句中的模式\n\n```js\n// 全部报错\n({ p: a }) = { p: 42 };\n([a]) = [5];\n```\n\n### 可以使用圆括号\n\n只有一种，那就是赋值语句中的非模式\n\n```js\n[(b)] = [3]; // 正确\n({ p: (d) } = {}); // 正确\n[(parseInt.prop)] = [3]; // 正确\n```\n\n上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是 `p` ，而不是 `d` ；第三行语句与第一行语句的性质一致。","tags":["ES6"],"categories":["Note"]},{"title":"LeanJs「 ES6 」-- Let 和 Const 命令","url":"%2F2018%2F01%2F28%2FLeanJSLET%E5%92%8CCONST%2F","content":"![Js](LeanJSLET和CONST/js.png)\n\n<!--more-->\n\n## Let 命令\n\n### 基本用法\n\n`let` 所声明的变量只在 `let` 命令所在的代码块内有效\n\n```js\n{\n  var a = 10;\n  let b = 10;\n}\n\na // 10\nb // Uncaught ReferenceError: b is not defined\n```\n\n对于我们以前碰到的循环中很经典的问题，就可以用 `let` 来解决\n\n```js\nvar a = [];\nfor(var i = 0 ; i < 5 ; i++){\n  a[i] = function(){\n    console.log(i);\n  }\n}\n\na[1]()//5\n```\n\n上面这种情况用 `var` 声明 `i`，它在全局作用内都有效，最后调用 `a[1]()` 时，循环早已结束，输出的是全局作用域中的 `i`\n\n```js\nvar a = [];\nfor(let i = 0 ; i < 5 ; i++){\n  a[i] = function(){\n    console.log(i);\n  }\n}\n\na[1]()//1\n```\n\n因为 `let` 声明的变量仅在当前块级作用域中有效，当前的 `i` 只在本轮循环中有效，所以每次循环的 `i` 其实都相当于一个新的变量。\n\n用 `babel` 转换成 ES5 语法其实是下面这个样子\n\n```js\n\"use strict\";\n\nvar a = [];\n\nvar _loop = function _loop(i) {\n  a[i] = function () {\n    console.log(i);\n  };\n};\n\nfor (var i = 0; i < 5; i++) {\n  _loop(i);\n}\n```\n\n`for` 循环设置循环变量的那部分是一个父级作用域，而循环体内部是一个单独的子作用域\n\n### 不存在变量提升\n\n`let` 命令它所声明的变量一定要在声明后使用，否则报错。\n\n```js\nconsole.log(varName);//undefined\nvar varName = 'h';\n\nconsole.log(letName);//letName is not defined\nlet letName = 'p';\n```\n\n### 暂时性死区\n\n只要块级作用域存在 `let` 命令，它所声明的变量就「绑定」这个区域，不再受外部的影响\n\nES6 明确规定，如果区块内部存在 `let` 和 `const` 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。\n\n在代码块内，从开始到用 `let` 声明变量之前，改变量都是不可用的，在语法上被称为 「暂时性死区」(temporal dead zone，简称 TDZ)\n\n```js\n{\n  //TDZ开始\n  tmp = \"abc\"; // ReferenceError\n  console.log(tmp); // ReferenceError\n\n  let tmp;//TDZ结束\n  console.log(tmp); //undefined\n\n  tmp = 123;\n  console.log(tmp);//123\n\n}\n```\n\n有些死区比较隐蔽\n\n```js\nfunction bar(x = y,y = 2){\n  return [x,y];\n}\n\nbar();//y is not defined\n```\n\n参数 `x` 默认等于 `y` ，而此时 `y` 还没有声明\n\n```js\nlet x = x;\n```\n\n使用 `let` 声明变量时，只要变量在还没有声明完成前使用，就会报错。上面 `x` 还没有声明完成就取 `x` 的值，就会报错\n\n总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。\n\n### 不允许重复声明\n\n`let` 不允许在**相同作用域**内，重复声明一个变量\n\n```js\nfunction(){\n  let a = 1;\n  var a = 10;//报错\n}\n\nfunction(){\n  let a = 1;\n  let a = 10;//报错\n}\n\nfunction(a){\n  let a; //报错\n}\n\nfunction(a){\n  {\n    let a ;//不报错\n  }\n}\n```\n\n## 块级作用域\n\nES5 中只有「全局作用域」和「函数作用域」，没有「块级作用域」，这带来很多不便\n\n首先就是众所周知的 `for` 循环的问题\n\n```js\nfor(var i = 0;i < 10 ;i++){\n  ...\n}\n\ni //10\n```\n\n用来计数的 `i` 泄漏为全局变量\n\n内存变量覆盖外层变量\n\n```js\nvar tem = 'hello';\n\nfunction f(){\n  console.log(tem);\n  if(false){\n    var tem = 'world'\n  }\n}\n\nf()//undefined\n```\n\n`if` 代码块中的 `tem` 因为变量提升其实是下面的代码\n\n```js\nfunction f(){\n  var tem;\n  console.log(tem);\n  if(false){\n    tem = 'world'\n  }\n}\n```\n\nES6 块级作用域也代替了立即执行函数（IIFE）\n\n```js\n// IIFE 写法\n(function () {\n  var tmp = ...;\n  ...\n}());\n\n// 块级作用域写法\n{\n  let tmp = ...;\n  ...\n}\n```\n\n## const 命令\n\n`const` 声明一个只读的常量。一旦声明，常量的值就不能改变，这意味着 `const` 必须声明时就赋值。\n\n```js\nconst foo;//Missing initializer in const declaration\n```\n\n但其实 `const` 保证的不是变量的值不能改动，而是变量指向的那个内存地址不得变动，对于简单类型的数据，就是值不能改动，但是对于复杂类型来说就是地址了\n\n```js\nconst foo = {};\nfoo.add = 123;\nfoo.add //123\n\nfoo = {}//Assignment to constant variable\n```\n\n`const` 的作用域以及其它特点都和 `let` 相同，上面只是比 `let` 多出来的特点\n\n## 顶层对象\n\n顶层对象，在浏览器环境指的是 window 对象，在 Node 指的是global对象。ES5 之中，「顶层对象」的属性与「全局变量」是等价的。 \n\n顶层对象和全局变量挂钩，会造成很多问题，首先就是无法在编译时就报出未声明的错误；其次，程序员很容易就创建了全局变量。\n\nES6 为了改变这一点，又为了保持兼容性，规定 `var` 命令和 `function` 命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let` 命令、`const` 命令、`class` 命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。\n\n```js\nvar a = 1;\nwindow.a //1\n\nlet b = 2;\nwindow.b //undefined\n```\n\n","tags":["ES6"],"categories":["Note"]},{"title":"LeanJs「 ES5 」-- 浏览器环境","url":"%2F2018%2F01%2F27%2FLeanJS%E6%B5%8F%E8%A7%88%E5%99%A8%E7%8E%AF%E5%A2%83%2F","content":"![Js](LeanJS浏览器环境/js.png)\n\n<!--more-->\n\n## 概述\n\n### JavaScript 代码嵌入网页的方法\n\n#### script标签:代码嵌入网页\n\n`type` 指定脚本类型\n\n- `text/javascript` 是默认值\n- `application/javascript` 对于新式浏览器，建议这个值\n- 也可以不写 `type`\n- 写一个浏览器不认识的，就不会执行\n\n#### script标签：加载外部脚本\n\n```html\n<script src=\"example.js\"></script>\n```\n\n加载外部的脚步和直接添加代码块不能混用\n\n```html\n<script src=\"example.js\">\n  console.log('hello world');\n</script>\n```\n\n`console.log` 会被忽略\n\n为了防止攻击者篡改外部脚本，`script` 标签允许设置一个 `integrity` 属性，写入该外部脚本的Hash签名，用来验证脚本的一致性\n\n```html\n<script src=\"/assets/application.js\"\n  integrity=\"sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs=\">\n</script>\n```\n\n\n#### 事件属性\n\n```html\n<div onclick=\"alert('Hello')\"></div>\n```\n\n#### URL协议\n\nURL支持 `javascript:` 协议，调用这个URL时，就会执行JavaScript代码。\n\n```html\n<a href=\"javascript:alert('Hello')\"></a>\n```\n\n### script标签\n\n#### 工作原理\n\n正常的网页加载流程是这样的\n\n1. 浏览器一边下载HTML网页，一边开始解析\n2. 解析过程中，发现 `<script>` 标签\n3. 暂停解析，网页渲染的控制权转交给JavaScript引擎\n4. 如果 `<script>` 标签引用了外部脚本，就下载该脚本，否则就直接进行\n5. 执行完毕，控制权交还给渲染引擎，恢复往下解析HTML网页\n\n#### defer 属性\n\n为了解决脚本文件下载阻塞网页渲染的问题，一个方法是加入 `defer` 属性\n\n```html\n<script src=\"a.js\" defer></script>\n<script src=\"b.js\" defer></script>\n```\n\n`defer` 的运行流程如下\n\n1. 浏览器开始解析HTML网页\n2. 解析过程中，发现带有 `defer` 属性的 `script` 标签\n3. 浏览器继续往下解析 HTML 网页，同时并行下载 `script` 标签中的外部脚本\n4. 浏览器完成解析HTML网页，此时再执行下载的脚本\n\n使用 `defer` 加载的外部脚本不应该使用 `document.write` 方法\n\n#### async\n\n解决「阻塞效应」的一个方法是加入 `async`\n\n`async` 属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染\n\n`async` 的运行流程如下\n\n1. 浏览器开始解析HTML网页\n2. 解析过程中，发现带有 `async` 属性的 `script` 标签\n3. 浏览器继续往下解析 HTML 网页，同时并行下载 `script` 标签中的外部文件\n4. 脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本\n5. 脚本执行完毕，浏览器恢复解析 HTML 网页\n\n`async` 无法保证脚本的执行顺序，一般来说，如果脚本没有依赖关系，用 `async` 属性，脚本之间有依赖关系，用 `defer` 属性，同时使用 `async` 和 `defer` 属性，后者不起作用，浏览器行为由 `async` 属性决定\n\n#### 脚本的动态加载\n\n```js\nvar script = document.createElement('script');\nscript.src = 'a.js';\ndocument.head.appendChild(script);\n```\n\n#### 加载使用的协议\n\n如果不指定协议，浏览器默认采用 HTTP 协议下载\n\n如果要采用 HTTPS 下载，必须写明\n\n```html\n<script src=\"https://example.js\"></script>\n```\n\n### 浏览器的组成\n\n浏览器的核心是两部分：渲染引擎和 JavaScript 解释器\n\n#### 渲染引擎\n\n- Firefox : Gecko\n- Safari : WebKit\n- Chrome : Blink\n- IE : Trident\n- Edge : EdgeHTML\n\n渲染引擎处理网页，通常分为四个阶段\n\n1. 解析代码 ：HTML 代码解析为 DOM，CSS 代码解析为 CSSSOM 「CSS Object Model」\n2. 对象合成 ：将 DOM 和 CSSOM 合成一棵渲染树 「render tree」\n3. 布局 ：计算出渲染树的布局 「layout」\n4. 绘制 ：将渲染树绘制到屏幕\n\n往往第一步还没完成，第二部和第三部已经开始了。\n\n#### 重流和重绘\n\n渲染树转换为网页布局，称为「布局流」（flow）；布局显示到页面的这个过程，称为「绘制」（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。\n\n重流一定会触发重绘，重绘不一定需要重流。\n\n以下是一些优化技巧\n\n- 读取 DOM 或者写入 DOM ，尽量写在一起，不要混杂\n- 缓存 DOM 信息\n- 不要一项一项地改变样式，而是使用CSS class一次性改变样式\n- 使用document fragment操作DOM\n- 动画时使用absolute定位或fixed定位，这样可以减少对其他元素的影响\n- 只在必要时才显示元素\n- 使用 `window.requestAnimationFrame()`，因为它可以把代码推迟到下一次重流时执行，而不是立即要求页面重流\n- 使用虚拟DOM（virtual DOM）库\n\n#### JavaScript 引擎\n\n早期的浏览器内部处理 JavaScript\n\n1. 读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。\n2. 对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。\n3. 使用“翻译器”（translator），将代码转为字节码（bytecode）。\n4. 使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。\n\n现在都采用了即时编译，运行到哪一行代码翻译哪一行，把编译结果缓存。V8省略了翻译字节码的步骤，直接翻译为机器码\n\n## window 对象\n\n### 概述\n\n在浏览器中，`window` 对象（注意，w为小写）指当前的浏览器窗口。它也是所有对象的顶层对象。\n\n### window 属性\n\n#### window.window，window.name\n\n`window` 对象的 `window` 属性指向自身。\n\n`window.name` 属性用于设置当前浏览器窗口的名字。该属性只能保存字符串，且当浏览器窗口关闭后，所保存的值就会消失。因此局限性比较大，但是与 `<iframe>` 窗口通信时，非常有用。\n\n#### window.location\n\n`window.location` 返回一个 `location` 对象，用于获取窗口当前的URL信息。它等同于 `document.location` 对象\n\n#### window.closed，window.opener\n\n`window.closed` 属性返回一个布尔值，表示窗口是否关闭。\n\n`window.opener` 属性返回打开当前窗口的父窗口。如果当前窗口没有父窗口，则返回 `null`。\n\n#### window.frames ，window.length\n\n`window.frames` 属性返回一个类似数组的对象，成员为页面内所有框架窗口\n\n`window.length` 属性返回当前网页包含的框架总数\n\n#### window.screenX ，window.screenY\n\n`window.screenX` 和 `window.screenY` 属性，返回浏览器窗口左上角相对于当前屏幕左上角（`(0, 0)`）的水平距离和垂直距离，单位为像素。\n\n#### window.outerHeight，window.outerWidth\n\n`window.outerHeight` 和 `window.outerWidth` 属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框，单位为像素。\n\n#### window.pageXOffset，window.pageYOffset\n\n`window.pageXOffset` 属性返回页面的水平滚动距离，`window.pageYOffset` 属性返回页面的垂直滚动距离，单位都为像素。\n\n### navigator 对象\n\n#### navigator.userAgent\n\n`navigator.userAgent` 属性返回浏览器的User-Agent字符串，标示浏览器的厂商和版本信息。\n\n用过 `userAgent` 属性识别浏览器不是一个好方法，但是 `userAgent` 可以大致准确地识别手机浏览器\n\n```js\nvar ua = navigator.userAgent.toLowerCase();\n\nif(/mobi/i.test(ua)){\n  //手机浏览器\n}else{\n  //非手机浏览器\n}\n```\n\n#### navigator.plugins\n\n`navigator.plugins` 属性返回一个类似数组的对象，成员是浏览器安装的插件，比如Flash、ActiveX等。\n\n#### navigator.platform\n\n`navigator.platform` 属性返回用户的操作系统信息。\n\n#### navigator.onLine\n\n`navigator.onLine` 属性返回一个布尔值，表示用户当前在线还是离线。\n\n#### navigator.geolocation\n\n`navigator.geolocation` 返回一个Geolocation对象，包含用户地理位置的信息。\n\n#### navigator.javaEnabled()，navigator.cookieEnabled\n\n`javaEnabled` 方法返回一个布尔值，表示浏览器是否能运行Java Applet小程序\n\n`cookieEnabled` 属性返回一个布尔值，表示浏览器是否能储存Cookie。\n\n### window.screen 对象\n\n`window.screen` 对象包含了显示设备的信息。\n\n### window对象的方法\n\n#### window.moveTo()，window.moveBy()\n\n`window.moveTo` 方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。\n\n`window.moveBy` 方法将窗口移动到一个相对位置。它接受两个参数，分布是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。\n\n#### window.scrollTo()，window.scrollBy()\n\n`window.scrollTo` 方法用于将网页的指定位置，滚动到浏览器左上角。它的参数是相对于整张网页的横坐标和纵坐标。它有一个别名 `window.scroll` 。\n\n`window.scrollBy` 方法用于将网页移动指定距离，单位为像素。它接受两个参数：向右滚动的像素，向下滚动的像素。\n\n#### window.open(), window.close()\n\n`window.open` 方法用于新建另一个浏览器窗口，并且返回该窗口对象。\n\n`window.close` 方法用于关闭当前窗口，一般用来关闭window.open方法新建的窗口。\n\n#### window.print()\n\n`print` 方法会跳出打印对话框，同用户点击菜单里面的“打印”命令效果相同。\n\n#### window.getComputedStyle()\n\n`getComputedStyle` 方法接受一个HTML元素作为参数，返回一个包含该HTML元素的最终样式信息的对象\n\n#### window.matchMedia()\n\n`window.matchMedia` 方法用来检查CSS的mediaQuery语句\n\n#### window.focus()\n\n`focus` 方法会激活指定当前窗口，使其获得焦点。\n\n#### window.getSelection()\n\n`window.getSelection` 方法返回一个 `Selection` 对象，表示用户现在选中的文本。\n\n### 多窗口操作\n\n#### 窗口的引用\n\n- top : 顶层窗口，即最上层的那个窗口\n- parent : 父窗口\n- self : 当前窗口，即自身\n\n#### iframe 标签\n\n对于 `iframe` 嵌入的窗口，`document.getElementById` 方法可以拿到该窗口的DOM节点，然后使用 `contentWindow` 属性获得 `iframe` 节点包含的 `window` 对象，或者使用 `contentDocument` 属性获得包含的 `document` 对象。\n\n#### frames 属性\n\n`window` 对象的 `frames` 属性返回一个类似数组的对象，成员是所有子窗口的 `window` 对象\n\n需要注意的是，`window.frames` 每个成员的值，是框架内的窗口（即框架的 `window` 对象），而不是 `iframe` 标签在父窗口的DOM节点。如果要获取每个框架内部的DOM树，需要使用 `window.frames[0].document` 的写法。\n\n另外，如果 `iframe` 元素设置了 `name` 或 `id` 属性，那么属性值会自动成为全局变量，并且可以通过 `window.frames` 属性引用，返回子窗口的 `window` 对象。\n\n### 事件\n\n#### load 事件和onload 属性\n\n`load` 事件发生在文档在浏览器窗口加载完毕时。`window.onload` 属性可以指定这个事件的回调函数。\n\n#### error 事件和 onerror 属性\n\n浏览器脚本发生错误时，会触发 `window` 对象的 `error` 事件。我们可以通过 `window.onerror` 属性对该事件指定回调函数。\n\n由于历史原因，`window `的 `error` 事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。\n\n- 出错信息\n- 出错脚本的网址\n- 行号\n- 列号\n- 错误对象\n\n老浏览器只支持前三个参数\n\n### URL的编码/解码方法\n\n#### encodeURI\n\n`encodeURI` 方法的参数是一个字符串，代表整个URL。它会将元字符和语义字符之外的字符，都进行转义。\n\n#### encodeURIComponent\n\n`encodeURIComponent` 只转除了语义字符之外的字符，**元字符也会被转义**。因此，它的参数通常是URL的路径或参数值，而不是整个URL。\n\n#### decodeURI\n\n`decodeURI` 用于还原转义后的URL。它是 `encodeURI` 方法的逆运算。\n\n#### decodeURIComponent\n\n`decodeURIComponent` 用于还原转义后的URL片段。它是 `encodeURIComponent` 方法的逆运算。\n\n#### alert()，prompt()，confirm()\n\n`alert` 方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。\n\n`prompt` 方法弹出的对话框，在提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。\n\n`confirm` 方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户的意见。\n\n## history 对象\n\n### 概述\n\n浏览器窗口有一个 `history` 对象，用来保存浏览历史\n\n`history` 对象提供了一系列方法，允许在浏览器历史之间移动\n\n- `back` : 移动到上一个访问页面，等同于浏览器的后退键\n- `forward` : 移动到下一个访问页面，等同于浏览器的前进键\n- `go` : 接受一个整数作为参数，移动到该整数指定的页面，`go(0)` 相当于刷新页面\n\n### history.pushState()\n\n接受三个参数\n\n- `state` ：一个与指定网址相关的状态对象，`popstate` 事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填 `null` 。\n- `title` ：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填 `null`。\n- `url` ：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。\n\n```js\nvar stateObj = { foo: 'bar' };\nhistory.pushState(stateObj, 'page 2', '2.html');\n```\n\n添加上面这个新记录后，浏览器地址栏立刻显示 `example.com/2.html`，但并不会跳转到`2.html`，甚至也不会检查 `2.html` 是否存在，它只是成为浏览历史中的最新记录。这时，你在地址栏输入一个新的地址(比如访问 `google.com` )，然后点击了倒退按钮，页面的 `URL` 将显示 `2.html`；你再点击一次倒退按钮，URL 将显示 `1.html`。\n\n总之，`pushState`方法不会触发页面刷新，只是导致`history`对象发生变化，地址栏会有反应。\n\n如果 `pushState的url` 参数，设置了一个新的锚点值（即hash），并不会触发 `hashchange` 事件。如果设置了一个跨域网址，则会报错。\n\n### history.replaceState()\n\n`history.replaceState` 方法的参数与 `pushState` 方法一模一样，区别是它修改浏览历史中当前记录。\n\n### history.state属性\n\n`history.state` 属性返回当前页面的 `state` 对象。\n\n### popstate 事件\n\n每当同一个文档的浏览历史（即 `history` 对象）出现变化时，就会触发 `popstate` 事件。\n\n需要注意的是，仅仅调用 `pushState` 方法或 `replaceState` 方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 `back`、`forward`、`go` 方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。\n\n可以用 `onpushState` 接受回调函数，它接受一个 `event` 的回调参数，通过 `pushState` 和 `replaceState` 方法传递的第一个参数。也可以通过 `history.state` 对象获取。\n\n注意，页面第一次加载的时候不会触发 `popstate` 事件\n\n### URLSearchParams API\n\nURLSearchParams API用于处理URL之中的查询字符串，即问号之后的部分\n\n- `has()` ：返回一个布尔值，表示是否具有某个参数\n- `get()` ：返回指定参数的第一个值\n- `getAll()` ：返回一个数组，成员是指定参数的所有值\n- `set()` ：设置指定参数\n- `delete()` ：删除指定参数\n- `append()` ：在查询字符串之中，追加一个键值对\n- `toString()` ：返回整个查询字符串\n\n```js\nvar paramsString = 'q=URLUtils.searchParams&topic=api';\nvar searchParams = new URLSearchParams(paramsString);\n\nsearchParams.has('topic') // true\n```\n\n- `keys()` ：遍历所有参数名\n- `values()` ：遍历所有参数值\n- `entries()` ：遍历所有参数的键值对\n\nDOM的 `a` 元素节点的 `searchParams` 属性，就是一个 `URLSearchParams` 实例。\n\n```js\nvar a = document.createElement('a');\na.href = 'https://example.com?filter=api';\na.searchParams.get('filter') // \"api\"\n```\n\n`URLSearchParams `还可以与 `URL` 接口结合使用。\n\n```js\nvar url = new URL(location);\nvar foo = url.searchParams.get('foo') || 'somedefault';\n```\n\n## Cookie\n\n### 概述\n\nCookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。\n\nCookie 保存以下几方面的信息\n\n- Cookie 的名字\n- Cookie 的值\n- 到期时间\n- 所属域名\n- 生效的路径\n\n浏览器可以设置不接受 Cookie，也可以设置不向服务器发送 Cookie\n\n`window.navigation.cookieEnabled` 属性返回一个布尔值，表示浏览器是否打开 Cookie 功能\n\n`document.cookie` 返回所有 Cookie，`document.cookie` 一次只能写入一个 Cookie\n\n### Cookie 的属性\n\n服务器向浏览器发送 Cookie 的时候，除了 Cookie 本身的内容，还有一些可选的属性也是可以写入的，它们都必须以分号开头。\n\n（1）value 属性\n\n`value` 属性是必需的，它是一个键值对，用于指定Cookie的值。\n\n（2）expires 属性\n\n`expires` 属性用于指定 Cookie 过期时间。它的格式采用 `Date.toUTCString()` 的格式。\n\n如果不设置该属性，或者设为`null`，Cookie只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。\n\n浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。\n\n（3）domain属性\n\n`domain` 属性指定 Cookie 所在的域名，比如 `example.com` 或 `.example.com` （这种写法将对所有子域名生效）、`subdomain.example.com` 。\n\n如果未指定，默认为设定该Cookie的域名。所指定的域名必须是当前发送Cookie的域名的一部分，比如当前访问的域名是 `example.com` ，就不能将其设为 `google.com` 。只有访问的域名匹配 `domain` 属性，Cookie 才会发送到服务器。\n\n（4）path 属性\n\n`path` 属性用来指定路径，必须是绝对路径（比如/、/mydir），如果未指定，默认为请求该 Cookie 的网页路径。\n\n只有path属性匹配向服务器发送的路径，Cookie 才会发送。这里的匹配不是绝对匹配，而是从根路径开始，只要 `path` 属性匹配发送路径的一部分，就可以发送。比如，path属性等于 `/blog`，则发送路径是 `/blog` 或者 `/blog/roll` ，Cookie都会发送。path属性生效的前提是domain属性匹配。\n\n（5）secure 属性\n\nsecure属性用来指定Cookie只能在加密协议HTTPS下发送到服务器。\n\n该属性只是一个开关，不需要指定值。如果通信是HTTPS协议，该开关自动打开。\n\n（6）max-age\n\n`max-age` 属性用来指定Cookie有效期，比如 `60 * 60 * 24 * 365`（即一年31536e3秒）。\n\n（7）HttpOnly\n\n`HttpOnly` 属性用于设置该Cookie不能被JavaScript读取，详见下文的说明。\n\n以上属性可以同时设置一个或多个，也没有次序的要求。如果服务器想改变一个早先设置的Cookie，必须同时满足四个条件：Cookie的 `key`、`domain`、`path` 和 `secure` 都匹配。也就是说，如果原始的Cookie是用如下的 `Set-Cookie` 设置的。\n\n### Cookie 的限制\n\n浏览器对 Cookie 数量的限制，规定不一样。目前，Firefox 是每个域名最多设置50个 Cookie，而 Safari 和 Chrome 没有域名数量的限制。\n\n所有 Cookie 的累加长度限制为4KB。超过这个长度的 Cookie，将被忽略，不会被设置。\n\n由于 Cookie 可能存在数量限制，有时为了规避限制，可以将 Cookie 设置成下面的形式。\n\n```\nname=a=b&c=d&e=f&g=h\n```\n\n上面代码实际上是设置了一个 Cookie，但是这个 Cookie 内部使用&符号，设置了多部分的内容。因此，读取这个 Cookie 的时候，就要自行解析，得到多个键值对。这样就规避了 Cookie 的数量限制。\n\n### 同源政策\n\n浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie。\n\n### Http-Only Cookie\n\n设置 Cookie 的时候，如果服务器加上了 `HttpOnly` 属性，则这个 Cookie 无法被 JavaScript 读取（即 `document.cookie` 不会返回这个Cookie的值），只用于向服务器发送\n\n## Web Storage 「 浏览器端数据储存机制 」\n\n### 概述\n\n`sessionStorage` 保存的数据用于浏览器的一次会话，当会话结束（通常是该窗口关闭），数据被清空；`localStorage` 保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的属性和方法完全一样。\n\n### 操作方法\n\n#### 存入/读取数据\n\n```js\nsessionStorage.setItem(\"key\",\"value\")\nlocalStorage.setItem(\"key\",\"value\")\n```\n\n```js\nvar valueSession = sessionStorage.getItem(\"key\")\nvar valueLocal = localStorage.getItem(\"key\")\n```\n\n#### 清除数据\n\n`removeItem('key')` 方法用于清除对应键名的值\n\n`clear` 方法用于清除所有保存的数据\n\n#### 遍历操作\n\n```js\nfor(var i = 0;i < localStorage.length ;i++){\n  console.log(localSotrage.key(i));\n}\n```\n\n### storage 事件\n\n当储存的数据发生变化的时候，会触发 storage 事件\n\n```js\nwindow.addEventListener(\"storage\",callback);\n```\n\n回调函数接受一个 event 对象作为参数，这个 event 对象的 `key` 属性，保存发生变化的键名\n\n除了 `key` 属性外， event 属性还有三个\n\n- `oldValue` ：更新前的值。如果该键为新增加，则这个属性为 `null`。\n- `newValue` ：更新后的值。如果该键被删除，则这个属性为 `null`。\n- `url` ：原始触发 `storage` 事件的那个网页的网址。\n\n值得特别注意的是，**该事件不在导致数据变化的当前页面触发**。如果浏览器同时打开一个域名下面的多个页面，当其中的一个页面改变 `sessionStorage` 或 `localStorage` 的数据时，其他所有页面的 `storage` 事件会被触发，而原始页面并不触发 `storage` 事件。可以通过这种机制，实现多个窗口之间的通信。所有浏览器之中，只有IE浏览器除外，它会在所有页面触发 `storage` 事件。\n\n## 同源政策\n\n### 概述\n\n#### 含义\n\n1995 年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策\n\n最初，它的函数是指，A网页设置的Cookie，B网页不能打开，除非这两个网页「同源」\n\n- 协议形同\n- 域名相同\n- 端口相同\n\n#### 目的\n\n为了保证用户的安全，A 网站的 Cookie 没有同源政策就可以 被其它浏览的网站窃取。\n\n#### 限制范围\n\n- Cookie、LocalStorage 和 IndexedDB 无法读取。\n- DOM 无法获得。\n- AJAX 请求无效（可以发送，但浏览器会拒绝接受响应）。\n\n### Cookie\n\n当两个网页的一级域名相同，只是二级域名不同时，浏览器允许通过设置 `document.domain` 共享 Cookie\n\n举例来说，A网页是 `http://w1.example.com/a.html` ，B网页是 `http://w2.example.com/b.html` ，那么只要设置相同的 `document.domain` ，两个网页就可以共享Cookie。\n\n### iframe\n\n关于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题\n\n#### 片段识别符\n\n片段标识符指的是 URL 的 `#` 号后面的部分。如果只是改变片段标识符，页面不会重新刷新\n\n父窗口可以把信息，写入子窗口的片段标识符\n\n```js\nvar src = originURL + '#' + data;\ndocument.getElementById('myIFrame').src = src;\n```\n\n子窗口通过 `hashchange` 事件得到通知\n\n```js\nwindow.onhashchange = checkMessage;\n\nfunction checkMessage() {\n  var message = window.location.hash;\n  // ...\n}r\n```\n\n同样的，子窗口也可以改变父窗口的片段标识符。\n\n```js\nparent.location.href= target + '#' + hash;\n```\n\n#### window.postMessage\n\n接受两个参数，第一个参数是发送的数据，第二个参数是接受消息的窗口的源，即\"协议+域名+端口\"\n\n```js\nwindow.postMessage(\"hellp\",\"http://example.com:80\");\n```\n\n接受信息\n\n```js\nwindow.addEventListener(\"message\",function(e){\n  e.data//数据\n})\n```\n\n`message` 事件的对象 `event` 提供三个属性\n\n- `event.source` 发送消息的窗口\n- `event.origin` 消息发向的网址\n- `event.data` 消息内容\n\n### AJAX\n\n同源政策规定，AJAX请求只能发给同源的网址，否则就报错。\n\n除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。\n\n#### JSONP\n\n基本思想是，网页通过添加一个 `<script>` 元素，向服务器请求JSON数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定的回调函数里传回来\n\n首先网页动态插入 `<script>` 元素，由它向跨源网址发出请求\n\n```js\nfunction addScriptTag(src) {\n  var script = document.createElement('script');\n  script.setAttribute(\"type\",\"text/javascript\");\n  script.src = src;\n  document.body.appendChild(script);\n}\n\nwindow.onload = function () {\n  addScriptTag('http://example.com/ip?callback=foo');\n}\n\nfunction foo(data) {\n  console.log('Your public IP address is: ' + data.ip);\n};\n```\n\n服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。\n\n```js\nfoo({\n  \"ip\": \"8.8.8.8\"\n});\n```\n\n#### WebSocket\n\nWebSocket是一种通信协议，使用 `ws://`（非加密）和 `wss://`（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。\n\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\nOrigin: http://example.com\n```\n\n上面代码中，有一个字段是 `Origin`，表示该请求的请求源（origin），即发自哪个域名。\n\n正是因为有了 `Origin` 这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。\n\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat\n```\n\n#### CORS\n\nCORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比 `JSONP` 只能发 `GET` 请求，CORS允许任何类型的请求。\n\n## CORS 通信\n\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\n\n### 两种请求\n\n简单请求（simple request）和非简单请求（not-so-simple request）。\n\n只要同时满足以下两大条件，就属于简单请求\n\n请求方法是以下三种之一\n\n- HEAD\n- GET\n- POST\n\nHTTP 的头信息不超出以下几种字段\n\n- Accept\n- Accept-Language\n- Content-Language\n- Last-Event-ID\n- Content-Type: 只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain\n\n\n### 简单请求\n\n#### 基本流程\n\n对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个 `Origin` 字段。\n\n```\nGET /cors HTTP/1.1\nOrigin: http://api.bob.com\nHost: api.alice.com\nAccept-Language: en-US\nConnection: keep-alive\nUser-Agent: Mozilla/5.0...\n```\n\n如果 `Origin` 指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含 `Access-Control-Allow-Origin` 字段，就知道出错了，从而抛出一个错误，被 `XMLHttpRequest` 的 `onerror` 回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是 `200` 。\n\n如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。\n\n```\nAccess-Control-Allow-Origin: http://api.bob.com\nAccess-Control-Allow-Credentials: true\nAccess-Control-Expose-Headers: FooBar\nContent-Type: text/html; charset=utf-8\n```\n\n#### withCredentials 属性\n\n上面说到，CORS请求默认不包含Cookie信息（以及HTTP认证信息等）。如果需要包含Cookie信息，一方面要服务器同意，指定 `Access-Control-Allow-Credentials` 字段。\n\n```\nAccess-Control-Allow-Credentials: true\n```\n\n另一方面，开发者必须在AJAX请求中打开 `withCredentials` 属性。\n\n```js\nvar xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n```\n\n\n","tags":["ES5"],"categories":["Note"]},{"title":"LeanJs「 ES5 」-- DOM 模型","url":"%2F2018%2F01%2F27%2FLeanJSDOM%E6%A8%A1%E5%9E%8B%2F","content":"![Js](LeanJSDOM模型/js.png)\n\n<!--more-->\n\n## DOM模型概述\n\n文档对象模型(Document Object Model)\n\n### 节点\n\nDOM 的最小组成单位叫做节点，节点的类型有 7 种\n\n- `Document` : 整个文档数的顶层节点\n- `DocumentType` : `doctype`标签\n- `Element` : 网页的各种HTML标签\n- `Attribute` : 网页元素的属性\n- `Text` : 标签之间或标签包含的文本\n- `Comment` : 注释\n- `DocumentFragment` : 文档的片段\n\n这七种节点都属于浏览器原生提供的节点对象的派生对象，具有一些共同的属性和方法。\n\n### 特征相关属性\n\n所有节点对象都是浏览器内置 `Node` 对象的实例，继承了 `Node` 属性和方法。\n\n可以用 `console.dir(Node)` 查看方法\n\n#### Node.nodeName Node.nodeType\n\n| 类型 | nodeName |\tnodeType |\n|----|------|------|\n|ELEMENT_NODE|\t大写的HTML元素名|\t1|\n|ATTRIBUTE_NODE| 等同于Attr.name|\t2|\n|TEXT_NODE\t|#text\t|3|\n|COMMENT_NODE\t|#comment|\t8|\n|DOCUMENT_NODE|\t#document|\t9|\n|DOCUMENT_FRAGMENT_NODE|\t#document-fragment|\t11|\n|DOCUMENT_TYPE_NODE\t| 等同于DocumentType.name |10|\n\n#### Node.nodeValue\n\n返回一个字符串，表示当前节点本身的文本值，该属性可读写\n\n因为只有Text节点、Comment节点，XML文档的CDATA节点有文本值，因此只有这三类节点的 `nodeValue` 可以返回结果，其它类型的节点一律返回 `null` ，也无法设置 `nodeValue` 属性\n\n#### Node.textContent\n\n`Node.textContent` 属性返回当前节点和他所有后代节点的文本内容\n\n```html\n<div id=\"test\">this<span>is</span>some text</div>\n```\n\n```js\ndocument.getElementById('test').textContent\n//this is some text\n```\n\n该属性是可读写的，不过在这里要注意一点，他里面的内容会代替掉该元素其中的任何元素，而且是以文本的形式展示\n\n```js\ndocument.getElementById('test').textContent = '<p>just a test</p>'\n```\n\n这里的`<p></p>`并不会自动识别成 `p` 标签，而是以文本的形式展现在页面上\n\n如果要读取整个文档的内容\n\n```js\ndocument.documentElement.textContent\n```\n\n#### Node.baseURI\n\n返回一个字符串，表示当前网页的绝对路径，如果无法获取，则返回 `null`\n\n不同节点都可以调用这个属性，一般返回的值是相同的\n\n该属性的值一般由当前网址的URL决定，但是可以用HTML的 `<base>` 标签改变该属性的值\n\n```js\n<base href=\"http://www.example.com/page.html\">\n```\n\n设置 `<base>` 以后，`baseURI` 属性就返回 `<base>` 标签设置的值\n\n\n#### Node.firstChild Node.lastChild\n\n`firstChild` 属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回 `null`\n\n```html\n<p id=\"para-01\">\n  <span>First span</span>\n</p>\n\n<script type=\"text/javascript\">\n  console.log(\n    document.getElementById('para-01').firstChild.nodeName\n  ) // \"#text\"\n</script>\n```\n\n上面代码中，p元素与span元素之间有空白字符，这导致firstChild返回的是文本节点。\n\n### 节点对象的方法\n\n#### Node.appendChild()\n\n`Node.appendChild` 方法接受一个节点对象作为参数，将其作为最后一个子节点，插入当前节点\n\n#### Node.hasChildNodes()\n\n`Node.hasChildNodes` 方法返回一个布尔值，表示当前节点是否有子节点。\n\n#### Node.cloneNode()\n\n`Node.cloneNode` 方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点，默认是 `false` ，即不克隆子节点。\n\n此克隆方法不会克隆绑定事件，并且如果被克隆的对象有 `id` 值的话，需要修改掉其中的一个\n\n#### Node.insertBefore()\n\n`insertBefore` 方法用于将某个节点插入当前节点内部的指定位置。它接受两个参数，第一个参数是所要插入的节点，第二个参数是当前节点内部的一个子节点，新的节点将插在这个子节点的前面。该方法返回被插入的新节点。\n\n#### Node.removeChild()\n\n`Node.removeChild` 方法接受一个子节点作为参数，用于从当前节点移除该子节点。它返回被移除的子节点。\n\n#### Node.replaceChild()\n\n`Node.replaceChild` 方法用于将一个新的节点，替换当前节点的某一个子节点。它接受两个参数，第一个参数是用来替换的新节点，第二个参数将要被替换走的子节点。它返回被替换走的那个节点。\n\n#### Node.contains()\n\n`Node.contains` 方法接受一个节点作为参数，返回一个布尔值，表示参数节点是否为当前节点的后代节点。\n\n#### Node.compareDocumentPosition()\n\n`compareDocumentPosition` 方法的用法，与 `contains` 方法完全一致，返回一个7个比特位的二进制值，表示参数节点与当前节点的关系。\n\n#### Node.isEqualNode()\n\n`isEqualNode` 方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。\n\n#### Node.normalize()\n\n`normailize` 方法用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。\n\n\n### 节点的集合对象\n\n#### NodeList 对象\n\n`NodeList` 实例对象是一个类似数组的对象，它的成员是节点对象。节点数的变化会改变对应的 `NodeList` ，因为是类数组，它不能直接调用数组的一些方法。\n\n#### HTMLCollection 对象\n\n`HTMLCollection` 实例对象与 `NodeList` 实例对象类似，也是节点的集合，返回一个类似数组的对象。 `document.links` 、 `docuement.forms` 、 `document.images` 等属性，返回的都是 `HTMLCollection` 实例对象。\n\n`HTMLCollection` 与 `NodeList` 的区别有以下几点。\n\n1. `HTMLCollection` 实例对象的成员只能是 `Element` 节点，`NodeList` 实例对象的成员可以包含其他节点。\n\n2.` HTMLCollection` 实例对象都是动态集合，节点的变化会实时反映在集合中。`NodeList` 实例对象可以是静态集合。\n\n3. `HTMLCollection` 实例对象可以用 `id` 属性或 `name` 属性引用节点元素， `NodeList` 只能使用数字索引引用。\n\n### ParentNode 接口，ChildNode 接口\n\n不同的节点除了继承 `Node` 接口以外，还会继承其他接口。`ParentNode` 接口用于获取当前节点的 `Element` 子节点， `ChildNode` 接口用于处理当前节点的子节点（包含但不限于 `Element` 子节点）。\n\n#### ParentNode接口\n\n`ParentNode` 接口用于获取 `Element` 子节点。`Element` 节点、`Document` 节点和 `DocumentFragment` 节点，部署了 `ParentNode` 接口。凡是这三类节点，都具有以下四个属性，用于获取Element子节点。\n\nchildren\n\n`children` 属性返回一个动态的 `HTMLCollection` 集合，由当前节点的所有 `Element` 子节点组成。\n\n\nfirstElementChild\n\n`firstElementChild` 属性返回当前节点的第一个 `Element` 子节点，如果不存在任何  `Element`子节点，则返回 `null` 。\n\nlastElementChild\n\n`lastElementChild` 属性返回当前节点的最后一个 `Element` 子节点，如果不存在任何 `Element` 子节点，则返回 `null`。\n\nchildElementCount\n\n`childElementCount` 属性返回当前节点的所有 `Element` 子节点的数目。\n\n#### ChildNode 接口\n\n`ChildNode` 接口用于处理子节点（包含但不限于 `Element` 子节点）。`Element` 节点、`DocumentType` 节点和 `CharacterData` 接口，部署了 `ChildNode` 接口。凡是这三类节点（接口），都可以使用下面四个方法。\n\nremove()\n\n`remove` 方法用于移除当前节点。\n\n```js\nel.remove()\n```\n\n上面方法在DOM中移除了 `el` 节点。注意，调用这个方法的节点，是被移除的节点本身，而不是它的父节点。\n\nbefore()\n\n`before` 方法用于在当前节点的前面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。\n\nafter()\n\n`after` 方法用于在当前节点的后面，插入一个同级节点。如果参数是节点对象，插入DOM的就是该节点对象；如果参数是文本，插入DOM的就是参数对应的文本节点。\n\nreplaceWith()\n\n`replaceWith` 方法使用参数指定的节点，替换当前节点。如果参数是节点对象，替换当前节点的就是该节点对象；如果参数是文本，替换当前节点的就是参数对应的文本节点。\n\n## Document 节点\n\n### 内部属性节点\n\n#### document.doctype\n\n`document` 对象的第一个子节点，包含了文档类型，通常 `document.firstChild` 返回这个节点\n\n#### document.documentElement\n\n`document` 对象的第二个子节点，对于HTML网页，返回 `<html>` 节点 \n\n#### document.defaultView \n\n在浏览器中返回 `document` 对象所在的 `window` 对象，否则返回 `null`\n\n#### document.body,document.head\n\ndocument.head属性返回当前文档的 `<head>` 节点，`document.body` 属性返回当前文档的 `<body>`。\n\n#### document.activeElement\n\n`document.activeElement` 属性返回当前文档中获得焦点的那个元素。用户通常可以使用Tab键移动焦点，使用空格键激活焦点。比如，如果焦点在一个链接上，此时按一下空格键，就会跳转到该链接。\n\n### 节点集合属性\n\n#### document.links，document.forms，document.images，document.embeds\n\n`document.links` 属性返回当前文档所有设定了 `href` 属性的 `a` 及 `area` 元素。\n\n`document.forms` 属性返回页面中所有表单元素 `form`。\n\n`document.images` 属性返回页面所有图片元素（即 `img` 标签）。\n\n`document.embeds` 属性返回网页中所有嵌入对象，即 `embed` 标签。\n\n以上四个属性返回的都是 `HTMLCollection` 对象实例\n\n#### document.scripts，document.styleSheets\n\n`document.scripts` 属性返回当前文档的所有脚本（即 `script` 标签）。\n\n`document.scripts`返回的也是 `HTMLCollection` 实例。\n\n`document.styleSheets` 属性返回一个类似数组的对象，代表当前网页的所有样式表。每个样式表对象都有 `cssRules` 属性，返回该样式表的所有CSS规则，这样这可以操作具体的CSS规则了。\n\n### 文档信息属性\n\n#### document.documentURI，document.URL\n\n`document.documentURI` 属性和 `document.URL` 属性都返回一个字符串，表示当前文档的网址。不同之处是 `documentURI` 属性可用于所有文档（包括 XML 文档），`URL` 属性只能用于 `HTML` 文档。\n\n#### document.domain\n\n`document.domain` 属性返回当前文档的域名。比如，某张网页的网址是 http://www.example.com/hello.html ，`domain` 属性就等于 `www.example.com`。如果无法获取域名，该属性返回 `null`。\n\n#### document.lastModified\n\n`document.lastModified` 属性返回当前文档最后修改的时间戳，格式为字符串。\n\n注意，`lastModified` 属性的值是字符串，所以不能用来直接比较，两个文档谁的日期更新，需要用 `Date.parse` 方法转成时间戳格式，才能进行比较。\n\n#### document.location\n\n属性\n\n```js\n// 当前网址为 http://user:passwd@www.example.com:4097/path/a.html?x=111#part1\ndocument.location.href // \"http://user:passwd@www.example.com:4097/path/a.html?x=111#part1\"\ndocument.location.protocol // \"http:\"\ndocument.location.host // \"www.example.com:4097\"\ndocument.location.hostname // \"www.example.com\"\ndocument.location.port // \"4097\"\ndocument.location.pathname // \"/path/a.html\"\ndocument.location.search // \"?x=111\"\ndocument.location.hash // \"#part1\"\ndocument.location.user // \"user\"\ndocument.location.password // \"passwd\"\n```\n\n方法\n\n```js\n// 跳转到另一个网址\ndocument.location.assign('http://www.google.com')\n// 优先从服务器重新加载\ndocument.location.reload(true)\n// 优先从本地缓存重新加载（默认值）\ndocument.location.reload(false)\n// 跳转到新网址，并将取代掉history对象中的当前记录\ndocument.location.replace('http://www.google.com');\n// 将location对象转为字符串，等价于document.location.href\ndocument.location.toString()\n```\n\n#### document.referrer，document.title，document.characterSet\n\n`document.referrer` 属性返回一个字符串，表示当前文档的访问来源，如果是无法获取来源或是用户直接键入网址，而不是从其他网页点击，则返回一个空字符串。\n\n`document.referrer` 的值，总是与HTTP头信息的 `Referer` 保持一致，但是它的拼写有两个 `r` 。\n\n`document.title` 属性返回当前文档的标题，该属性是可写的。\n\n#### document.readyState\n\n`document.readyState` 属性返回当前文档的状态，共有三种可能的值。\n\n- `loading`：加载HTML代码阶段（尚未完成解析）\n- `interactive`：加载外部资源阶段时\n- `complete`：加载完成时\n\n#### document.designMode\n\n`document.designMode` 属性控制当前文档是否可编辑，通常用在制作所见即所得编辑器。打开 `iframe` 元素包含的文档的 `designMode` 属性，就能将其变为一个所见即所得的编辑器。\n\n#### document.implementation\n\n`document.implementation` 属性返回一个对象，用来甄别当前环境部署了哪些DOM相关接口。`implementation` 属性的 `hasFeature` 方法，可以判断当前环境是否部署了特定版本的特定接口。\n\n#### document.compatMode\n\n`compatMode`属性返回浏览器处理文档的模式，可能的值为`BackCompat`（向后兼容模式）和`CSS1Compat`（严格模式）。\n\n一般来说，如果网页代码的第一行设置了明确的`DOCTYPE`（比如`<!doctype html>`），`document.compatMode`的值都为`CSS1Compat`。\n\n#### document.cookie\n\n操作浏览器的Cookie\n\n### 读写相关的方法\n\n#### document.write()，document.writeln()\n\n如果页面已经解析完成（`DOMContentLoaded`事件发生之后），再调用`write`方法，它会先调用`open`方法，擦除当前文档所有内容，然后再写入。\n\n```js\ndocument.addEventListener('DOMContentLoaded', function (event) {\n  document.write('<p>Hello World!</p>');\n});\n\n// 等同于\n\ndocument.addEventListener('DOMContentLoaded', function (event) {\n  document.open();\n  document.write('<p>Hello World!</p>');\n  document.close();\n});\n```\n\n`document.writeln` 方法与 `write` 方法完全一致，除了会在输出内容的尾部添加换行符。\n\n### 查找节点的方法\n\n#### document.querySelector()，document.querySelectorAll()\n\n`document.querySelector` 方法接受一个CSS选择器作为参数，返回匹配该选择器的元素节点。如果有多个节点满足匹配条件，则返回第一个匹配的节点。如果没有发现匹配的节点，则返回 `null`。\n\n`document.querySelectorAll` 方法与 `querySelector` 用法类似，区别是返回一个 `NodeList` 对象，包含所有匹配给定选择器的节点。\n\n支持复杂的CSS选择器，但是不支持伪元素的选择器\n\n#### document.getElementsByTagName()\n\n`document.getElementsByTagName` 方法返回所有指定HTML标签的元素，返回值是一个类似数组的 `HTMLCollection` 对象，可以实时反映HTML文档的变化。如果没有任何匹配的元素，就返回一个空集。\n\n#### document.getElementsByClassName()\n\n`document.getElementsByClassName` 方法返回一个类似数组的对象（HTMLCollection实例对象），包括了所有 `class` 名字符合指定条件的元素，元素的变化实时反映在返回结果中。\n\n#### document.getElementsByName()\n\n`document.getElementsByName` 方法用于选择拥有 `name` 属性的HTML元素（比如`<form>`、`<radio>`、`<img>`、`<frame>`、`<embed>`和`<object>`等），返回一个类似数组的的对象（`NodeList`对象的实例），因为`name`属性相同的元素可能不止一个。\n\n#### getElementById()\n\n`getElementById` 方法返回匹配指定 `id` 属性的元素节点。如果没有发现匹配的节点，则返回 `null`。\n\n#### document.elementFromPoint()\n\n`document.elementFromPoint` 方法返回位于页面指定位置最上层的 `Element` 子节点。\n\n```js\nvar element = document.elementFromPoint(50, 50);\n```\n\n上面代码选中在 `(50, 50)` 这个坐标位置的最上层的那个HTML元素。\n\n\n`elementFromPoint` 方法的两个参数，依次是相对于当前视口左上角的横坐标和纵坐标，单位是像素。如果位于该位置的HTML元素不可返回（比如文本框的滚动条），则返回它的父元素（比如文本框）。如果坐标值无意义（比如负值或超过视口大小），则返回 `null`。\n\n### 生成节点的方法\n\n#### document.createElement()\n\n`document.createElement` 方法用来生成网页元素节点。\n\n#### document.createTextNode()\n\n`document.createTextNode` 方法用来生成文本节点，参数为所要生成的文本节点的内容。\n\n这个方法可以确保返回的节点，被浏览器当作文本渲染，而不是当作 HTML 代码渲染。因此，可以用来展示用户的输入，避免 XSS 攻击。\n\n```js\nvar div = document.createElement('div');\ndiv.appendChild(document.createTextNode('<span>Foo & bar</span>'));\nconsole.log(div.innerHTML)\n// &lt;span&gt;Foo &amp; bar&lt;/span&gt;\n```\n\n上面代码中，`createTextNode` 方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。\n\n`createTextNode` 方法不转义双引号\n\n#### document.createAttribute()\n\n`document.createAttribute` 方法生成一个新的属性对象节点，并返回它。\n\n参数是这个属性的名称\n\n#### document.createDocumentFragment()\n\n`createDocumentFragment` 方法生成一个DocumentFragment对象。\n\n`DocumentFragment `对象是一个存在于内存的DOM片段，但是不属于当前文档，常常用来生成较复杂的DOM结构，然后插入当前文档。这样做的好处在于，因为**`DocumentFragment` 不属于当前文档，对它的任何改动，都不会引发网页的重新渲染，比直接修改当前文档的DOM有更好的性能表现**。\n\n### 事件相关的方法\n\n#### document.createEvent()\n\n`document.createEvent` 方法生成一个事件对象，该对象可以被 `element.dispatchEvent` 方法使用，触发指定事件。\n\n#### document.addEventListener()，document.removeEventListener()，document.dispatchEvent()\n\n```js\n// 添加事件监听函数\ndocument.addEventListener('click', listener, false);\n\n// 移除事件监听函数\ndocument.removeEventListener('click', listener, false);\n\n// 触发事件\nvar event = new Event('click');\ndocument.dispatchEvent(event);\n```\n\n### 其他方法\n\n#### document.hasFocus()\n\n`document.hasFocus` 方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。\n\n#### document.createNodeIterator()，document.createTreeWalker()\n\n`document.createNodeIterator` 方法返回一个DOM的子节点遍历器。\n\n`document.createTreeWalker` 方法返回一个DOM的子树遍历器。它与`createNodeIterator` 方法的区别在于，后者只遍历子节点，而它遍历整个子树。\n\n#### document.adoptNode()\n\n`document.adoptNode` 方法将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。\n\n#### document.importNode()\n\n`document.importNode` 方法从外部文档拷贝指定节点，插入当前文档。\n\n## Element 节点\n\n### 特征相关的属性\n\n#### Element.attributes\n\n`Element.attributes` 属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点\n\n#### Element.id，Element.tagName\n\n`Element.id` 属性返回指定元素的 `id` 属性，该属性可读写\n\n`Element.tagName` 属性返回指定元素的大写标签名，与 `nodeName` 属性的值相等。\n\n#### Element.innerHTML\n\n`Element.innerHTML `属性返回该元素包含的 HTML 代码。该属性可读写，常用来设置某个节点的内容。\n\n**注意**\n\n如果文本节点中包含&、小于号和大于号，`innerHTML` 属性会将它们转为实体形式 `&amp;` 、 `&lt;` 、 `&gt;`。\n\n如果文本中含有 `<script>` 标签，虽然可以生成 `script` 节点，但是插入的代码不会执行，但是 `innerHTML` 还是有安全风险\n\n```js\nvar name = \"<img src=x onerror=alert(1)>\";\nel.innerHTML = name;\n```\n\n上面代码中 `alert` 还是会执行的，因此为了安全考虑，如果插入的是文本，最好用 `textContent` 属性代替 `innerHTML`\n\n#### Element.outerHTML\n\n`Element.outerHTML` 属性返回一个字符串，内容为指定元素节点的所有 HTML 代码，包括它自身和包含的所有子元素。\n\n`outerHTML` 属性是可读写的，对它进行赋值，等于替换掉当前元素。\n\n```js\n// HTML代码如下\n// <div id=\"container\"><div id=\"d\">Hello</div></div>\n\ncontainer = document.getElementById('container');\nd = document.getElementById(\"d\");\ncontainer.firstChild.nodeName // \"DIV\"\nd.nodeName // \"DIV\"\n\nd.outerHTML = '<p>Hello</p>';\ncontainer.firstChild.nodeName // \"P\"\nd.nodeName // \"DIV\"\n```\n\n上面代码中，`outerHTML` 属性重新赋值以后，内层的 `div` 元素就不存在了，被 `p` 元素替换了。但是，变量 `d` 依然指向原来的 `div` 元素，这表示被替换的 `DIV` 元素还存在于内存中。\n\n#### Element.className , Element.classList\n\n```html\n<div class=\"one two three\" id=\"myDiv\"></div>\n```\n\n上面代码的 `className` 属性和 `classList` 属性如下\n\n```js\ndocument.getElementById('myDiv').className\n//'one two three'\n\ndocument.getElementById('myDiv').classList\n// {\n//   0: \"one\"\n//   1: \"two\"\n//   2: \"three\"\n//   length: 3\n// }\n```\n\nclassList 对象有下列几种方法\n\n- `add()` : 增加一个class\n- `remove()` : 移除一个class\n- `contains()` : 检查当前元素是否包含某个class\n- `toggle()` : 将某个class移入或移出元素（如果存在就移除，不存在就添加）\n- `item()` : 返回指定索引位置的class\n- `toString()` : 将class的列表转为字符串\n\n### 盒装模型相关属性\n\n#### Element.clientHeight,Element.clientWidth\n\n返回元素节点可见部分的高度，不包括溢出(overflow)的大小\n\n这两个属性的值等元素的css高度（宽度）加上css的padding减去滚动条（如果存在滚动条），单位为像素。\n\n#### Element.clientLeft,Element.clientTop\n\n`Element.clientLeft` 属性等于元素节点左边框的宽度，`Element.clientTop` 属性等于元素节点顶部边框的宽度，单位为像素\n\n如果元素设置了 `display:inline` 它的 `clientLeft` 属性一律为 `0`\n\n#### Element.scrollLeft,Element.scrollTop\n\n`Element.scrollLeft`属性表示网页元素的水平滚动条向右侧滚动的像素，`Element.scrollTop`属性表示网页元素的垂直滚动条向下滚动的像素数量，对于没有滚动条的网页元素，这两个属性总是等于0\n\n如果要查看整张网页的水平的垂直的滚动距离，要从`document.documentElement` 元素上读取\n\n#### Element.scrollWidth,Element.scrollHeight\n\n`Element.scrollHeight` 属性返回某个网页元素的总高度，`Element.scrollWidth` 属性返回总宽度，可以理解成元素在垂直和水平两个方向上可以滚动的距离。它们都包括由于溢出容器而无法显示在网页上的那部分高度或宽度。这两个属性是只读属性。\n\n如果内容正好适合它的容器，没有溢出，那么 `Element.scrollHeight` 和 `Element.clientHeight` 是相等的，如果存在溢出，那么 `scrollHeight` 属性大于`clientHeight` 属性，宽度也是同样。\n\n当存在溢出的时候，滚动条滚动到内容底部时，下列表达式为  `true` \n\n```js\nelement.scrollHeight - element.scrollTop === element.clientHeight \n```\n\n#### Element.offsetHeight , Element.offsetWidth\n\n`Element.offsetHeight` 属性返回元素的垂直高度，`Element.offsetWidth` 属性返回水平宽度。`offsetHeight` 可以理解成元素左下角距离左上角的位移，`offsetWidth` 是元素右上角距离左上角的位移。它们的单位为像素，都是只读。\n\n这两个属性值包括 `Padding` 和 `Border` 、以及滚动条。这也意味着，如果不存在内容溢出，`Element.offsetHeight` 只比 `Element.clientHeight` 多了边框的高度。\n\n#### Element.offsetLeft，Element.offsetTop\n\n`Element.offsetLeft` 返回当前元素左上角相对于 `Element.offsetParent` 节点的水平位移，`Element.offsetTop` 返回垂直位移，单位为像素。通常，这两个值是指相对于父节点的位移。\n\n\n### 相关节点的属性\n\n#### Element.children，Element.childElementCount\n\n`Element.children` 属性返回一个 `HTMLCollection` 对象，包括当前元素节点的所有子元素\n\n这个属性与 `Node.childNodes` 属性的区别是，它只包括HTML元素类型的子节点，不包括其他类型的子节点。\n\n`Element.childElementCount` 属性返回当前元素节点包含的子HTML元素节点的个数，与`Element.children.length` 的值相同。注意，该属性只计算HTML元素类型的子节点。\n\n#### Element.firstElementChild，Element.lastElementChild\n\n`Element.firstElementChild` 属性返回第一个HTML元素类型的子节点，`Element.lastElementChild` 返回最后一个HTML元素类型的子节点\n\n#### Element.nextElementSibling，Element.previousElementSibling\n\n`Element.nextElementSibling` 属性返回当前HTML元素节点的后一个同级HTML元素节点\n\n`Element.previousElementSibling` 属性返回当前HTML元素节点的前一个同级HTML元素节点\n\n\n#### Element.offsetParent\n\n`Element.offsetParent` 属性返回当前 HTML 元素的最靠近的、并且 CSS 的 `position` 属性不等于 `static` 的上层元素\n\n如果该元素是不可见的（`display`属性为`none`），或者位置是固定的（`position`属性为`fixed`），则`offsetParent`属性返回`null`。\n\n### 属性相关的方法\n\n- `Element.getAttribute()`：读取指定属性\n- `Element.setAttribute()`：设置指定属性\n- `Element.hasAttribute()`：返回一个布尔值，表示当前元素节点是否有指定的属性\n- `Element.removeAttribute()`：移除指定属性\n\n### 查找相关方法\n\n- `Element.querySelector()`\n- `Element.querySelectorAll()`\n- `Element.getElementsByTagName()`\n- `Element.getElementsByClassName()`\n\n### 事件相关的方法\n\n- `Element.addEventListener()` ：添加事件的回调函数\n- `Element.removeEventListener()` ：移除事件监听函数\n- `Element.dispatchEvent()` ：触发事件\n\n### 其他方法\n\n#### Element.scrollIntoView()\n\n`Element.scrollIntoView` 方法滚动当前元素，进入浏览器的可见区域，类似于设置`window.location.hash` 的效果。\n\n#### Element.getBoundingClientRect()\n\n`Element.getBoundingClientRect` 方法返回一个对象，该对象提供当前元素节点的大小、位置等信息，基本上就是CSS盒状模型提供的所有信息。\n\n#### Element.getClientRects()\n\n`Element.getClientRects` 方法返回一个类似数组的对象，里面是当前元素在页面上形成的所有矩形。每个矩形都有 `bottom` 、 `height` 、 `left` 、 `right` 、 `top` 和 `width` 六个属性，表示它们相对于视口的四个坐标，以及本身的高度和宽度。\n\n#### Element.insertAdjacentHTML()\n\n`Element.insertAdjacentHTML` 方法解析HTML字符串，然后将生成的节点插入DOM树的指定位置。\n\n#### Element.remove()\n\n`Element.remove` 方法用于将当前元素节点从DOM树删除。\n\n#### Element.focus()\n\n`Element.focus` 方法用于将当前页面的焦点，转移到指定元素上。\n\n## 属性的操作\n\n### Element.attributes 属性\n\n返回一个类似数组的动态对象，成员是该元素标签的所有属性节点对象，属性的实时变化都会反映在这个节点对象上，其他类型的节点对象，虽然也有 `attribute` 属性，但是返回的都是 `null`\n\n属性节点对象有 `name` 和 `value` 属性，对应该属性的属性名和属性值。等同于 `nodeName` 属性和 `nodeValue` 属性\n\n### 元素节点对象的属性\n\n```js\nimg.src\na.href\n```\n\n这种写法虽然可以读写 HTML 属性，但是无法删除属性， `delete` 运算符在这里不会生效\n\nHTML 元素的属性名是大小写不敏感的，但是 JavaScript 对象的属性名是大小写敏感的。转为 JavaScript 属性名时，一律采用小写，如果属性名包括多个单词，采用驼峰拼写法\n\n有些 HTML 属性名是 JavaScript 的保留字，转为 JavaScript 属性时，必须改名\n\n- `for` 属性改为 `htmlFor`\n- `class` 属性改为 `className`\n\n\n### 属性操作的标准方法\n\n#### getAttribute()\n\n返回当前元素节点的指定属性，只返回字符串，HTML 标签对象的属性会返回各种类型的值。\n\n#### setAttribute()\n\n`Element.setAttribute` 方法用于为当前元素节点新增属性。如果同名属性已存在，则相当于编辑已存在的属性。\n\n\n#### hasAttribute()\n\n`Element.hasAttribute` 方法返回一个布尔值，表示当前元素节点是否包含指定属性。\n\n#### removeAttribute()\n\n`Element.removeAttribute` 方法用于从当前元素节点移除属性。\n\n### dataset 属性\n\n```html\n<div id=\"mydiv\" data-foo=\"bar\">\n```\n\n```js\nvar n = document.getElementById('mydiv');\nn.dataset.foo // bar\nn.dataset.foo = 'baz'\n```\n\n可以通过 `dateset.foo` 读写 `data-foo` 属性\n\n删除一个 `data-*` 属性，可以直接用 `delete` 命令\n\n**注意**\n\n`data-` 后面的属性名有限制，只能包含字母、数字、连词线（`-`）、点（`.`）、冒号（`:`）和下划线（`_`）。而且，属性名不应该使用 `A` 到 `Z` 的大写字母，比如不能有 `data-helloWorld` 这样的属性名，而要写成 `data-hello-world`。\n\n转成 `dataset` 的键名时，连词线后面如果跟着一个小写字母，那么连词线会被移除，该小写字母转为大写字母，其他字符不变。反过来，`dataset` 的键名转成属性名时，所有大写字母都会被转成连词线+该字母的小写形式，其他字符不变。比如，`dataset.helloWorld` 会转成 `data-hello-world`。\n\n## Text 节点和 DocumentFragment 节点\n\n### Text 节点的概念 \n\n`Text` 节点代表 `Element` 节点和 `Attribute` 节点的文本内容。如果一个节点只包含一段文本，那么它就有一个 `Text` 子节点，代表该节点的文本内容。由于空格也是一个字符，所以哪怕有一个空格，也会形成 `Text` 节点\n\n### Text 节点的属性\n\n#### data\n\n`data` 属性等同于 `nodeValue` 属性，用来设置或读取 `Text` 节点的内容。\n\n#### wholeText\n\n`wholeText` 属性将当前 `Text` 节点与毗邻的 `Text` 节点，作为一个整体返回\n\n\n```html\n<p id=\"para\">A <em>B</em> C</p>\n```\n\n```js\nvar el = document.getElementById(\"para\");\nel.firstChild.wholeText // \"A \"\nel.firstChild.data // \"A \"\n```\n\n但是，一旦移除em节点，`wholeText` 属性与 `data` 属性就会有差异，因为这时其实P节点下面包含了两个毗邻的 `Text` 节点。\n\n```js\nel.removeChild(para.childNodes[1]);\nel.firstChild.wholeText // \"A C\"\nel.firstChild.data // \"A \"\n```\n\n\n### Text 节点的方法\n\n`appendData` 方法用于在 `Text` 节点尾部追加字符串。\n\n`deleteData` 方法用于删除 `Text` 节点内部的子字符串，第一个参数为子字符串位置，第二个参数为子字符串长度。\n\n`insertData` 方法用于在 `Text` 节点插入字符串，第一个参数为插入位置，第二个参数为插入的子字符串。\n\n`replaceData` 方法用于替换文本，第一个参数为替换开始位置，第二个参数为需要被替换掉的长度，第三个参数为新加入的字符串。\n\n`subStringData` 方法用于获取子字符串，第一个参数为子字符串在 `Text` 节点中的开始位置，第二个参数为子字符串长度。\n\n`remove` 方法用于移除当前Text节点。\n\n`splitText` 方法将 `Text` 节点一分为二，变成两个毗邻的 `Text` 节点。它的参数就是分割位置（从零开始），分割到该位置的字符前结束。如果分割位置不存在，将报错。\n\n`normalize` 方法可以将毗邻的两个 `Text` 节点合并。\n\n### DocumentFragment 节点\n\n`DocumentFragment` 节点对象没有自己的属性和方法，全部继承自 `Node` 节点和`ParentNode` 接口。也就是说，`DocumentFragment` 节点比 `Node` 节点多出以下四个属性。\n\n`children`：返回一个动态的 `HTMLCollection` 集合对象，包括当前 `DocumentFragment` 对象的所有子元素节点。\n`firstElementChild`：返回当前`DocumentFragment`对象的第一个子元素节点，如果没有则返回`null`。\n`lastElementChild`：返回当前`DocumentFragment`对象的最后一个子元素节点，如果没有则返回`null`。\n`childElementCount`：返回当前`DocumentFragment`对象的所有子元素数量。\n\n## 事件模型\n\n### EventTarget 接口\n\nDOM的事件操作（监听和触发），都定义在 `EventTarget` 接口。`Element` 节点、 `document` 节点和 `window` 对象，都部署了这个接口\n\n- addEventListener 绑定事件的监听函数\n- removeEventListener 移除事件的监听函数\n- dispatchEvent 触发事件\n\n### addEventListener\n\n接受三个参数\n\n- `type`：事件名称，大小写敏感。\n- `listener`：监听函数。事件发生时，会调用该监听函数。\n- `useCapture`：布尔值，表示监听函数是否在捕获阶段（capture）触发（参见后文《事件的传播》部分），默认为`false`（监听函数只在冒泡阶段被触发）。老式浏览器规定该参数必写，较新版本的浏览器允许该参数可选。为了保持兼容，建议总是写上该参数。\n\n### removeEventListener()\n\n`removeEventListener` 方法用来移除 `addEventListener` 方法添加的事件监听函数。\n\n### dispatchEvent()\n\n`dispatchEvent` 方法在当前节点上触发指定事件，从而触发监听函数的执行。该方法返回一个布尔值，只要有一个监听函数调用了 `Event.preventDefault()` ，则返回值为`false`，否则为 `true` 。\n\n### 监听函数\n\n事件发生时，程序所要执行的函数\n\n#### HTML 标签的 on- 属性\n\n使用这种发放时 `on-` 属性的值是将会执行的代码，而不是一个函数\n\n```html\n<!-- 正确 -->\n<body onload=\"doSomething()\">\n\n<!-- 错误 -->\n<body onload=\"doSomething\">\n```\n\n#### Element 节点的事件属性\n\n```js\ndiv.onclick = function(event){\n  //...\n}\n```\n\n只会在冒泡阶段触发\n\n#### addEventListener方法\n\n第一种“HTML标签的on-属性”，违反了HTML与JavaScript代码相分离的原则；第二种“Element节点的事件属性”的缺点是，同一个事件只能定义一个监听函数，也就是说，如果定义两次onclick属性，后一次定义会覆盖前一次。因此，这两种方法都不推荐使用，除非是为了程序的兼容问题，因为所有浏览器都支持这两种方法。\n\naddEventListener是推荐的指定监听函数的方法。它有如下优点：\n\n可以针对同一个事件，添加多个监听函数。\n\n能够指定在哪个阶段（捕获阶段还是冒泡阶段）触发回监听函数。\n\n除了DOM节点，还可以部署在`window`、`XMLHttpRequest`等对象上面，等于统一了整个JavaScript的监听函数接口。\n\n#### this 对象的指向\n\n以下写法的 `this` 对象都指向 Element 节点\n\n```js\nelement.onclick = print\nelement.addEventListener('click',print,false)\nelement.onclick = function(){console.log(this.id)}\n\n<element onclick=\"console.log(this.id)\">\n```\n\n以下写法的 `this` 对象，都指向全局对象\n\n```js\nelement.onclick = function(){print()}\nelement.setAttribute('onclick','print()')\n\n<element onclick=\"print()\">\n```\n\n### 事件的传播\n\n#### 传播的三个阶段\n\n第一阶段 \n\n从 window 对象传导到目标节点，称为「捕获」阶段\n\n第二阶段\n\n在目标节点触发，称为「目标」阶段\n\n第三阶段\n\n从目标节点传导回 window 对象，成为「冒泡」阶段\n\n```html\n<div>\n  <p>Click Me</p>\n</div>\n``` \n\n- 捕获阶段：事件从`<div>`向`<p>`传播时，触发`<div>`的`click`事件；\n- 目标阶段：事件从`<div>`到达`<p>`时，触发`<p>`的click事件；\n- 目标阶段：事件离开`<p>`时，触发`<p>`的`click`事件；\n- 冒泡阶段：事件从`<p>`传回`<div>`时，再次触发`<div>`的`click`事件\n\n用户点击时，浏览器总是假定 `click` 事件的目标节点就是点击位置的嵌套最深的那个节点。所以 `<p>` 节点的捕获阶段和冒泡阶段会是 `target` 阶段\n\n事件传播的最上层对象是 `window` 接着依次是 `document` `body` 如果 `<body>` 元素中有一个 `<div>` 元素,点击该元素，在捕获阶段为 `window`、`document`、`html`、`body`、`div` ， 在冒泡阶段依次为 `div`、`body`、`html`、`document`、`window`。\n\n#### 事件的代理\n\n由于事件会在冒泡阶段向上传播到父节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件。这种方法叫做事件的代理（delegation）。\n\n如果希望事件到某个节点为止不再传播，可以使用事件对象的 `stopPropagation` 方法。\n但是 `stopPropagation` 方法只会阻止当前监听函数的传播，不会阻止节点上的其它同样事件的监听函数，如果想要不再触发那些监听函数，可以使用 `stopImmediatePropagation` \n\n### Event 对象\n\n事件发生以后，会生成一个事件对象，作为参数传给监听函数。浏览器原生提供了一个 `Event` 对象，所有的事件都是这个对象的实例，或者说继承了 `Event.prototype` 对象\n\n```js\nevent = new Event(typeArg,eventInit)\n```\n\n`Event`构造函数接受两个参数。第一个参数是字符串，表示事件的名称；第二个参数是一个对象，表示事件对象的配置。该参数可以有以下两个属性。\n\n- `bubbles`：布尔值，可选，默认为`false`，表示事件对象是否冒泡。\n- `cancelable`：布尔值，可选，默认为`false`，表示事件是否可以被取消。\n\n#### event 属性\n\n`bubbles` 属性返回一个布尔值，表示当前事件是否会冒泡。该属性为只读属性，只能在新建事件时改变。除非显式声明，Event构造函数生成的事件，默认是不冒泡的。\n\n`eventPhase` 属性返回一个整数值，表示事件目前所处的阶段。\n\n- 0，事件目前没有发生。\n- 1，事件目前处于捕获阶段，即处于从祖先节点向目标节点的传播过程中。该过程是从`Window`对象到`Document`节点，再到`HTMLHtmlElement`节点，直到目标节点的父节点为止。\n- 2，事件到达目标节点，即`target`属性指向的那个节点。\n- 3，事件处于冒泡阶段，即处于从目标节点向祖先节点的反向传播过程中。该过程是从父节点一直到`Window`对象。只有`bubbles`属性为`true`时，这个阶段才可能发生。\n\n`cancelable` 属性返回一个布尔值，表示事件是否可以取消。该属性为只读属性，只能在新建事件时改变。除非显式声明，`Event`构造函数生成的事件，默认是不可以取消的\n\n`defaultPrevented` 属性返回一个布尔值，表示该事件是否调用过 `preventDefault` 方法。。\n\n\n#### event.currentTarget，event.target\n\n`currentTarget` 属性返回事件当前所在的节点，即正在执行的监听函数所绑定的那个节点，`target` 属性返回事件正发生的节点\n\n```js\nfunction hide(e){\n  console.log(this === e.target);  // 有可能不是true\n  e.target.style.visibility = \"hidden\";\n}\n\n// HTML代码为\n// <p id=\"para\">Hello <em>World</em></p>\npara.addEventListener('click', hide, false);\n```\n\n点击 World 会隐藏 `<em>` 节点，`event.currentTarget` 为 `<p>` ，`event.target` 为 `<em>` 节点\n\n在 IE6-IE8 中，该属性的名字不是 `target` ，而是 `srcElement`。\n\n#### event.type，event.detail，event.timeStamp，event.isTrusted\n\n\n`type` 属性返回一个字符串，表示事件类型，大小写敏感。\n\n`detail` 属性返回一个数值，表示事件的某种信息。具体含义与事件类型有关，对于鼠标事件，表示鼠标按键在某个位置按下的次数，比如对于`dblclick`事件，`detail`属性的值总是`2`。\n\n`timeStamp` 属性返回一个毫秒时间戳，表示事件发生的时间。\n\n`isTrusted` 属性返回一个布尔值，表示该事件是否为真实用户触发。\n\n#### event.preventDefault()\n\n`preventDefault` 方法取消浏览器对当前事件的默认行为，比如点击链接后，浏览器跳转到指定页面，或者按一下空格键，页面向下滚动一段距离。该方法生效的前提是，事件对象的`cancelable`属性为`true`，如果为`false`，则调用该方法没有任何效果。\n\n#### event.stopPropagation()\n\n`stopPropagation` 方法阻止事件在 DOM 中继续传播，防止再触发定义在别的节点上的监听函数，但是不包括在当前节点上新定义的事件监听函数。\n\n#### event.stopImmediatePropagation()\n\n`stopImmediatePropagation` 方法阻止同一个事件的其他监听函数被调用。\n\n## 事件种类\n\n### 鼠标事件\n\n#### onclick ,dblclick\n\n鼠标单击定义为用户在同一个位置完成一次 `mousedown` 和 `mouseup` 动作。 他们的触发顺序是 `mousedown` 首先触发， `mouseup` 接着触发 `click` 最后触发\n\n`dblclick` 事件当用户在 `element`、`document`、`window` 对象上，双击鼠标时触发。该事件会在 `mousedown`、`mouseup`、`click`之后触发。\n\n#### mouseup mousedown mousemove\n\n`mouseup` 事件在释放按下的鼠标键时触发。\n\n`mousedown` 事件在按下鼠标键时触发。\n\n`mousemove` 事件当鼠标在一个节点内部移动时触发。当鼠标持续移动时，该事件会**连续触发**。为了避免性能问题，建议对该事件的监听函数做一些限定，比如限定一段时间内只能运行一次代码。\n\n#### mouseover，mouseenter\n\n`mouseover`事件和`mouseenter`事件，都是鼠标**进入一个节点时触发**。\n\n两者的区别是，`mouseenter`事件只触发一次，而只要鼠标在节点内部移动，`mouseover` 事件会在**子节点上触发多次**。\n\n#### mouseout，mouseleave \n\n`mouseout` 事件和 `mouseleave` 事件，都是鼠标离开一个节点时触发。\n\n两者的区别是，`mouseout` 事件会冒泡，`mouseleave` 事件不会。子节点的 `mouseout` 事件会冒泡到父节点，进而触发父节点的 `mouseout` 事件。`mouseleave` 事件就没有这种效果，所以离开子节点时，不会触发父节点的监听函数。\n\n#### contextmenu 事件\n\n`contextmenu` 事件在一个节点上点击鼠标右键时触发，或者按下「上下文菜单」键时触发。\n\n### MouseEvent 对象\n\n#### altKey，ctrlKey，metaKey，shiftKey\n\n以下属性返回一个布尔值，表示鼠标事件发生时，是否同时按下某个键。\n\n- `altKey` 属性 ：Alt 键\n- `ctrlKey` 属性 ：Ctrl 键\n- `metaKey` 属性 ：Meta 键（Mac键盘是一个四瓣的小花，Windows键盘是Windows键）\n- `shiftKey` 属性 ：Shift 键\n\n#### button，buttons\n\n`button` 属性返回一个数值，表示按下了鼠标哪个键。\n\n- -1：没有按下键。\n- 0：按下主键（通常是左键）。\n- 1：按下辅助键（通常是中键或者滚轮键）。\n- 2：按下次键（通常是右键）。\n\n`buttons` 属性返回一个3个比特位的值，表示**同时按下了哪些键**。它用来处理同时按下多个鼠标键的情况。\n\n- 1：二进制为001，表示按下左键。\n- 2：二进制为010，表示按下右键。\n- 4：二进制为100，表示按下中键或滚轮键。\n\n同时按下多个键的时候，每个按下的键对应的比特位都会有值。比如，同时按下左键和右键，会返回3（二进制为011）。\n\n#### clientX，clientY\n\n`clientX`，`clientY` 属性返回鼠标位置相对于浏览器窗口左上角的水平垂直坐标，单位为像素，与页面是否横向滚动无关。\n\n#### movementX，movementY\n\n`movementX` 属性返回一个水平位移，单位为像素，表示当前位置与上一个 `mousemove` 事件之间的水平距离。在数值上，等于 `currentEvent.movementX` = `currentEvent.screenX` - `previousEvent.screenX`。\n\n#### screenX，screenY\n\n`screenX`，`screenY` 属性返回鼠标位置相对于屏幕左上角的水平坐标，单位为像素。\n\n### Wheel 事件\n\n`Wheel` 事件是与鼠标滚轮相关的事件，目前只有一个 `Wheel` 事件。用户滚动滚轮，触发此事件\n\n该事件继承了 MouseEvent ，UIEvent ，Event 属性 ，还有几个自己的属性\n\n- deltaX : 返回一个数值，表示一个滚轮的水平滚动量\n- deltxY : 返回一个数值，表示一个滚轮的垂直滚动量\n- deltxZ : 返回一个数值，表示一个滚轮的Z轴滚动量\n- deltaMode : 返回一个数值，表示一个单位。0为像素，1表示行，2表示页\n\n### 键盘事件\n\n- keydown : 按下键盘时触发的事件\n- keypress : 只要按下的键并非 Ctrl ， Alt ，Shift 和 Meta ，就接着触发 keypress 事件\n- keyup : 松开键盘时触发该事件\n\n如果用户一直按键不松开，就会连续触发键盘事件，触发的事件如下\n\n- keydown\n- keypress\n- keydown\n- keypress\n- 「重复以上过程」\n- keyup\n\nkeyBoard 事件还有几个可配置字段\n\n- key : 默认为空字符串，返回按下的键的字符串\n- ctrlKey : 是否按下 ctrl 键\n- shiftKey : 是否按下 shift 键\n- altKey : 是否按下 alt 键\n- metaKey : 是否按下 meta 键\n- charCode : 返回一个数值，表示keypress按键的Unicode值，该属性已从标准中移除\n\n### 进度事件\n\n- abort : 当进度事件被中止时触发。如果发生错误，导致事件中止，不会触发该事件\n- error : 由于错误导致资源无法加载时触发\n- load : 进度成功结束时触发\n- loadstart : 进度开始时触发\n- loadend : 进度停止时触发，发生顺序在 `error` 事件、 `abort` 事件、`load` 事件后面\n- progress : 当操作处于进度之中，由传输的数据块不断触发\n- timeout : 进度超过限时触发\n\n\n有时候，图片加载会在脚本运行之前就完成，尤其是脚本放置在网页底部的时候，因此有可能使得 `load` 和 `error` 事件的监听函数根本不会执行，`error` 事件的监听函数最好放在 `img` 元素的 HTML 属性中，这样才能保证发生错误时百分之百执行。`error` 事件也不会冒泡\n\n`progress` 事件也有几个属性\n\n- lenthComputable : 返回一个布尔值，表示当前进度是否具有可计算的长度，如果为 `false` ，就表示当前进度无法测量\n- total : 返回一个数值，表示当前进度的总长度，如果是通过 HTTP 下载某个资源，表示内容本身的长度，不含 HTTP 头部的长度。如果 `lengthComputable` 属性为 `false` ，则 `total` 属性就无法去的正确的值\n- loaded : 返回一个数值，表示当前进度已经完成的数量。该属性除以 `total` 属性就可以得到目前进度的百分比\n\n### 拖拉事件\n\n拖拉指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里\n\n图片和链接不加本身就可以拖动，`Element` 节点需要设置 `draggable` 属性为 `true` ，但是这样鼠标就无法选中该字节内部的文字和子节了\n\n#### 事件种类\n\n当 `Element` 节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件\n\n在拖拉节点上触发的事件\n\n- drag事件 ： 拖拉过程中，在被拖拉的节点上持续触发\n- dragstart事件 ：拖拉开始时触发，该事件的 `target` 属性是被拖拉的节点\n- dragend事件 ： 在拖拉结束时触发\n\n在目标节点上触发的事件\n\n- dragenter事件 ： 拖拉进入当前节点时触发\n- dragover事件 ：拖拉到当前节点上方时持续触发\n- dragleave事件 ：拖拉离开当前范围节点时触发\n- drop事件 ：被拖拉的节点释放，目标节点触发\n\n**注意**\n\n- 拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发\n- 将文件从操作系统拖拉进浏览器，不会触发 `dragstart` 和 `dragend` 事件\n- `dragenter` 和 `dragover` 事件默认设置为当前节点不允许drop，如果想要在目标节点上 `drop` 拖拉的数据，首先必须阻止这两个事件的默认行为，或者取消这两个事件\n\n```html\n<div ondragover=\"event.preventDefault()\"></div>\n```\n\n#### DataTransfer 对象概述\n\n所有的拖拉事件都有一个 dataTransfer 属性，用来保存需要传递的数据。这个属性的值是一个 DataTransfer 对象\n\n拖拉的数据保存两方面的数据，数据的种类和数据的数值，种类是一个MIME字符串，数据的值是一个字符串\n\n拖拉开始时提供数据类型和数据值，`dragenter` 和 `dragover` 事件检查数据，以确定是否准许放下。\n\n#### DataTransfer 对象的属性\n\n**dropEffect**\n\n设置放下被拖拉节点时的效果\n\n- copy 复制被拖拉的节点\n- move 移动被拖拉的节点\n- link 创建指向被拖拉的节点的链接\n- none 无法放下被拖拉的节点\n\n一般在 `dragenter` 和 `dragover` 事件的监听函数中设置，对于 `dragstart`、`drag`、`dragleave` 这三个事件，该属性不起作用。进入目标节点后，用户可通过Shift键和Control键，改变初始值\n\n箭头会根据 `dropEffect` 属性改变形状\n\n**effectAllowed**\n\n`effectAllowed` 属性设置本次拖拉中允许的效果\n\n- copy 复制被拖拉的节点\n- move 移动被拖拉的节点\n- link 创建指向被拖拉节点的链接\n- copyLink 允许copy或link\n- copyMove 允许copy或move\n- linkMove 允许link或move\n- all 允许所有效果\n- none 无法放下被拖拉的节点\n- uninitialized 默认值，等同于all\n\n只要 `dropEffect` 属性和 `effectAllowed` 属性之中，有一个为none，就无法在目标节点完成  `drop` 操作\n\n**files**\n\n`files` 属性是一个 FileList 对象，如果本次拖拉不涉及文件，则属性为空的 FileList 对象\n\n通过 `files` 属性读取拖拉文件的信息，如果想要读取文件的内容，要使用 FileReader 对象\n\n**types**\n\n`types` 属性是一个数组，保存每一次拖拉的数据格式，比如拖拉文件，则格式信息为File\n\n#### DataTransfer 对象的方法\n\n**setData()**\n\n`setData` 方法用来设置事件所带有的指定类型的数据。它接受两个参数，第一个是数据类型，第二个是具体数据。如果指定的类型在现有数据中不存在，则该类型将写入 `types` 属性；如果已经存在，在该类型的现有数据将被替换。\n\n如果拖拉文本框或者拖拉选中的文本，会默认将文本数据添加到 `dataTransfer` 属性，不用手动指定。\n\n```html\n<div draggable=\"true\" ondragstart=\"\n  event.dataTransfer.setData('text/plain', 'bbb')\">\n  aaa\n</div>\n```\n\n上面代码中，拖拉数据实际上是 bbb ，而不是 aaa\n\n由于 `text/plain` 是最普遍支持的格式，为了保证兼容性，建议最后总是将数据保存一份纯文本的格式。\n\n```js\nvar dt = event.dataTransfer;\n\n// 添加链接\ndt.setData(\"text/uri-list\", \"http://www.example.com\");\ndt.setData(\"text/plain\", \"http://www.example.com\");\n// 添加HTML代码\ndt.setData(\"text/html\", \"Hello there, <strong>stranger</strong>\");\ndt.setData(\"text/plain\", \"Hello there, <strong>stranger</strong>\");\n// 添加图像的URL\ndt.setData(\"text/uri-list\", imageurl);\ndt.setData(\"text/plain\", imageurl);\n```\n\n**getData()**\n\n`getData` 方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用 `setData` 方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有 `drop` 事件触发后，才能取出数据。如果取出另一个域名存放的数据，将会报错。\n\n**clearData()**\n\n`clearData` 方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则原数据不受影响。\n\n**setDragImage()**\n\n拖动过程中（ `dragstart` 事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置 。`setDragImage` 方法可以用来自定义这张图片，它接受三个参数，第一个是`img` 图片元素或者 `canvas` 元素，如果省略或为 `null` 则使用被拖动的节点的外观，第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。\n\n```js\ndiv.addEventListener('dragstart',function(e){\n  var img = document.createElement(\"img\");\n  img.src=\"http://path/to/img\";\n  e.dataTransfer.setDragImage(img,0,0);\n},false)\n```\n\n### 触摸事件\n\nTouch 对象表示触摸点，多个触摸点由 TouchList 对象表示，TouchEvent 对象代表由触摸引发的事件。\n\n很多时候，触摸事件和鼠标事件同时触发，即使这个时候并没有用到鼠标。这是为了让那些只定义鼠标事件、没有定义触摸事件的代码，在触摸屏的情况下仍然能用。如果想避免这种情况，可以用 `preventDefault` 方法阻止发出鼠标事件。\n\n#### Touch 对象\n\nTouch 对象代表一个触摸点\n\n**identifier**\n\n`identifier` 属性表示 `Touch` 实例的独一无二的识别符。它在整个触摸过程中保持不变。\n\n**screenX，screenY，clientX，clientY，pageX，pageY**\n\n`screenX` 属性和 `screenY` 属性，分别表示触摸点相对于屏幕左上角的横坐标和纵坐标，与页面是否滚动无关。\n\n`clientX` 属性和 `clientY` 属性，分别表示触摸点相对于浏览器视口左上角的横坐标和纵坐标，与页面是否滚动无关。\n\n`pageX` 属性和 `pageY` 属性，分别表示触摸点相对于当前页面左上角的横坐标和纵坐标，包含了页面滚动带来的位移。\n\n**radiusX，radiusY，rotationAngle**\n\n`radiusX` 属性和 `radiusY` 属性，分别返回触摸点周围受到影响的椭圆范围的X轴和Y轴，单位为像素。\n\n`rotationAngle` 属性表示触摸区域的椭圆的旋转角度，单位为度数，在0到90度之间。\n\n上面这三个属性共同定义了用户与屏幕接触的区域，对于描述手指这一类非精确的触摸，很有帮助。指尖接触屏幕，触摸范围会形成一个椭圆，这三个属性就用来描述这个椭圆区域。\n\n**force**\n\n`force `属性返回一个0到1之间的数值，表示触摸压力。0代表没有压力，1代表硬件所能识别的最大压力。\n\n**target**\n\n`target` 属性返回一个Element节点，代表触摸发生的那个节点。\n\n#### TouchList 对象\n\n`TouchList` 对象是一个类似数组的对象，成员是与某个触摸事件相关的所有触摸点。\n\n`TouchList` 实例的 `identifiedTouch` 方法和 `item` 方法，分别使用id属性和索引值（从0开始）作为参数，取出指定的 `Touch` 对象。\n\n#### TouchEvent 对象\n\n**键盘相关属性**\n\n- altKey 是否按下alt键\n- ctrlKey 是否按下ctrl键\n- metaKey 是否按下meta键\n- shiftKey 是否按下shift键\n\n**changedTouches**\n\n`changedTouches` 属性返回一个 `TouchList` 对象，包含了由当前触摸事件引发的所有 `Touch` 对象（即相关的触摸点）。\n\n**targetTouches**\n\n`targetTouches` 属性返回一个 `TouchList` 对象，包含了触摸的目标Element节点内部，所有仍然处于活动状态的触摸点。\n\n**touches**\n\n`touches` 属性返回一个 `TouchList` 对象，包含了所有仍然处于活动状态的触摸点。\n\n#### 触摸事件的种类\n\n- touchstart：用户接触触摸屏时触发，它的target属性返回发生触摸的Element节点。\n- touchend：用户不再接触触摸屏时（或者移出屏幕边缘时）触发，它的target属性与touchstart事件的target属性是一致的，它的changedTouches属性返回一个TouchList对象，包含所有不再触摸的触摸点（Touch对象）。\n- touchmove：用户移动触摸点时触发，它的target属性与touchstart事件的target属性一致。如果触摸的半径、角度、力度发生变化，也会触发该事件。\n- touchcancel：触摸点取消时触发，比如在触摸区域跳出一个情态窗口（modal window）、触摸点离开了文档区域（进入浏览器菜单栏区域）、用户放置更多的触摸点（自动取消早先的触摸点）。\n\n### 表单事件\n\n#### Input事件，select事件，change事件\n\n`input` 事件当 `<input>`、`<textarea>` 的值发生变化时触发。此外，打开`contenteditable` 属性的元素，只要值发生变化，也会触发 `input` 事件。\n\n`input` 事件的一个特点，就是会连续触发，比如用户每次按下一次按键，就会触发一次`input` 事件。\n\n\n`select` 事件当在 `<input>`、`<textarea>` 中选中文本时触发。\n\n`Change` 事件当 `<input>`、`<select>`、`<textarea>` 的值发生变化时触发。它与`input` 事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，而且`input` 事件必然会引发 `change` 事件。具体来说，分成以下几种情况。\n\n- 激活单选框（radio）或复选框（checkbox）时触发。\n- 户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。\n- 当文本框或 `textarea` 元素的值发生改变，并且丧失焦点时触发。\n\n#### reset事件，submit事件\n\n`reset` 事件当表单重置（所有表单成员变回默认值）时触发。\n\n`submit` 事件当表单数据向服务器提交时触发。注意，`submit` 事件的发生对象是 `form` 元素，**而不是 `button` 元素（即使它的类型是 `submit` ），因为提交的是表单，而不是按钮。**\n\n### 文档事件\n\n#### beforeunload 事件\n\n`beforeunload` 事件在窗口将要关闭，或者网页（即 `document` 对象）将要卸载时触发。它可以用来防止用户不小心关闭网页。\n\n根据标准，只要在该事件的回调函数中，调用了 `event.preventDefault()` ，或者 `event.returnValue` 属性的值是一个非空的值，就会自动跳出一个确认框，让用户确认是否关闭网页。如果用户点击“取消”按钮，网页就不会关闭。 `event.returnValue` 属性的值，会显示在确认对话框之中。\n\n许多手机浏览器默认忽视这个事件，而桌面浏览器也可以这样设置，所以这个事件有可能根本不生效。所以，**不能依赖它来阻止用户关闭窗口**。\n\n#### unload 事件\n\nunload事件在窗口关闭或者document对象将要卸载时触发，发生在window、body、frameset等对象上面。它的触发顺序排在beforeunload、pagehide事件后面。unload事件只在页面没有被浏览器缓存时才会触发，换言之，如果通过按下“前进/后退”导致页面卸载，并不会触发unload事件。\n\n当unload事件发生时，document对象处于一个特殊状态。所有资源依然存在，但是对用户来说都不可见，UI互动（window.open、alert、confirm方法等）全部无效。这时即使抛出错误，也不能停止文档的卸载。\n\n如果在window对象上定义了该事件，网页就不会被浏览器缓存。\n\n#### load事件，error事件\n\n`load` 事件在页面加载成功时触发，`error` 事件在页面加载失败时触发。注意，页面从浏览器缓存加载，并不会触发 `load` 事件。\n\n#### pageshow事件，pagehide事件\n\n默认情况下，浏览器会在当前会话（session）缓存页面，当用户点击“前进/后退”按钮时，浏览器就会从缓存中加载页面。\n\npageshow事件在页面加载时触发，包括第一次加载和从缓存加载两种情况。如果要指定页面每次加载（不管是不是从浏览器缓存）时都运行的代码，可以放在这个事件的监听函数。\n\npagehide事件与pageshow事件类似，当用户通过“前进/后退”按钮，离开当前页面时触发。它与unload事件的区别在于，如果在window对象上定义unload事件的监听函数之后，页面不会保存在缓存中，而使用pagehide事件，页面会保存在缓存中。\n\n#### DOMContentLoaded事件\n\n当HTML文档下载并解析完成以后，就会在document对象上触发DOMContentLoaded事件。这时，仅仅完成了HTML文档的解析（整张页面的DOM生成），所有外部资源（样式表、脚本、iframe等等）可能还没有下载结束。也就是说，这个事件比load事件，发生时间早得多。\n\n#### readystatechange事件\n\nreadystatechange事件发生在Document对象和XMLHttpRequest对象，当它们的readyState属性发生变化时触发。\n\n#### scroll事件\n\nscroll事件在文档或文档元素滚动时触发，主要出现在用户拖动滚动条。\n\n#### resize事件\n\nresize事件在改变浏览器窗口大小时触发，发生在window、body、frameset对象上面。\n\n#### 焦点事件\n\n- focus事件：Element节点获得焦点后触发，该事件不会冒泡。\n- blur事件：Element节点失去焦点后触发，该事件不会冒泡。\n- focusin事件：Element节点将要获得焦点时触发，发生在focus事件之前。该事件会冒泡。Firefox不支持该事件。\n- focusout事件：Element节点将要失去焦点时触发，发生在blur事件之前。该事件会冒泡。Firefox不支持该事件。\n\n## CSS 操作\n\n### style 属性\n\n操作 CSS 样式最简单的方法，就是使用网页元素节点的 `getAttribute` 方法、 `setAttribute` 方法和 `removeAttribute` 方法，直接读写或删除网页元素的 `style` 属性。\n\n```js\ndiv.setAttribute(\n  'style',\n  'background-color:red;' + 'border:1px solid black;'\n);\n```\n\n### Style 对象\n\n```js\nvar divStyle = document.querySelector('div').style;\n```\n\n这个 `style` 对象可以直接操作，但是名字需要改写，比如 `background-color` 写成 `backgroundColor`。如果CSS属性是JavaScript保留字，那规则名之前需要加上字符串`css` ，比如 `float` 写成 `cssFloat` \n\n#### cssText 属性\n\n元素节点对象的 `style` 对象，有一个 `cssText` 属性，可以读写或删除整个样式。\n\n```js\nvar divStyle = document.querySelector('div').style;\n\ndivStyle.cssText = 'background-color: red;'\n  + 'border: 1px solid black;'\n  + 'height: 100px;'\n  + 'width: 100px;';\n```\n\n`cssText` 的属性值不用改写 CSS 属性名\n\n#### CSS 模块的侦测\n\nCSS的规格发展太快，新的模块层出不穷。不同浏览器的不同版本，对CSS模块的支持情况都不一样。有时候，需要知道当前浏览器是否支持某个模块，这就叫做「CSS模块的侦测」。\n\n#### setProperty()，getPropertyValue()，removeProperty()\n\n- `setProperty(propertyName,value)` ：设置某个CSS属性。\n- `getPropertyValue(propertyName)` ：读取某个CSS属性。\n- `removeProperty(propertyName)` ：删除某个CSS属性。 \n\n#### window.getComputedStyle()\n\n`window.getComputedStyle` 方法，就用来返回这个规则。它接受一个DOM节点对象作为参数，返回一个包含该节点最终样式信息的对象。所谓“最终样式信息”，指的是各种CSS规则叠加后的结果。\n\n`getComputedStyle` 方法还可以接受第二个参数，表示指定节点的伪元素（比如`:before`、`:after`、`:first-line`、`:first-letter` 等）\n\n**注意**\n\n- 返回的CSS值都是绝对单位，比如，长度都是像素单位（返回值包括px后缀），颜色是 `rgb(#, #, #)` 或 `rgba(#, #, #, #)` 格式。\n- CSS规则的简写形式无效，比如，想读取 `margin` 属性的值，不能直接读，只能读 `marginLeft`、`marginTop` 等属性。\n- 如果一个元素不是绝对定位， `top` 和 `left` 属性总是返回 `auto` 。\n- 该方法返回的样式对象的 `cssText` 属性无效，返回 `undefined` 。\n- 该方法返回的样式对象是只读的，如果想设置样式，应该使用元素节点的 `style` 属性。\n\n### CSS 伪元素\n\nCSS伪元素是通过CSS向DOM添加的元素，主要方法是通过 `:before` 和 `:after` 选择器生成伪元素，然后用 `content` 属性指定伪元素的内容。\n\n### StyleSheet对象\n\n#### 获取样式表\n\n`document.styleSheets` 返回当前页面所有 `StyleSheet` 对象。是一个类数组对象\n\n#### 属性\n\n**media**\n\n`media` 属性表示这个样式表是用于屏幕（screen），还是用于打印（print），或两者都适用（all）。该属性只读，默认值是 `screen`。\n\n**disabled**\n\n`disabled` 属性用于打开或关闭一张样式表。`disabled` 属性只能在 JavaScript 脚本中设置，不能在 HTML 语句中设置。\n\n**href**\n\n`href` 属性是只读属性，返回 `StyleSheet` 对象连接的样式表地址。对于内嵌的 `<style>` 节点，该属性等于 `null` 。\n\n**title**\n\n`title` 属性返回 `StyleSheet` 对象的 `title` 值。\n\n**type属性**\n\n`type` 属性返回 `StyleSheet` 对象的 `type` 值，通常是 `text/css`。\n\n**parentStyleSheet**\n\nCSS的 `@import` 命令允许在样式表中加载其他样式表。`parentStyleSheet` 属性返回包含了当前样式表的那张样式表。如果当前样式表是顶层样式表，则该属性返回 `null`。\n\n**ownerNode**\n\n`ownerNode` 属性返回 `StyleSheet` 对象所在的DOM节点，通常是 `<link>` 或 `<style>`。对于那些由其他样式表引用的样式表，该属性为 `null`。\n\n```js\n// HTML代码为\n// <link rel=\"StyleSheet\" href=\"example.css\" type=\"text/css\" />\n\ndocument.styleSheets[0].ownerNode // [object HTMLLinkElement]\n```\n\n**cssRules**\n\n`cssRules` 属性指向一个类似数组的对象，里面每一个成员就是当前样式表的一条CSS规则。使用该规则的 `cssText` 属性，可以得到CSS规则对应的字符串。\n\n#### insertRule()，deleteRule()\n\n`insertRule` 方法用于在当前样式表的 `cssRules` 对象插入CSS规则，`deleteRule` 方法用于删除 `cssRules` 对象的CSS规则。\n\n`insertRule` 方法的第一个参数是表示CSS规则的字符串，第二个参数是该规则在`cssRules` 象的插入位置，是一个数值。`deleteRule` 方法的参数是该条规则在`cssRules` 对象中的位置。\n\n#### 添加样式表\n\n添加内部样式表 `<style>` 节点\n\n```js\nvar style = document.createElement('style');\nstyle.setAttribute('media','screen');\nstyle.setAttribute('media','@media only screen and (max-width : 1024px)');\nstyle.innerHTML = 'body{color:red}';\ndocument.head.appendChild(style);\n```\n\n添加外部样式表，在文档中添加 `<link>` 节点\n\n```js\nvar linkElm = document.createElement('link');\nlinkElm.setAttribute('rel', 'stylesheet');\nlinkElm.setAttribute('type', 'text/css');\nlinkElm.setAttribute('href', 'reset-min.css');\n\ndocument.head.appendChild(linkElm);\n```\n\n### CSS 规则\n\n一条CSS规则包括两个部分：CSS选择器和样式声明。下面就是一条典型的CSS规则。\n\n```css\n.myClass {\n  background-color: yellow;\n}\n```\n\n### window.matchMedia()\n\n`window.matchMedia` 方法用来检查CSS的 `mediaQuery` 语句\n\n```js\nvar result = window.matchMedia('(min-width: 600px)');\nresult.media // (min-width: 600px)\nresult.matches // true\n```\n\n`media` 返回所查询的 `mediaQuery` 语句字符串，`matches` 返回一个布尔值，表示当前环境是否匹配查询语句\n\n```js\nvar result = window.matchMedia('(max-width: 700px)');\n\nif (result.matches) {\n  console.log('页面宽度小于等于700px');\n} else {\n  console.log('页面宽度大于700px');\n}\n```\n\n#### 监听事件\n\n`window.matchMedia` 方法返回的 `MediaQueryList` 对象有两个方法，用来监听事件：`addListener` 方法和 `removeListener` 方法。如果 `mediaQuery` 查询结果发生变化，就调用指定的回调函数。\n\n```js\nvar mql = window.matchMedia(\"(max-width: 700px)\");\n\nmql.addListener(mqCallback);\n\n//...\n```\n\n### CSS事件\n\n#### transitionEnd 事件\n\ncss的过渡效果「transition」结束后，触发 `transitionEnd` 事件\n\n```js\nel.addEventListener('transitionend', onTransitionEnd, false);\n\nfunction onTransitionEnd() {\n  console.log('Transition end');\n}\n```\n\n`transitionEnd` 的事件对象具有以下属性。\n\n- `propertyName` ：发生 `transition` 效果的CSS属性名。\n- `elapsedTime` ：`transition` 效果持续的秒数，不含 `transition-delay` 的时间。\n- `pseudoElement` ：如果 `transition` 效果发生在伪元素，会返回该伪元素的名称，以「::」开头。如果不发生在伪元素上，则返回一个空字符串。\n\n#### animationstart事件，animationend事件，animationiteration事件\n\n- animationstart : 动画开始时触发\n- animationend : 动画结束时触发\n- animationiteration : 开始新一轮动画循环时触发。如果animationiteration-count属性等于1，该事件不触发，即只播放一轮的CSS动画，不触发animationiteration事件\n\n\n## Mutation Observer API\n\n### 概述\n\n用来监视 DOM 变动，异步触发而且不是马上触发，而是要等到当前所有 DOM 操作都结束才触发\n\n- 它等待所有脚本任务完成后，才会运行，即采用异步方式。\n- 它把 DOM 变动记录封装成一个数组进行处理，而不是一条条地个别处理 DOM 变动。\n- 它既可以观察发生在 DOM 的所有类型变动，也可以观察某一类变动。\n\n### MutationObserver 构造函数\n\n回调函数接受两个参数，第一个是变动数组，第二个是观察实例\n\n```js\nvar observer = new MutationObserver(function (mutations, observer) {\n  mutations.forEach(function(mutation) {\n    console.log(mutation);\n  });\n});\n```\n\n### 实例方法\n\n#### observe()\n\n- 第一个参数是所要观察的 DOM 节点\n- 第二个参数是一个配置对象，用来指定所要观察的特定变动\n\n配置对象有以下几种\n\n- childList：子节点的变动。\n- attributes：属性的变动。\n- characterData：节点内容或节点文本的变动。\n- subtree：所有后代节点的变动。\n- attributeOldValue：类型为布尔值，表示观察attributes变动时，是否需要记录变动前的属性值。\n- characterDataOldValue：类型为布尔值，表示观察characterData变动时，是否需要记录变动前的值。\n- attributeFilter：类型为数组，表示需要观察的特定属性（比如['class','src']）。\n\n#### disconnect(),takeRecords()\n\n`disconnect` 方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。\n\n`takeRecords` 方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。\n\n### MutationRecord 对象\n\n`MutationRecord` 对象包含了DOM的相关信息，有如下属性：\n\n- type：观察的变动类型（attribute、characterData或者childList）。\n- target：发生变动的DOM节点。\n- addedNodes：新增的DOM节点。\n- removedNodes：删除的DOM节点。\n- previousSibling：前一个同级节点，如果没有则返回null。\n- nextSibling：下一个同级节点，如果没有则返回null。\n- attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。\n- oldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。\n\n\n","tags":["ES5"],"categories":["Note"]},{"title":"LeanJs「 ES5 」-- 语法专题","url":"%2F2018%2F01%2F26%2FLeanJS%E8%AF%AD%E6%B3%95%E4%B8%93%E9%A2%98%2F","content":"\n![Js](LeanJS语法专题/js.png)\n\n<!--more-->\n\n## 单线程模式\n\nJavaScript 只在一个线程上运行，也就是说同时只能进行一个任务，其他任务必须要排队.但是这不代表 JavaScript 只有一个线程，实际上 JavaScript 引擎有多个线程。\n\n单线程模式带来很多问题，因为新的任务只能加在任务队列的末尾，如果排在前面的任务加载需要过长的时间，后面的所有任务都会在等待，造成浏览器失去响应，又称为「假死」\n\n而且有的时候并不是因为计算量大，而是因为有的时候输入输出设备或者一些耗时的请求阻碍队列的正常的进行，此时CPU在闲着确还是出现了假死的现象\n\n### 消息队列\n\n为了避免以上说的情况，设计者设计了一个消息队列，也就是对于一些耗时的操作， JavaScript 引擎提供了一个消息队列，排在任务队列的最后。先优先处理相对简单的任务，等任务队列处理完成之后，再处理消息队列。\n\n### Event Loop\n\n所谓Event Loop机制，指的是一种内部循环，用来**一轮又一轮地处理消息队列之中的消息，即执行对应的回调函数**。\n\n消息队列是一个先进先出的数据结构，按顺序动态添加处理消息队列中的任务\n\n## 定时器\n\n### setTimeout()\n\n第一个参数是要执行的函数名，回调函数或者是代码，如果传入的是代码要用字符串的形式，因为引擎内部用 `eval`，第二个参数是推迟的时间单位为毫秒\n\n```js\nsetTimeout(func|code,timeout)\n```\n\n`setTimeout` 还允许添加更多的参数，多余的参数会被传入回调函数中，这种方式IE9以下不支持\n\n```js\nsetTimeout(function(a,b){\n  console.log(a+b);\n},1000,1,2)\n```\n\n如果还是想实现传参的话可以自定义一个函数\n\n```js\nsetTimeout(function(){\n  add(a,b);\n},1000)\n```\n\n`setTimeout` 传入的回调函数如果是某个对象的方法，那么该方法中的 `this` 会指向全局对象\n\n```js\nfunction User(login) {\n  this.login = login;\n  this.sayHi = function() {\n    console.log(this.login);\n  }\n}\n\nvar user = new User('John');\n\nsetTimeout(user.sayHi, 1000); //undefined\n```\n\n写在回调函数中即可\n\n```js\nsetTimeout(function(){\n  user.sayHi()\n}, 1000);\n```\n\n也可用 `bind`\n\n```js\nsetTimeout(user.sayHi.bind(this),1000)\n```\n\nHTML 5标准规定，`setTimeout` 的最短时间间隔是4毫秒。为了节电，对于那些不处于当前窗口的页面，浏览器会将时间间隔扩大到1000毫秒。另外，如果笔记本电脑处于电池供电状态，Chrome和IE 9以上的版本，会将时间间隔切换到系统定时器，大约是15.6毫秒。\n\n### setInterval()\n\n`setInterval` 函数的用法与 `setTimeout` 完全一致，区别仅仅在于 `setInterval` 指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。\n\n`setInterval` 的时间间隔不是结束后的时间，而是开始后就开始算，假如 `delay` 时间设置的是 `1000ms` 假如这个任务执行了100ms，那么下次调用这个任务就是这个任务结束后的900ms执行，假如这个任务执行了1000ms那么后面的任务就在它执行后立马执行\n\n为了确保两次执行的间隔之间相同，推荐使用 `setTimeout` 代替 `setInterval`\n\n```js\nvar timer = setTimeout(function(){\n  //do something\n  var timer = setTimeout(arguments.callee,2000)\n},2000)\n```\n\n也可以自定义一个函数来替代 `setInterval`\n\n```js\nfunction interval(func,delay){\n  var interv = function(){\n    //将func的this指向全局\n    func.call(null);\n    setTimeout(interv,delay)\n  }\n  setTimeout(interv,delay);\n}\n```\n\nHTML 5标准规定，`setInterval` 的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒。\n\n### clearTimeout() clearInterval()\n\n`setTimeout` 和 `setInterval` 函数，都返回一个表示计数器编号的整数值，将该整数传入 `clearTimeout` 和 `clearInterval` 函数，就可以取消对应的定时器。\n\n`setTimeout` 和 `setInterval` 返回的整数值是连续的。\n\n利用这一点可以写一个函数取消当前所有的 `setTimeout()`\n\n```js\n(function() {\n  var gid = setInterval(clearAllTimeouts, 0);\n\n  function clearAllTimeouts() {\n    //此id代表的数值为定义的定时器中最大的\n    var id = setTimeout(function() {}, 0);\n    while (id > 0) {\n      if (id !== gid) {\n        clearTimeout(id);\n      }\n      id--;\n    }\n  }\n})();\n```\n\n运行上面代码后，实际上再设置任何 `setTimeout` 都无效了。\n\n防抖动函数也可以利用 `setTimeout` 改写\n\n```js\nfunciton debounce(func,delay){\n  var timer = null;\n  return function(){\n    var context = this;\n    var args = arguments;\n    clearTimeout(timer);\n    var timer = setTimeout(function(){\n      func.apply(context,args);\n    },delay)\n  }\n}\n```\n\n### 运行机制\n\n`setTimeout` 和 `setInterval` 的运行机制是，将指定的代码移出本次执行，等到下一轮 Event Loop 时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮 Event Loop 时重新判断。\n\n### setTimeout(f,0)\n\n#### 调整事件的执行顺序\n\n用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，`keypress` 事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。\n\n```js\ndocument.getElementById('input-box').onkeypress = function(event) {\n  this.value = this.value.toUpperCase();\n}\n```\n\n上面代码想在用户输入文本后，立即将字符转为大写。但是实际上，它只能将上一个字符转为大写，因为浏览器此时还没接收到文本，所以 `this.value` 取不到最新输入的那个字符。只有用 `setTimeout` 改写，上面的代码才能发挥作用。\n\n```js\ndocument.getElementById('my-ok').onkeypress = function() {\n  var self = this;\n  setTimeout(function() {\n    self.value = self.value.toUpperCase();\n  }, 0);\n}\n```\n\n上面代码将代码放入 `setTimeout` 之中，就能使得它在浏览器接收到文本之后触发。\n\n#### 分批处理耗时的任务\n\n由于 `setTimeout(f,0)` 实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到 `setTimeout(f,0)` 里面执行。\n\n```js\nvar div = document.getElementsByTagName('div')[0];\n\n// 写法一\nfor (var i = 0xA00000; i < 0xFFFFFF; i++) {\n  div.style.backgroundColor = '#' + i.toString(16);\n}\n\n// 写法二\nvar timer;\nvar i=0x100000;\n\nfunction func() {\n  timer = setTimeout(func, 0);\n  div.style.backgroundColor = '#' + i.toString(16);\n  if (i++ == 0xFFFFFF) clearTimeout(timer);\n}\n\ntimer = setTimeout(func, 0);\n```\n\n上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器「堵塞」，**因为JavaScript执行速度远高于DOM**，会造成大量DOM操作「堆积」，而写法二就不会，这就是 `setTimeout(f, 0)` 的好处。\n\n另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成 `setTimeout(highlightNext, 50)` 的样子，性能压力就会减轻。\n\n### 正常任务和微任务\n\n这时，需要区分两种任务：正常任务（task）与微任务（microtask）。它们的区别在于，「正常任务」在下一轮Event Loop执行，「微任务」在本轮Event Loop的所有任务结束后执行。\n\n微任务主要是 `process.nextTick`和 Promise\n\n正常任务为 \n\n- setTimeout\n- setInterval\n- setImmediate\n- I/O\n- 各种事件（比如鼠标单击事件）的回调函数\n\n\n```js\nconsole.log(1);\n\nsetTimeout(function() {\n  console.log(2);\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log(3);\n}).then(function() {\n  console.log(4);\n});\n\nconsole.log(5);\n\n// 1\n// 5\n// 3\n// 4\n// 2\n```\n\n`setTimeout` 为正常任务，在下一轮执行，Promise 在队列结束后立马执行，所以 5 后先是 3 和 4 然后再是 2\n\n## Promise\n\n### JavaScript 的异步执行\n\n「异步模式」则完全不同，每一个任务分成两段，第一段代码包含对外部数据的请求，第二段代码被写成一个回调函数，包含了对外部数据的处理。第一段代码执行完，不是立刻执行第二段代码，而是将程序的执行权交给第二个任务。等到外部数据返回了，再由系统通知执行第二段代码。所以，程序的执行顺序与任务的排列顺序是不一致的、异步的。\n\n#### 回调函数\n\n回调函数是异步编程最基本的方法\n\n回调函数的优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合（Coupling），使得程序结构混乱、流程难以追踪（尤其是回调函数嵌套的情况），而且每个任务只能指定一个回调函数。\n\n#### 事件监听\n\n另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。\n\n这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以「去耦合」（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。\n\n#### 发布/订阅\n\n“事件”完全可以理解成”信号”，如果存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式“（publish-subscribe pattern），又称”观察者模式“（observer pattern）。\n\n这个模式有多种实现，下面采用的是Ben Alman的Tiny Pub/Sub，这是jQuery的一个插件。\n\n首先，f2向”信号中心”jQuery订阅”done”信号。\n\n```js\njQuery.subscribe(\"done\", f2);\n```\n\n然后，f1进行如下改写：\n\n```js\nfunction f1(){\n\tsetTimeout(function () {\n\t\t// f1的任务代码\n\t\tjQuery.publish(\"done\");\n\t}, 1000);\n}\n```\njQuery.publish(“done”)的意思是，f1执行完成后，向”信号中心”jQuery发布”done”信号，从而引发f2的执行。\n\nf2完成执行后，也可以取消订阅（unsubscribe）。\n\n```js\njQuery.unsubscribe(\"done\", f2);\n```\n这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。\n\n### 异步操作的流程控制\n\n经历回调函数嵌套、串行执行、并行执行到串行与并行的结合\n\n所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行n个异步任务。这样就避免了过分占用系统资源。\n\n### Promise 对象\n\n`Promise` 对象是 CommonJS 工作组提出的一种规范，目的是为异步操作提供统一接口。\n\n它的思想是，每一个异步任务立刻返回一个 `Promise` 对象，由于是立刻返回，所以可以采用同步操作的流程。这个 `Promises` 对象有一个 `then` 方法，允许指定回调函数，在异步任务完成后调用。\n\n前面说过，Promise接口的基本思想是，异步任务返回一个Promise对象。\n\nPromise对象只有三种状态。\n\n异步操作「未完成」（pending）、异步操作 「已完成」（resolved，又称fulfilled）、异步操作「失败」（rejected）\n\n三种状态的变化途径也只有两种\n\n未完成到成功、未完成到失败\n\n变化只能发生一次，异步操作成功，Promise对象传回一个值，状态变为 `resolved`，异步操作失败，Promise对象抛出一个错误，状态变为 `rejected`。\n\n```js\npo.then(step1)\n  .then(step2)\n  .then(step3)\n  .then(\n    console.log,\n    console.error\n  )\n```\n\n`po`的状态一旦变为 `resolved` 就调用下一个 `then` 中的方法，依次进行。`console.log` 这个方法只显示 `step3` 的返回值，而 `console.error` 会显示 `step1` 、 `step2` 、 `step3` 中的任意一个错误。因为假定 `step1` 执行出错，这时 `step2` `step3` 就不会再执行下去，然后 Promise 就会**寻找接下来第一个操作失败的回调函数**\n\nPromise 对象的例子\n\n```js\nvar promise = new Promise(function(resolve,reject){\n  //异步操作的代码\n  if(//异步操作成功){\n    resolve(value);\n  }else{\n    reject(error);\n  }\n})\n```\n\n#### 用法辨析\n\n`finalHandler` 回调函数的参数，是 `doSomethingElse` 函数的运行结果\n\n```js\ndoSomething().then(function () {\n  return doSomethingElse();\n}).then(finalHandler);\n```\n\n`findlHandler` 回调函数的参数是 `undefined`\n\n```js\ndoSomething().then(function () {\n  doSomethingElse();\n  return;\n}).then(finalHandler);\n```\n\n`finalHandler` 回调函数的参数是 `doSomethingElse` 函数的返回值\n\n```js\ndoSomething().then(doSomethingElse())\n  .then(finalHandler);\n```\n\n`doSomethingElse` 的参数是 `doSomething` 的返回值\n\n```\ndoSomething().then(doSomethingElse)\n  .then(finalHandler);\n```\n\n### Promise 应用\n\n#### 加载图片\n\n```js\nvar preloadImage = function(path){\n  return new Promise(function(resolve,reject){\n    var img = new Image();\n    img.onload = resolve;\n    img.error = reject;\n    img.src = path;\n  })\n}\n```\n\n#### Ajax 操作\n\n```js\nfunction search(term) {\n  var url = 'http://example.com/search?q=' + term;\n  var xhr = new XMLHttpRequest();\n  var result;\n\n  var p = new Promise(function (resolve, reject) {\n    xhr.open('GET', url, true);\n    xhr.onload = function (e) {\n      if (this.status === 200) {\n        result = JSON.parse(this.responseText);\n        resolve(result);\n      }\n    };\n    xhr.onerror = function (e) {\n      reject(e);\n    };\n    xhr.send();\n  });\n\n  return p;\n}\n\nsearch(\"Hello World\").then(console.log, console.error);\n```\n\n#### 小结\n\nPromise对象的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它的一整套接口，可以实现许多强大的功能，比如为多个异步操作部署一个回调函数、为多个回调函数中抛出的错误统一指定处理方法等等。\n\n而且，它还有一个前面三种方法都没有的好处：如果一个任务已经完成，再添加回调函数，该回调函数会立即执行。所以，你不用担心是否错过了某个事件或信号。这种方法的缺点就是，编写和理解都相对比较难。\n\n## 严格模式\n\n### 设计目的\n\n- 明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。\n- 增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。\n- 提高编译器效率，增加运行速度。\n- 为未来新版本的 JavaScript 语法做好铺垫。\n\n### 特点\n\n在文件头或者函数内部添加 `use strict` 即可开启严格模式。\n\n```html\n<script>\n'use strict'\n//严格模式\n</script>\n\n<script>\n//正常模式\n</script>\n```\n\n```js\n//正常模式\n'use strict'\n// 严格模式\n```\n\n有的时候需要合并不同的脚本，严格模式的脚本在前，则合并的脚本都是严格模式，如果正常的脚本在前，则合并后都是正常模式的脚本，但是这两种情况都是错误的，这时可以考虑把整个脚本放在一个立即执行的函数之中\n\n### 显示报错\n\nhttp://javascript.ruanyifeng.com/advanced/strict.html\n\n","tags":["ES5"],"categories":["Note"]},{"title":"LeanJs「 ES5 」-- 面向对象编程","url":"%2F2018%2F01%2F25%2FLeanJS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F","content":"\n![Js](LeanJS面向对象编程/js.png)\n\n<!--more-->\n\n## 构造函数与 new 命令\n\n面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。\n\n**对象是单个实物的抽象**\n\n一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。\n\n**对象是一个容器，封装了属性（property）和方法（method）**\n\n属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。\n\n### new \n\n```js\nvar Vehicle = function () {\n  this.price = 1000;\n};\n\nvar v = new Vehicle();\nv.price // 1000\n```\n\n使用 `new` 命令时，根据需要，构造函数也可以接受参数。\n\n```js\nvar Vehicle = function (p) {\n  this.price = p;\n};\n\nvar v = new Vehicle(500);\n```\n\n`new` 命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的。\n\n```js\nvar v = new Vehicle();\nvar v = new Vehicle;\n```\n\n**注意**\n\n`new` 必须要使用,不使用 `new` 就不会产生实例对象，此时的 `this` 就会指向全局对象\n\n```js\nvar Vehicle = function (){\n  this.price = 1000;\n};\n\nvar v = Vehicle();\nv.price\n// Uncaught TypeError: Cannot read property 'price' of undefined\n\nprice\n// 1000\n```\n\n### new 的原理\n\n- 创建一个空对象，作为将要返回的对象实例\n- 将这个空对象的原型，指向构造函数的prototype属性\n- 将这个空对象赋值给函数内部的this关键字\n- 开始执行构造函数内部的代码\n\n也就是说，构造函数内部，`this` 指的是一个新生成的空对象，所有针对 `this` 的操作，都会发生在这个空对象上。构造函数之所以叫「构造函数」，就是说这个函数的目的，就是操作一个空对象（即 `this` 对象），将其「构造」为需要的样子。\n\n如果构造函数内部有 `return` 语句，而且 `return` 后面跟着一个对象，`new` 命令会返回 `return` 语句指定的对象；否则，就会不管 `return`语句，返回 `this` 对象。\n\n但是，如果 `return` 语句返回的是一个跟 `this` 无关的新对象，`new` 命令会返回这个新对象，而不是 `this` 对象。这一点需要特别引起注意。\n```js\nvar Vehicle = function (){\n  this.price = 1000;\n  return { price: 2000 };\n};\n\n(new Vehicle()).price\n// 2000\n```\n上面代码中，构造函数 `Vehicle` 的 `return` 语句，返回的是一个新对象。**`new` 命令会返回这个对象，而不是 `this` 对象**。\n\n**另一方面，如果对普通函数（内部没有 `this` 关键字的函数）使用 `new` 命令，则会返回一个空对象**。\n```js\nfunction getMessage() {\n  return 'this is a message';\n}\n\nvar msg = new getMessage();\n\nmsg // {}\ntypeof msg // \"object\"\n```\n上面代码中，`getMessage` 是一个普通函数，返回一个字符串。对它使用 `new` 命令，会得到一个空对象。这是因为 `new` 命令总是返回一个对象，要么是实例对象，要么是 `return` 语句指定的对象。本例中，`return` 语句返回的是字符串，所以 `new` 命令就**忽略了该语句**。\n\n### new.target\n\n函数内部可以使用 `new.target` 属性。如果当前函数是 `new` 命令调用，`new.target` 指向当前函数，否则为 `undefined`。\n```js\nfunction f() {\n  console.log(new.target === f);\n}\n\nf() // false\nnew f() // true\n```\n使用这个属性，可以判断函数调用的时候，是否使用 `new` 命令。\n```js\nfunction f() {\n  if (!new.target) {\n    throw new Error('请使用 new 命令调用！');\n  }\n  // ...\n}\n\nf() // Uncaught Error: 请使用 new 命令调用！\n```\n上面代码中，构造函数 `f` 调用时，没有使用 `new` 命令，就抛出一个错误。\n\n### Object.create()\n\n构造函数作为模板，可以生成实例对象。但是，有时只能拿到实例对象，而该对象根本就不是由构造函数生成的，这时可以使用 `Object.create()` 方法，直接以某个实例对象作为模板，生成一个新的实例对象。\n```js\nvar person1 = {\n  name: '张三',\n  age: 38,\n  greeting: function() {\n    console.log('Hi! I\\'m ' + this.name + '.');\n  }\n};\n\nvar person2 = Object.create(person1);\n\nperson2.name // 张三\nperson2.greeting() // Hi! I'm 张三.\n```\n\n## this\n\n`this` 总是返回一个对象，就是返回属性和方法「当前」所在的对象\n\n由于对象的属性和可以赋给另一个对象，所以相同属性所在的当前对象是可变的，即 `this` 的指向是可以改变的\n\n```js\nfunction printf(){\n  return this.name;\n}\n\nvar A = {\n  name : 'Hutchins',\n  print : printf\n}\n\nvar B = {\n  name : 'zhangsan',\n  print : printf\n}\n\nA.print() //'Hutchins'\nB.print() //'zhangsan'\n```\n\n在 `printf` 中使用了 `this` 关键字，随着 `printf` 所在的当前对象的不同，`this` 的指向也不同\n\n只要函数被赋给另一个变量，`this` 的指向也会发生改变\n\n```js\nvar A = {\n  name: '张三',\n  describe: function () {\n    return '姓名：'+ this.name;\n  }\n};\n\nvar name = '李四';\nvar f = A.describe;\nf() // \"姓名：李四\"\n```\n\n`A.describe` 被赋值给 `f` ，**内部的 `this` 就会指向 `f` 运行时所在的对象**(本例是顶层对象)\n\n### 多层对象\n\n如果某个方法位于多层对象的内部，这时 `this` 只是指向当前一层的对象，而不会继承更上面的层。\n\n```js\nvar a = {\n  p: 'Hello',\n  b: {\n    m: function() {\n      console.log(this);//b{..}\n      console.log(this.p);\n    }\n  }\n};\n\na.b.m() // undefined\n```\n\n`a.b.m` 方法在 `a` 对象的第二层，该方法内部的 `this` 不是指向 `a` ，而是指向 `a.b` 。这是因为实际执行的是下面的代码。\n\n```js\nvar b = {\n  m: function() {\n   console.log(this.p);\n  }\n};\n\nvar a = {\n  p: 'Hello',\n  b: b\n};\n\n(a.b).m() // 等同于 b.m()\n```\n\n如果这时将嵌套对象内部的方法赋值给一个变量，`this` 依然会指向全局对象。\n\n```js\nvar a = {\n  b: {\n    m: function() {\n      console.log(this.p);\n    },\n    p: 'Hello'\n  }\n};\n\nvar hello = a.b.m;\nhello() // undefined\n```\n\n上面代码中，`m` 是多层对象内部的一个方法。为求简便，将其赋值给 `hello` 变量，结果调用时，`this` 指向了顶层对象。为了避免这个问题，可以只将 `m` 所在的对象赋值给 `hello`，这样调用时，`this` 的指向就不会变。\n\n```js\nvar hello = a.b;\nhello.m() // Hello\n```\n\n### 避免多层this\n\n由于 `this` 的指向是不确定的，所以切勿在函数中包含多层的 `this`。\n\n```js\nvar o = {\n  f1: function () {\n    console.log(this);\n    var f2 = function () {\n      console.log(this);\n    }();\n  }\n}\n\no.f1()\n// Object\n// Window\n```\n\n上面代码包含两层 `this` ，结果运行后，第一层指向该对象，第二层指向全局对象\n\n一个解决方法是在第二层改用一个指向外层 `this` 的变量。\n\n```js\nvar o = {\n  f1: function() {\n    console.log(this);\n    var that = this;\n    var f2 = function() {\n      console.log(that);\n    }();\n  }\n}\n\no.f1()\n// Object\n// Object\n```\n\n上面代码定义了变量 `that` ，固定指向外层的 `this` ，然后在内层使用 `that`，就不会发生 `this` 指向的改变。\n\n### 避免数组处理方法中的this\n\n数组的 `map` 和 `foreach` 方法，允许提供一个函数作为参数。这个函数内部不应该使用 `this`。\n```js\nvar o = {\n  v: 'hello',\n  p: [ 'a1', 'a2' ],\n  f: function f() {\n    this.p.forEach(function (item) {\n      console.log(this.v + ' ' + item);\n    });\n  }\n}\n\no.f()\n// undefined a1\n// undefined a2\n```\n\n上面代码中，`foreach` 方法的回调函数中的 `this` ，其实是指向 `window` 对象，因此取不到 `o.v` 的值。原因跟上一段的多层 `this` 是一样的，就是内层的 `this` 不指向外部，而指向**顶层对象**。\n\n解决这个问题的一种方法，是使用中间变量。\n```js\nvar o = {\n  v: 'hello',\n  p: [ 'a1', 'a2' ],\n  f: function f() {\n    var that = this;\n    this.p.forEach(function (item) {\n      console.log(that.v+' '+item);\n    });\n  }\n}\n\no.f()\n// hello a1\n// hello a2\n```\n另一种方法是将 `this` 当作 `foreach` 方法的第二个参数，固定它的运行环境。\n\n```js\nvar o = {\n  v: 'hello',\n  p: [ 'a1', 'a2' ],\n  f: function f() {\n    this.p.forEach(function (item) {\n      console.log(this.v + ' ' + item);\n    }, this);\n  }\n}\n\no.f()\n// hello a1\n// hello a2\n```\n\n### 绑定this的方法\n\n#### function.prototype.call()\n\n`call` 方法的参数，应该是一个对象。如果参数为空、`null` 和 `undefined`，则默认传入全局对象。\n\n```js\nvar n = 123;\nvar obj = { n: 456 };\n\nfunction a() {\n  console.log(this.n);\n}\n\na.call() // 123\na.call(null) // 123\na.call(undefined) // 123\na.call(window) // 123\na.call(obj) // 456\n```\n\n上面代码中，`a` 函数中的 `this` 关键字，如果指向全局对象，返回结果为 `123` 。如果使用 `call` 方法将 `this` 关键字指向 `obj` 对象，返回结果为 `456` 。可以看到，如果 `call` 方法没有参数，或者参数为 `null` 或 `undefined` ，则等同于指向全局对象。\n\n如果 `call` 方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入 `call` 方法。\n\n```js\nvar f = function () {\n  return this;\n};\n\nf.call(5)\n// Number {[[PrimitiveValue]]: 5}\n```\n\n上面代码中， `call` 的参数为5，不是对象，会被自动转成包装对象（Number的实例），绑定 `f` 内部的 `this`。\n\n`call` 方法还可以接受多个参数。\n\n```js\nfunc.call(thisValue, arg1, arg2, ...)\n```\n\n`call` 的第一个参数就是 `this` 所要指向的那个对象，后面的参数则是函数调用时所需的参数。\n\n`call` 方法的一个使用是调用对象的原始方法\n\n```js\nvar num = 6;\nnum.toString()//\"6\"\n\nObject.prototype.toString.call(num)//\"[object Number]\"\n```\n\n#### function.prototype.apply()\n\n`apply` 方法的作用与 `call` 方法类似，也是改变 `this` 指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。\n\n```js\nfunc.apply(thisValue, [arg1, arg2, ...])\n```\n\n**将数组的空元素变为 `undefined`**\n\n通过 `apply` 方法，利用 `Array` 构造函数将数组的空元素变成 `undefined`。\n\n```js\nArray.apply(null, [\"a\",,\"b\"])\n// [ 'a', undefined, 'b' ]\n```\n\n空元素与 `undefined` 的差别在于，数组的 `forEach` 方法会跳过空元素，但是不会跳过 `undefined` 。因此，遍历内部元素的时候，会得到不同的结果。\n\n```js\nvar a = ['a', , 'b'];\n\nfunction print(i) {\n  console.log(i);\n}\n\na.forEach(print)\n// a\n// b\n\nArray.apply(null, a).forEach(print)\n// a\n// undefined\n// b\n```\n\n**类数组转换**\n\n```js\nvar arr = Array.prototype.slice.call(arrayLike);\n```\n\n#### function.prototype.bind()\n\n`bind` 方法用于将函数体内的 `this` 绑定到某个对象，然后返回一个新函数。 \n\n`bind` 比 `call` 方法和 `apply` 方法更进一步的是，除了绑定 `this` 以外，还可以绑定原函数的参数。\n```js\nvar add = function (x, y) {\n  return x * this.m + y * this.n;\n}\n\nvar obj = {\n  m: 2,\n  n: 2\n};\n\nvar newAdd = add.bind(obj, 5);\n\nnewAdd(5)\n// 20\n```\n\n上面代码中，`bind` 方法除了绑定 `this` 对象，还将 `add` 函数的第一个参数 `x` 绑定成 `5` ，然后返回一个新函数 `newAdd` ，这个函数只要再接受一个参数 `y` 就能运行了。\n\n## prototype 对象\n\nJavaScript 继承机制的设计就是，原型的所有属性和方法，都能被子对象共享。\n\n```js\nfunction Car(name){\n  this.name = name;\n}\nCar.prototype.speed = 70;\n\nvar car1 = new Car('baoma');\nvar car2 = new Car('benchi');\ncar1.speed // 70\ncar2.speed // 70\n```\n\n在原型上定义了一个 `speed` 属性，所有 `Car` 实例对象都有这一个属性，如果实例对象也定义 `speed` 属性，那么就会有一个其自身的 `speed` 属性，不会影响其它原型上的属性和其它实例对象\n\n### 原型链\n\n所有对象的原型都可以追溯到 `Object.prototype` ，而 `Object.prototype` 的原型就是没有任何属性和任何方法的 `null` 对象。而 `null` 没有自己的原型\n\n「原型链」的作用是，读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的 `Object.prototype` 还是找不到，则返回 `undefined`。\n\n如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做「覆盖」（overriding）。\n\n需要注意的是，一级级向上，在原型链寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。\n\n如果让某个函数的 `prototype` 指向一个数组，就意味着这个函数可以当作数组的构造函数，因为它生成的实例对象都可以调用数组的属性和方法\n\n```js\nvar MyArray = function(){};\n\nMyArray.prototype = new Array();\n\nvar mine = new myArray()\nmine.push(1,2,3);\n\nmine.length // 3\nmine instanceof Array // true\n```\n\n### constructor\n\n`prototype` 对象有一个 `constructor` 属性，默认指向 `prototype` 对象所在的构造函数。\n\n由于 `constructor` 属性定义在 `prototype` 对象上面，意味着可以被所有实例对象继承\n\n```js\nfunction P(){};\nvar p = new P();\n\nP.prototype.constructor === p.constructor//true\n```\n\n但是实例对象自身是没有 `constructor` 属性\n\n```js\np.hasOwnProperty('constructor')//false\n```\n\n通过 `constructor` 的 `name` 属性可以获得构造函数的名字\n\n```js\np.constructor.name // 'P'\n```\n\n`constructor` 属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改 `constructor` 属性，防止引用的时候出错。\n\n修改原型对象时，一般要同时校正 `constructor` 属性的指向。\n\n```js\n// 避免这种写法\nC.prototype = {\n  method1: function (...) { ... },\n  // ...\n};\n\n// 较好的写法\nC.prototype = {\n  constructor: C,\n  method1: function (...) { ... },\n  // ...\n};\n\n// 更好好的写法\nC.prototype.method1 = function (...) { ... };\n```\n\n### instanceof\n\n`instanceof` 运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上。\n\n`instanceof` 的原理是检查原型链，对于那些不存在原型链的对象，就无法判断。例如 `null`\n\n`instanceof` 运算符只能用于对象，不适用原始类型的值。\n\n对于 `undefined` 和 `null` ，`instanceOf` 运算符总是返回 `false` 。\n\n### Object.getPrototypeOf()\n\n`Object.getPrototypeOf` 方法返回一个对象的原型。这是获取原型对象的标准方法。\n\n```js\nObject.getPrototypeOf({}) === Object.prototype\n```\n\n### Object.setPrototypeOf()\n\n`Object.setPrototypeOf` 方法可以为现有对象设置原型，返回一个新对象。\n\n`Object.setPrototypeOf` 方法接受两个参数，第一个是现有对象，第二个是原型对象。\n\n`new` 命令通过构造函数新建实例对象，实质就是将实例对象的原型，指向构造函数的 `prototype` 属性，然后在实例对象上执行构造函数。\n\n```js\nvar F = function () {\n  this.foo = 'bar';\n};\n\nvar f = new F();\n\n// 等同于\nvar f = Object.setPrototypeOf({}, F.prototype);\nF.call(f);//绑定this\n```\n\n### Object.create()\n\n```js\nif (typeof Object.create !== 'function') {\n  Object.create = function (obj) {\n    function F() {}\n    F.prototype = obj;\n    return new F();\n  };\n}\n```\n\n`Object.create` 方法的实质是新建一个构造函数 `F` ，然后让 `F.prototype` 属性指向参数对象 `obj` ，最后返回一个 `F` 的实例，从而实现让该实例继承 `obj` 的属性\n\n使用 `Object.create` 方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。\n\n```js\nObject.create()\n// TypeError: Object prototype may only be an Object or null\n\nObject.create(123)\n// TypeError: Object prototype may only be an Object or null\n```\n\n`object.create` 方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。\n\n```js\nvar obj1 = { p: 1 };\nvar obj2 = Object.create(obj1);\n\nobj1.p = 2;\nobj2.p\n// 2\n```\n\n上面代码中，修改对象原型 `obj1` 会影响到新生成的实例对象 `obj2`。\n\n除了对象的原型，`Object.create` 方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。\n\n```js\nvar obj = Object.create({}, {\n  p1: {\n    value: 123,\n    enumerable: true,\n    configurable: true,\n    writable: true,\n  },\n  p2: {\n    value: 'abc',\n    enumerable: true,\n    configurable: true,\n    writable: true,\n  }\n});\n\n// 等同于\nvar obj = Object.create({});\nobj.p1 = 123;\nobj.p2 = 'abc';\n```\n\n`Object.create` 方法生成的对象，继承了它的原型对象的构造函数。\n\n```js\nfunction A() {}\nvar a = new A();\nvar b = Object.create(a);\n\nb.constructor === A // true\nb instanceof A // true\n```\n\n上面代码中，`b` 对象的原型是 `a` 对象，因此继承了 `a` 对象的构造函数 `A`。\n\n### Object.prototype.isPrototypeOf()\n\n对象实例的 `isPrototypeOf` 方法，用来判断一个对象是否是另一个对象的原型。\n\n只要某个对象处在原型链上，`isPrototypeOf` 都返回 `true`。\n\n## Object 对象与继承\n\n### Object.getOwnPropertyNames()\n\n`Object.getOwnPropertyNames` 方法返回一个数组，**成员是对象本身的所有属性的键名，不包含继承的属性键名**，而且会将不可枚举的也一同获取到\n\n### Object.keys()\n\n`Object.keys` 也是返回一个数组，与 `Object.getOwnPropertyNames` 不同的是，**只能枚举出可枚举的自身属性**\n\n### Object.prototype.hasOwnProperty()\n\n对象实例的 `hasOwnProperty` 方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。\n\n### in 运算符和 for…in 循环\n\n`in` 运算符返回一个布尔值，表示一个对象是否具有某个属性。**它不区分该属性是对象自身的属性，还是继承的属性**。\n\n`for...in`会枚举出所有**可枚举的属性，不论是自身的还是继承的**\n\n## 面向对象编程模式\n\n### 构造函数的继承\n\n一个构造函数继承另一个构造函数\n\n```js\nfunction Shape() {\n  this.x = 0;\n  this.y = 0;\n}\nShape.prototype.move = function(x,y){\n  this.x+=x;\n  this.y+=y;\n  console.log('shape moved');\n}\n```\n\n然后用 `Rectange` 构造函数继承 `Shape`\n\n```js\n//第一步 子类构造函数继承父类的实例 \n//就相当于在子类构造函数中用子类this调用父类构造函数\nfunction Rectange(){\n  Shape.call(this);\n}\n\n//另一种写法\nfunction Rectange(){\n  this.base = Shape;\n  this.base();\n}\n\n//子类继承父类的原型\nRectange.prototype = Object.create(Shape.prototype);\nRectange.prototype.constructor = Rectange;\n```\n\n在此处 `Rectange.prototype` 不能直接等于 `Shape.prototype` ，要等于 `Object.create(Shape.prototype)`，相当于等于 `Shape.prototype`的一个副本，直接等于的话后面在修改 `Rectange.prototype` 的时候会连 `Shape.prototype` 一同修改掉\n\n也可以仅实现单个方法的继承\n\n```js\nRectange.prototype.printf = function(){\n  Shape.prototype.printf.call(this);\n}\n```\n\n[关于模块，多重继承，封装私有变量](http://javascript.ruanyifeng.com/oop/pattern.html)\n\n\n\n\n\n\n\n\n","tags":["ES5"],"categories":["Note"]},{"title":"LeanJs「 ES5 」-- 标准库","url":"%2F2018%2F01%2F24%2FLearnJS%E6%A0%87%E5%87%86%E5%BA%93%2F","content":"\n![Js](LearnJS标准库/js.png)\n\n<!--more-->\n\n## Object\n\n### Object()\n\n`Object()`本身是一个函数，可以将任意值转换为对象\n\n```js\nvar obj = Object();\n// 等同于\nvar obj = Object(undefined);\nvar obj = Object(null);\n```\n\n如果要被转换的值为原始类型，`Object`会将其转换成对应的包装类型，如果要转换的值是对象，它总是返回该对象，即不用转换\n\n```js\nvar obj = Object(1);\nobj instanceof Object // true\nobj instanceof Number // true\n\nvar obj = Object('foo');\nobj instanceof Object // true\nobj instanceof String // true\n\nvar obj = Object(true);\nobj instanceof Object // true\nobj instanceof Boolean // true\n```\n\n因此可以用`Object`来判断是否为对象\n\n```js\nvar arr = [];\nvar obj = Object(arr); // 返回原数组\nobj === arr // true\n\nvar value = {};\nvar obj = Object(value) // 返回原对象\nobj === value // true\n\nvar fn = function () {};\nvar obj = Object(fn); // 返回原函数\nobj === fn // true\n\nfunction isObj(value){\n  return value === Object(value);\n}\n```\n\n### Object构造函数\n\n```js\nvar obj = new Object();\n\n//等同于\n\nvar obj = {};\n```\n\n`new Object(value)`中也可以传入值，和`Object(value)`相同，只不过在语义上有所差别。前者表示生成一个对象，它的值为`value`，后者表示将`value`转换为对象\n\n### 静态方法\n\n部署在`Object`对象自身的方法\n\n#### Object.keys() && Object.getOwnPropertyNames()\n\n`Object.keys`方法和`Object.getOwnPropertyNames`方法都用来遍历对象的属性。\n\n`Object.keys()`和`Object.getOwnPropertyNames()`方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名。\n\n`Object.getOwnPropertyNames()`还可以遍历出不可枚举的属性，`Object.keys()`不可以\n\n```js\nvar a = ['Hello', 'World'];\n\nObject.keys(a) // [\"0\", \"1\"]\nObject.getOwnPropertyNames(a) // [\"0\", \"1\", \"length\"]\n```\n\n#### Object.prototype.toString\n\n`toString`方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。\n\n数组、字符串、函数、Date对象都分别部署了自定义的`toString`方法\n\n可以用来准确的判断数据类型\n\n```js\nObject.prototype.toString.call(value)\n```\n\n这样可以任意调用`Object.prototype.toString`方法\n\n各种类型的返回结果\n\n```\n数值：返回[object Number]。\n字符串：返回[object String]。\n布尔值：返回[object Boolean]。\nundefined：返回[object Undefined]。\nnull：返回[object Null]。\n数组：返回[object Array]。\narguments 对象：返回[object Arguments]。\n函数：返回[object Function]。\nError 对象：返回[object Error]。\nDate 对象：返回[object Date]。\nRegExp 对象：返回[object RegExp]。\n其他对象：返回[object Object]。\n```\n\n利用这个可以写出比`typeof`更加准确的类型判断函数\n\n```js\nfunction checkType(value){\n  var s = Object.prototype.toString.call(value);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n}\n```\n\nJavaScript中`match`函数方法返回的数组有三个属性：`input`、`index`和`lastIndex`。`Input` 属性包含整个的被查找字符串。`Index` 属性包含了在整个被查找字符串中匹配的子字符串的位置。`LastIndex` 属性包含了最后一次匹配中最后一个字符的下一个位置。如果没有设置全局标志 `g`，数组的0元素包含整个匹配，而第 1 到 n 元素包含了匹配中曾出现过的任一个**子匹配(在其中用过圆括号)**。这相当于没有设置全局标志的 `exec` 方法。如果设置了全局标志，元素0到n中包含所有匹配\n\n#### Object.prototype.toLocaleString\n\n返回值和`Object.prototype.toString`相同，用来留一个出口返回针对地域的某些特定的值.\n\n## Array对象\n\n### 创建\n\n```js\nvar arr = [];\n\nvar arr = new Array()\n\nvar arr = new Array(3);\narr.length // 3\n\narr[0] // undefined\narr[1] // undefined\narr[2] // undefined\n\n0 in arr // false\n1 in arr // false\n2 in arr // false\n```\n\n注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回`undefined`，但实际上该位置没有任何值。虽然可以取到`length`属性，但是取不到键名。\n\n### 方法\n\n#### 改变原数组\n\npop\n\n`pop`方法用于删除数组的最后一个元素，并返回该元素\n\n```js\n[].pop()//undefined\n```\n\npush\n\n`push`方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度\n\nshift\n\n`shift`方法用于删除数组的第一个元素，并返回该元素\n\nunshift\n\n`unshift`方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度\n\nreverse\n\n`reverse`方法用于颠倒数组中元素的顺序，返回改变后的数组\n\nsplice\n\n`splice`方法用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素\n\n```js\narr.splice(index, count_to_remove, addElement1, addElement2, ...)\n```\n\nsort\n\n`sort`方法对数组成员进行排序，默认是按照字典顺序排序.\n\n```js\n[\n  { name: \"张三\", age: 30 },\n  { name: \"李四\", age: 24 },\n  { name: \"王五\", age: 28  }\n].sort(function (o1, o2) {\n  return o1.age - o2.age;\n})\n// [\n//   { name: \"李四\", age: 24 },\n//   { name: \"王五\", age: 28 },\n//   { name: \"张三\", age: 30 }\n// ]\n```\n\n#### 不改变原数组\n\njoin\n\n`join`方法以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。\n\n```js\n[undefined,null].join('#')//#\n```\n\n如果数组成员是`undefined`，`null`，或空位会被转换成空字符串\n\nconcat\n\n`concat`方法用于多个数组的合并。它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组.\n\nslice\n\n`slice`方法用于提取原数组的一部分，返回一个新数组.\n\n```js\narr.slice(start_index,end_index);//左闭右开\n```\n\n也可以用来将类数组转换成数组\n\n```js\nArray.prototype.slice.call(arrayLike);\n```\n\nmap\n\n`map`方法对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。\n\n```js\narr.map(function(item,index,arr){\n  //当前成员,当前位置,数组本身\n},arr)//花括号后的arr表示回调函数的this指向\n//只有item是必须存在的\n```\n\n`map`方法不跳过`undefined`和`null`，但是会跳过空位，碰到空位不执行任何函数，直接跳过.\n\nforEach\n\n`forEach`方法与`map`方法很相似，也是遍历数组的所有成员，执行某种操作，但是`forEach`方法一般不返回值，只用来操作数据。如果需要有返回值，一般使用`map`方法。\n\n```js\narr.forEach(function(item,index,arr){\n  //当前成员,当前位置,数组本身\n},arr)//花括号后的arr表示回调函数的this指向\n//只有item是必须存在的\n```\n\nfilter\n\n`filter`方法的参数是一个函数，所有数组成员依次执行该函数，返回结果为`true`的成员组成一个新数组返回\n\n```js\narr.filter(function(item,index,arr){\n  //当前成员,当前位置,数组本身\n},arr)//花括号后的arr表示回调函数的this指向\n//只有item是必须存在的\n```\n\nsome\n\n`some`方法是只要有一个数组成员的返回值是`true`，则整个`some`方法的返回值就是`true`，否则`false`。\n\n```js\narr.some(function(item,index,arr){\n  //当前成员,当前位置,数组本身\n},arr)//花括号后的arr表示回调函数的this指向\n//只有item是必须存在的\n```\n\nevery\n\n`every`方法则是所有数组成员的返回值都是`true`，才返回`true`，否则`false`。\n\n```js\narr.some(function(item,index,arr){\n  //当前成员,当前位置,数组本身\n},arr)//花括号后的arr表示回调函数的this指向\n//只有item是必须存在的\n```\n\nreduce && reduceRight\n\n`reduce`方法和`reduceRight`方法依次处理数组的每个成员，最终累计为一个值。\n\n它们的差别是，`reduce`是从左到右处理（从第一个成员到最后一个成员），`reduceRight`则是从右到左（从最后一个成员到第一个成员），其他完全一样。\n\n这两个方法的第一个参数都是一个函数。该函数接受以下四个参数。\n\n```\n累积变量，默认为数组的第一个成员\n当前变量，默认为数组的第二个成员\n当前位置（从0开始）\n原数组\n```\n\n这四个参数之中，只有前两个是必须的，后两个则是可选的。\n\nindexOf && lastIndexOf\n\n`indexOf`方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。\n\n`lastIndexOf`方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。\n\n`indexOf`方法还可以接受第二个参数，表示搜索的开始位置。\n\n如果数组中包含`NaN`，这两个方法不适用，即无法确定数组成员是否包含`NaN`\n\n这是因为这两个方法内部，使用严格相等运算符`===`进行比较，而`NaN`是唯一一个不等于自身的值\n\n## 包装对象\n\n所谓「包装对象」，就是分别与数值、字符串、布尔值相对应的`Number`、`String`、`Boolean`三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。\n\n```js\nvar r = new Number(123);\ntypeof r //object\n```\n\n如果不作为构造函数调用（即调用不加`new`），是将其它类型转换为`number`,`string`,`boolean`\n\n### 原始类型的自动转换\n\n原始类型的值，可以自动当作对象调用，即调用各种对象的方法和参数。这时，JavaScript引擎会自动将原始类型的值转为包装对象，**在使用后立刻销毁**。\n\n因为立即销毁，所以这个临时对象是只读的，无法进行修改，所以无法添加新属性。\n\n```js\nvar str = 'abc';\nstr.length // 3\n\n// 等同于\nvar strObj = new String(str)\n// String {\n//   0: \"a\", 1: \"b\", 2: \"c\", length: 3, [[PrimitiveValue]]: \"abc\"\n// }\nstrObj.length // 3\n```\n\n`[[PrimitiveValue]]`保存字符串的原始值。这个`[[PrimitiveValue]]`内部属性，外部是无法调用，仅供`ValueOf`或`toString`这样的方法内部调用。\n\n### Boolean对象\n\n`false`对应的包装对象的实例,布尔运算结果是`true`\n\n```js\nif (new Boolean(false)) {\n  console.log('true');\n} // true\n\nif (new Boolean(false).valueOf()) {\n  console.log('true');\n} // 无输出\n```\n\n上面代码的第一个例子之所以得到`true`，是因为`false`对应的包装对象实例是一个**对象**，进行逻辑运算时，被自动转化成布尔值`true`（因为所有对象对应的布尔值都是`true`）。而实例的`valueOf`方法，则返回实例对应的原始值，本例为`false`。\n\n## Number\n\n### 属性\n\n```js\nNumber.POSITIVE_INFINITY：正的无限，指向Infinity。\nNumber.NEGATIVE_INFINITY：负的无限，指向-Infinity。\nNumber.NaN：表示非数值，指向 NaN。\nNumber.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。\nNumber.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。\nNumber.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。\nNumber.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。\n```\n\n### 方法\n\n#### toString\n\n接受参数可以转为相应进制的字符串\n\n```js\n(10).toString(2) // \"1010\"\n(10).toString(8) // \"12\"\n(10).toString(16) // \"a\"\n```\n\n#### toFixed\n\n`toFixed`方法的参数为指定的小数位数，有效范围为0到20，超出这个范围将抛出`RangeError`错误。\n\n#### toExponential\n\n`toExponential`方法的参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个`RangeError`。\n\n#### toPrecision\n\n`toExponential`方法的参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个`RangeError`。\n\n\n## String\n\n### String.fromCharCode\n\n该方法的参数是一系列`Unicode`码点，返回对应的字符串。\n\n该方法不支持`Unicode`码点大于`0xFFFF`的字符，即传入的参数不能大于`0xFFFF`。\n\n### charAt\n\n可以用下标代替，如果参数为负数，或大于等于字符串的长度，`charAt`返回空字符串。\n\n### charCodeAt\n\n`charCodeAt`方法返回给定位置字符的`Unicode`码点（十进制表示），相当于`String.fromCharCode()`的逆操作\n\n:exclamation: 注意\n\n如果没有任何参数，`charCodeAt`返回首字符的`Unicode`码点。\n\n`charCodeAt`方法返回的`Unicode`码点不大于`65536（0xFFFF）`，也就是说，只返回两个字节的字符的码点。如果遇到`Unicode`码点大于`65536`的字符，必需连续使用两次`charCodeAt`，不仅读入`charCodeAt(i)`，还要读入`charCodeAt(i+1)`，将两个16字节放在一起，才能得到准确的字符。\n\n如果参数为负数，或大于等于字符串的长度，`charCodeAt`返回`NaN`。\n\n### indexOf()，lastIndexOf()\n\n这两个方法用于确定一个字符串在另一个字符串中的位置，都返回一个整数，表示匹配开始的位置。如果返回`-1`，就表示不匹配。两者的区别在于，`indexOf`从字符串头部开始匹配，`lastIndexOf`从尾部开始匹配。\n\n### concat\n\n`concat`方法用于连接两个字符串，返回一个新字符串，不改变原字符串。\n\n### slice\n\n`slice`方法用于从原字符串取出子字符串并返回，不改变原字符串。\n\n它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。左闭右开\n\n如果参数是负值，表示从结尾开始倒数计算的位置，即该**负值加上字符串长度**。\n\n如果第一个参数大于第二个参数，slice方法返回一个空字符串。\n\n### substring\n\n`substring`方法用于从原字符串取出子字符串并返回，不改变原字符串\n\n`substring`方法的第一个参数表示子字符串的开始位置，第二个位置表示结束位置。\n\n如果第二个参数大于第一个参数，`substring`方法会自动更换两个参数的位置。\n\n如果参数是负数，`substring`方法会自动将负数转为0。\n\n不建议使用，优先使用`slice`\n\n### substr\n\n`substr`方法用于从原字符串取出子字符串并返回，不改变原字符串。\n\n`substr`方法的第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。\n\n如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。\n\n### trim\n\n`trim`方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串。\n\n该方法去除的不仅是空格，还包括制表符`\\t、\\v`、换行符`\\n`和回车符`\\r`。\n\n### toLowerCase()，toUpperCase()\n\n`toLowerCase`方法用于将一个字符串全部转为小写，`toUpperCase`则是全部转为大写。它们都返回一个新字符串，不改变原字符串。\n\n### localeCompare()\n\n`localeCompare`方法用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。\n\n### match\n\n`match`方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回`null`。\n\n返回数组还有`index`属性和`input`属性，分别表示匹配字符串开始的位置和原始字符串。\n\n### search\n\n`search`方法的用法等同于`match`，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。\n\n### replace\n\n`replace`方法用于替换匹配的子字符串，一般情况下只替换第一个匹配\n\n### split\n\n`split`方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。\n\n## Math\n\n### 属性\n\n```js\nMath.E：常数e。\nMath.LN2：2的自然对数。\nMath.LN10：10的自然对数。\nMath.LOG2E：以2为底的e的对数。\nMath.LOG10E：以10为底的e的对数。\nMath.PI：常数Pi。\nMath.SQRT1_2：0.5的平方根。\nMath.SQRT2：2的平方根。\n```\n\n### 方法\n\n```js\nMath.abs()：绝对值\nMath.ceil()：向上取整\nMath.floor()：向下取整\nMath.max()：最大值\nMath.min()：最小值\nMath.pow()：指数运算\nMath.sqrt()：平方根\nMath.log()：自然对数\nMath.exp()：e的指数\nMath.round()：四舍五入\nMath.random()：随机数 \n```\n\n#### Math.random\n\n返回任意长度的字符\n\n```js\nfunction random_str(length) {\n  var ALPHABET = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n  ALPHABET += 'abcdefghijklmnopqrstuvwxyz';\n  ALPHABET += '0123456789-_';\n  var str = '';\n  for (var i=0; i < length; ++i) {\n    var rand = Math.floor(Math.random() * ALPHABET.length);\n    str += ALPHABET.substring(rand, rand + 1);\n  }\n  return str;\n}\n\nrandom_str(6) // \"NdQKOr\"\n```\n\n### 三角函数的方法\n\n```js\nMath.sin()：返回参数的正弦\nMath.cos()：返回参数的余弦\nMath.tan()：返回参数的正切\nMath.asin()：返回参数的反正弦（弧度值）\nMath.acos()：返回参数的反余弦（弧度值）\nMath.atan()：返回参数的反正切（弧度值）\n```\n\n## Date\n\n### new Date()\n\n`Date`对象接受从`1970年1月1日00:00:00 UTC`开始计算的毫秒数作为参数。这意味着如果将`Unix`时间戳（单位为秒）作为参数，必须将`Unix`时间戳乘以`1000`。\n\n`Date`对象还接受一个日期字符串作为参数，返回所对应的时间。\n\n日期字符串的完整格式是`month day, year hours:minutes:seconds`，比如`December 25, 1995 13:30:00`。如果省略了小时、分钟或秒数，这些值会被设为0。\n\n注意，在ES5之中，如果日期采用连词线`-`格式分隔，且具有前导0，JavaScript会认为这是一个`ISO`格式的日期字符串，导致返回的时间是以`UTC`时区计算的。\n\n```js\nnew Date('2014-01-01')\n// Wed Jan 01 2014 08:00:00 GMT+0800 (CST)\n\nnew Date('2014-1-1')\n// Wed Jan 01 2014 00:00:00 GMT+0800 (CST)\n```\n\n上面代码中，日期字符串有没有前导0，返回的结果是不一样的。如果没有前导0，JavaScript引擎假设用户处于本地时区，所以本例返回0点0分。如果有前导0（即如果你以`ISO`格式表示日期），就假设用户处于格林尼治国际标准时的时区，所以返回8点0分。但是，ES6改变了这种做法，规定凡是没有指定时区的日期字符串，一律认定用户处于本地时区。\n\n总之，对于`YYYY-MM-DD`形式的字符串，JavaScript引擎可能会将其当作`ISO`格式来解析，采用格林尼治时区作为计时标准；而对于其他格式的日期字符串，一律视为非ISO格式，采用本地时区作为计时标准。\n\n```js\nnew Date('2014-12-11')\n// Thu Dec 11 2014 08:00:00 GMT+0800 (CST)\n\nnew Date('2014/12/11')\n// Thu Dec 11 2014 00:00:00 GMT+0800 (CST)\n```\n\n上面代码中，第一个日期字符串是ISO格式，第二个不是，导致生成的时间不一样。\n\n`Date`对象还可以接受多个整数作为参数，依次表示年、月、日、小时、分钟、秒和毫秒。如果采用这种格式，**最少需要提供两个参数（年和月）**，其他参数都是可选的，默认等于0。因为如果只使用「年」这一个参数，`Date`对象会将其解释为毫秒数。\n\n### 日期的运算\n\n类型转换时，`Date`对象的实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串。所以，两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。\n\n### Date对象的静态方法                                                                            \n#### Date.now\n\n`Date.now`方法返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）。\n\n```js\nDate.now() // 1364026285194\n```\n如果需要比毫秒更精确的时间，可以使用`window.performance.now()`。它提供页面加载到命令运行时的已经过去的时间，可以精确到千分之一毫秒。\n\n```js\nwindow.performance.now() // 21311140.415\n```\n\n#### Date.parse\n\n`Date.parse`方法用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数\n\n如果解析失败，返回`NaN`。\n\n#### Date.UTC\n\n默认情况下，`Date`对象返回的都是当前时区的时间。`Date.UTC`方法可以返回`UTC`时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。\n\n### Date实例对象\n\n#### to类方法\n\n```js\nDate.prototype.toString : 返回一个完整的日期字符串\nDate.prototype.toUTCString : 返回对应的UTC时间，也就是比北京时间晚8个小时。\nDate.prototype.toISOString : 方法返回对应时间的ISO8601写法\nDate.prototype.toJSON : 符合JSON格式的ISO格式的日期字符串，与toISOString方法的返回结果完全相同。\nDate.prototype.toDateString : 方法返回日期字符串。\nDate.prototype.toTimeString : 方法返回时间字符串。\nDate.prototype.toLocaleDateString : 方法返回一个字符串，代表日期的当地写法。\nDate.prototype.toLocaleTimeString : 方法返回一个字符串，代表时间的当地写法。\n```\n\n#### get类方法\n\n```js\ngetTime()：返回距离1970年1月1日00:00:00的毫秒数，等同于valueOf方法。\ngetDate()：返回实例对象对应每个月的几号（从1开始）。\ngetDay()：返回星期几，星期日为0，星期一为1，以此类推。\ngetYear()：返回距离1900的年数。\ngetFullYear()：返回四位的年份。\ngetMonth()：返回月份（0表示1月，11表示12月）。\ngetHours()：返回小时（0-23）。\ngetMilliseconds()：返回毫秒（0-999）。\ngetMinutes()：返回分钟（0-59）。\ngetSeconds()：返回秒（0-59）。\ngetTimezoneOffset()：返回当前时间与UTC的时区差异，以分钟表示，返回结果考虑到了夏令时因素。\n```\n\n返回对应的UTC时间\n\n```js\ngetUTCDate()\ngetUTCFullYear()\ngetUTCMonth()\ngetUTCDay()\ngetUTCHours()\ngetUTCMinutes()\ngetUTCSeconds()\ngetUTCMilliseconds()\n```\n\n#### set类\n\n```js\nsetDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。\nsetYear(year): 设置距离1900年的年数。\nsetFullYear(year [, month, date])：设置四位年份。\nsetHours(hour [, min, sec, ms])：设置小时（0-23）。\nsetMilliseconds()：设置毫秒（0-999）。\nsetMinutes(min [, sec, ms])：设置分钟（0-59）。\nsetMonth(month [, date])：设置月份（0-11）。\nsetSeconds(sec [, ms])：设置秒（0-59）。\nsetTime(milliseconds)：设置毫秒时间戳。\n```\n\n对应的UTC方法\n\n```js\nsetUTCDate()\nsetUTCFullYear()\nsetUTCHours()\nsetUTCMilliseconds()\nsetUTCMinutes()\nsetUTCMonth()\nsetUTCSeconds()\n```\n\n### valueOf\n\n`valueOf`方法返回实例对象距离1970年1月1日00:00:00 UTC对应的毫秒数，该方法等同于`getTime`方法。\n\n## RegExp对象\n\n正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用作按照“给定模式”匹配文本的工具。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。\n\n## JSON对象\n\n严格规定\n\n复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。\n\n简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和`null`（不能使用`NaN`,`Infinity`, `-Infinity`和`undefined`）。\n\n字符串必须使用双引号表示，不能使用单引号。\n\n对象的键名必须放在双引号里面。\n\n数组或对象最后一个成员的后面，不能加逗号。\n\n### JSON.stringify\n\n`JSON.stringify`方法用于将一个值转为字符串。该字符串符合`JSON`格式，并且可以被`JSON.parse`方法还原。\n\n```js\nvar arr = [undefined, function () {}];\nJSON.stringify(arr) // \"[null,null]\"\n```\n\n如果数组的成员是`undefined`、函数或 XML 对象，则这些值被转成`null`\n\n```js\nJSON.stringify(/foo/) // \"{}\"\n```\n\n正则对象会被转成空对象。\n\n`JSON.stringify`方法会忽略对象的不可遍历属性。\n\n`JSON.stringify`方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性\n\n```js\nvar obj = {\n  'prop1': 'value1',\n  'prop2': 'value2',\n  'prop3': 'value3'\n};\n\nvar selectedProperties = ['prop1', 'prop2'];\n\nJSON.stringify(obj, selectedProperties)\n// \"{\"prop1\":\"value1\",\"prop2\":\"value2\"}\"\n```\n\n这个类似「白名单」的数组，只对对象的属性有效，对数组无效。\n\n第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。\n\n```js\nfunction f(key, value) {\n  if (typeof value === \"number\") {\n    value = 2 * value;\n  }\n  return value;\n}\n\nJSON.stringify({ a: 1, b: 2 }, f)\n// '{\"a\": 2,\"b\": 4}'\n```\n\n`JSON.stringify`还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。\n\n### toJSON\n\n如果对象有自定义的`toJSON`方法，那么`JSON.stringify`会使用这个方法的返回值作为参数，而忽略原对象的其他属性。\n\n```js\nvar user = {\n  firstName: '三',\n  lastName: '张',\n  fullName: '张三',\t\n\n  toJSON: function () {\n    var data = {\n      firstName: this.firstName,\n      lastName: this.lastName\n    };\n    return data;\n  }\n};\n\nJSON.stringify(user)\n// \"{\"firstName\":\"三\",\"lastName\":\"张\"}\"\n```\n\n可以给正则定义``toJSON``方法，就可以用来转换正则了\n\n```js\nvar obj = {\n  reg: /foo/\n};\n\n// 不设置 toJSON 方法时\nJSON.stringify(obj) // \"{\"reg\":{}}\"\n\n// 设置 toJSON 方法时\nRegExp.prototype.toJSON = RegExp.prototype.toString;\nJSON.stringify(/foo/) // \"\"/foo/\"\"\n```\n\n### JSON.parse\n\n`JSON.parse`方法用于将JSON字符串转化成对象。\n\n如果传入的字符串不是有效的JSON格式，`JSON.parse`方法将报错。\n\n## console对象\n\n### 浏览器实现\n\n打开开发者工具\n\n```\nElements：查看网页的HTML源码和CSS代码。\nResources：查看网页加载的各种资源文件（比如代码文件、字体文件、css文件等），以及在硬盘上创建的各种内容（比如本地缓存、Cookie、Local Storage等）。\nNetwork：查看网页的 HTTP 通信情况。\nSources：查看网页加载的所有源码。\nTimeline：查看各种网页行为随时间变化的情况。\nPerformance：查看网页的性能情况，比如 CPU 和内存消耗。\nConsole：用来运行 JavaScript 命令。\n```\n\n### console.log()，console.debug()，console.info()\n\n`console.info()`和`console.debug()`都是`console.log`方法的别名，用法完全一样。只不过`console.info`方法会在输出信息的前面，加上一个蓝色图标。\n\n自定义`console`方法\n\n```js\n['log', 'info', 'warn', 'error'].forEach(function(method) {\n  console[method] = console[method].bind(\n    console,\n    new Date().toISOString()\n  );\n});\n\nconsole.log(\"出错了！\");\n// 2014-05-18T09:00.000Z 出错了！\n```\n\n### console.warn(),console.error()\n\n`warn`方法和`error`方法也是在控制台输出信息，它们与`log`方法的不同之处在于，`warn`方法输出信息时，在最前面加一个黄色三角，表示警告；`error`方法输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈。其他方面都一样。\n\n### console.table()\n\n对于某些复合类型的数据，`console.table`方法可以将其转为表格显示。\n\n### console.count()\n\n`count`方法用于计数，输出它被调用了多少次。\n\n该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类。\n\n```js\nfunction greet(user) {\n  console.count(user);\n  return \"hi \" + user;\n}\n\ngreet('bob')\n// bob: 1\n// \"hi bob\"\n\ngreet('alice')\n// alice: 1\n// \"hi alice\"\n\ngreet('bob')\n// bob: 2\n// \"hi bob\"\n```\n\n### console.dir()，console.dirxml()\n\n`dir`方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。\n\n`dirxml`方法主要用于以目录树的形式，显示 DOM 节点。\n\n### console.assert()\n\n`assert`方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。\n\n```js\nconsole.assert(false, '判断条件不成立')\n// Assertion failed: 判断条件不成立\n\n// 相当于\ntry {\n  if (false) {\n    throw new Error('判断条件不成立');\n  }\n} catch(e) {\n  console.error(e);\n}\n```\n\n### console.time()，console.timeEnd()\n\n```js\nconsole.time('Array initialize');\n\nvar array= new Array(1000000);\nfor (var i = array.length - 1; i >= 0; i--) {\n    array[i] = new Object();\n};\n\nconsole.timeEnd('Array initialize');\n// Array initialize: 1914.481ms\n```\n\n### console.profile()，console.profileEnd()\n\n`console.profile`方法用来新建一个性能测试器（profile），它的参数是性能测试器的名字。\n\n`console.profileEnd`方法用来结束正在运行的性能测试器。\n\n```js\nconsole.profile('p')\n// Profile 'p' started.\n\nconsole.profileEnd()\n// Profile 'p' finished.\n```\n\n打开浏览器的开发者工具，在`profile`面板中，可以看到这个性能调试器的运行结果。\n\n### console.group()，console.groupend()，console.groupCollapsed()\n\n`console.group`和`console.groupend`这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。\n\n`console.groupCollapsed`方法与`console.group`方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。\n\n### console.trace()，console.clear()\n\n`console.trace`方法显示当前执行的代码在堆栈中的调用路径。\n\n`console.clear`方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的`Preserve log`选项，网页脚本调用`console.log`将不起作用，但手动在控制台执行该方法依然有效\n\n### 命令行API\n\n具体详细内容 http://javascript.ruanyifeng.com/stdlib/console.html\n\n## 属性描述对象\n\n### Object.defineProperty()，Object.defineProperties()\n\n`Object.defineProperty`方法和后面的`Object.defineProperties`方法，都有性能损耗，会拖慢执行速度，不宜大量使用。\n\n这时需要注意的是，一旦定义了取值函数`get`（或存值函数`set`），就不能将`writable`设为`true`，或者同时定义`value`属性，会报错。\n\n```js\nvar o = {};\n\nObject.defineProperty(o, 'p', {\n  value: 123,\n  get: function() { return 456; }\n});\n// TypeError: Invalid property.\n// A property cannot both have accessors and be writable or have a value,\n```\n\n上面代码同时定义了`get`属性和`value`属性，结果就报错。\n","tags":["ES5"],"categories":["Note"]},{"title":"LeanJs「 ES5 」-- 语法","url":"%2F2018%2F01%2F23%2FLeanJS%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F","content":"![Js](LeanJS基础语法/js.png)\n\n<!--more-->\n\n## 基本语法\n\n### 语句\n\nJavaScript 程序的执行单位为行「 line 」，也就是**一行一行**。一般情况下，每一行就是一个语句。\n\n\n```js\nvar a = 1 + 3\n```\n\n这条语句先用 `var` 命令，声明了变量 `a`，然后将 `1 + 3` 的运算结果赋值给变量 `a`。\n\n`1 + 3` 叫做表达式（expression），指一个为了得到返回值的计算式。语句和表达式的区别在于，前者主要为了进行某种操作，一般情况下不需要返回值；后者则是为了得到返回值，一定会返回一个值。凡是 JavaScript 语言中预期为值的地方，都可以使用表达式。比如，赋值语句的等号右边，预期是一个值，因此可以放置各种表达式。\n\n### 变量\n\n在 JS 中, **变量的声明与赋值是分开的两个步骤**\n\nJavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升「 hoisting 」。\n\n```JS\nvar a = 1\n```\n\n上面的代码实际上是\n\n```js\nvar a\na = 1\n```\n\n这里强调一点\n\n```js\nvar a = 1\nvar a\nconsole.log(a)//1\n```\n\n如果用 `var` 声明一个已经存在的变量，是无效的。但是一旦进行了**赋值**操作，则会覆盖掉先前的值\n\n### 区块\n\nJavaScript 使用大括号，将多个相关的语句组合在一起，称为 「 区块 」（block）\n\n```js\n{\n  var a = 1\n}\nconsole.log(a)//1\n```\n\n区块对于 `var` 命令不构成单独的作用域，与不使用区块没有任何区别。常见的区块`for`,`if`,`while`,`function`等\n\n`function` 中的区块是函数作用域\n\n### 标签\n\nJavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置,通常与 `continue` 和 `break` 搭配\n\n```js\ntop:\n  for(var i=0; i<3; i++){\n    if(i==1) continue top\n    console.log(i)\n  }\n//0\n//2\n```\n\n## 数据类型\n\n### 概念\n\nES5中有六种数据类型:数值(number),字符串(string),布尔值(boolean),undefined,null,对象(object)\n\n数值、字符串、布尔值这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。至于 `undefined` 和 `null` ，一般将它们看成两个特殊值。\n\n对象是最复杂的数据类型，又可以分成三个子类型。\n\n狭义的对象(object),数组(array),函数(function)\n\n### null 和 undefined\n\n两者还是有一些细微的差别\n\n**null表示\"没有对象\"，即该处不应该有值** 转为数值时为 0\n\n```\n1.作为函数的参数，表示为空\n2.作为对象原型链的终点\n3.为对象和值赋值为空\n```\n\n**undefined表示\"缺少值\"，就是此处应该有一个值，但是还没有定义** 转为数值时为 ``NaN``\n\n```\n1.变量被声明了，但没有赋值时，就等于 undefined。\n2.调用函数时，应该提供的参数没有提供，该参数等于 undefined。\n3.对象没有赋值的属性，该属性的值为 undefined。\n4.函数没有返回值时，默认返回 undefined。\n```\n\n### 布尔值\n\n如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为 `false`，其他值都视为 `true`。\n\n```js\nundefined\nnull\n0\n'' 或 \"\"\nNaN\nfalse\n```\n\n:heavy_exclamation_mark:注意\n\n空对象和空数组也是 ``true``\n\n## 数值\n\n### 整数与浮点数\n\nJavaScript 内部，所有数字都是以 64 位浮点数形式储存，即使整数也是如此。所以，1 与 1.0 是相同的，是同一个数。\n\n```js\n1 === 1.0 // true\n```\n\n这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把 64 位浮点数，转成 32 位整数，然后再进行运算\n\n```js\n0.3 / 0.1 //2.9999999999999996\n0.1 + 0.2 === 0.3 //false\n```\n#### 数值精度\n\n精度最多只能到 53 个二进制位，这意味着，绝对值小于等于 2 的 53 次方的整数，即 -2^53 到 2^53\n\n#### 数值范围\n\n根据标准，64 位浮点数的指数部分的长度是 11 个二进制位，意味着指数部分的最大值是 2047（2 的 11 次方减 1）。也就是说，64 位浮点数的指数部分的值最大为2047，分出一半表示负数，则 JavaScript 能够表示的数值范围为 2^1024 到2^-1023（开区间），超出这个范围的数无法表示。**正向溢出为 ``Infinity``,负向溢出为 0**\n\n#### 科学计数法\n\n小数点前数字多于 21 位，小数点后的零多于 5 个就会自动转换为科学计数法\n\n\n#### +0 和 -0\n\n几乎所有场合 +0 和-0都是相等的,只有当 +0 和 -0 作为分母的时候才不相同\n\n```js\n(1/+0) //+Infinity\n(1/-0) //-Infinity\n```\n\n这两个的结果是不想等的\n\n#### NaN\n\n``NaN``是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。\n\n特点\n\n```js\n0 / 0 //NaN\nNaN === NaN//false\nNaN 与任何数运算都是 NaN\nNaN 不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于 Number\ntypeof NaN//'number'\n```\n\n### parseInt && parseFloat && Number\n\n``parseInt`` 和 ``parseFloat`` 相似，用于将字符串转换成数值.特点如下\n\n```\n1.如果字符串头部有空格,空格会自动去除\n2.是一个一个字符依次转换,如果碰到不能转换成数字的字符,就不在进行下去，返回已经转好的部分\n3.如果字符串的第一次字符就不能转换成数字，则返回 NaN\n4.``parseFloat``可以转换科学技术法为十进制数字\n5.遇到空字符串转为 NaN\n```\n\n``Number`` 只要碰到字符串就返回 ``NaN``\n\n### isNaN\n\n判断一个值是否为 ``NaN``\n\n但是，`isNaN` 只对数值有效，**如果传入其他值，会被先转成数值**。比如，传入字符串的时候，字符串会被先转成 `NaN`，所以最后返回 `true`，这一点要特别引起注意。也就是说，`isNaN` 为 `true` 的值，有可能不是 `NaN`，而是一个字符串。\n\n因此判断是否为 ``NaN`` 可以利用它与自身不等的特性\n\n```js\nfunction myIsNaN(value){\n  return value !== value\n}\n```\n\n## 字符串\n\n```js\n'a\nb\nc'\n// SyntaxError: Unexpected token ILLEGAL\n```\n上面代码将一个字符串分成三行，JavaScript 就会报错。\n\n如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。\n\n```js\nvar str = 'a\\\nb\\\nc'\nstr // abc\n```\n\n字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。**但是仅仅是相似而已，无法改变字符串中的单个字符** ``length``属性也是如此\n\n### 字符集\n\n每个字符在 JavaScript 内部都是以 16 位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为 16 位长度，即 2 个字节。由于历史遗留问题,JavaScript只支持两个字节的字符，**四个字节的字符会识别成两个字符**\n\n### Base64转码\n\n```js\nbtoa()：任意值转为 Base64 编码\natob()：Base64 编码转为原来的值\n```\n\n但这两种方法不适合非ASCII码的字符,要加一个转码环节\n\n```js\nfunction b64Encode(str) {\n  return btoa(encodeURIComponent(str))\n}\n\nfunction b64Decode(str) {\n  return decodeURIComponent(atob(str))\n}\n```\n\n## 对象\n\n### 值传递\n\n[谈谈值传递](https://blog.haoqinzz.cn/2017/07/25/%E8%B0%88%E8%B0%88%E5%80%BC%E4%BC%A0%E9%80%92/#more)\n\n### 表达式还是语句？\n\n```js\n{foo:123}\n```\n\nJavaScript 引擎读到上面这行代码，会发现可能有两种含义。第一种可能是，这是一个表达式，表示一个包含 `foo` 属性的对象；第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签 `foo`，指向表达式 `123`。\n\n为了避免这种歧义，JavaScript 规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。\n\n```js\n({foo:123})\n```\n\n在``eval``中可以体现出差异\n\n```js\neval('{foo: 123}') // 123\neval('({foo: 123})') // {foo: 123}\n```\n\n### 属性(键名)\n\n可以采用点运算符和方运算符\n\n:heavy_exclamation_mark:注意\n\n数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。\n\n```js\nvar str = 'foo'\nvar obj = {\n  123: 2,\n  foo: 6,\n  str: 5\n}\nobj.123//错误\nobj[123]//2\nobj[str]//6\nobj['str']//5\n```\n\n### 查看所有属性\n\n```js\nvar obj = {\n  123: 2,\n  foo: 6,\n  str: 5\n}\nObject.keys(obj)//(3) [\"123\", \"foo\", \"str\"]\n```\n\n### 删除属性\n\n``delete``用于删除对象的属性\n\n```js\nvar obj = {\n  123: 2,\n  foo: 6,\n  str: 5\n}\ndelete obj.foo\nobj.foo //undefined\n```\n\n:heavy_exclamation_mark:注意\n\n用 ``delete`` 删除一个属性,不会报错,而且还会返回 `true`,因此不能根据``delete``返回的结果来判断是否有该属性\n\n只有一种情况,``delete`` 返回 ``false``,那就是该属性存在，且不得删除\n\n``delete``命令只能删除对象本身的属性，无法删除继承的属性\n\n\n### in运算符\n\n``in`` 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回 `true`，否则返回 `false`。\n\n```js\nvar obj = {\n  123: 2,\n  foo: 6,\n  str: 5\n}\n\n'foo' in obj//true\n```\n\n但是 ``in`` 运算符无法判断哪些属性是自身的，哪些属性是继承的。他都会返回 ``true``\n\n:coffee: ``for..in..`` 就是用来遍历对象的所有属性\n\n### with\n\n操作同一个对象的多个属性\n\n```js\n// 例一\nvar obj = {\n  p1: 1,\n  p2: 2,\n}\nwith (obj) {\n  p1 = 4\n  p2 = 5\n}\n// 等同于\nobj.p1 = 4\nobj.p2 = 5\n\n// 例二\nwith (document.links[0]){\n  console.log(href)\n  console.log(title)\n  console.log(style)\n}\n// 等同于\nconsole.log(document.links[0].href)\nconsole.log(document.links[0].title)\nconsole.log(document.links[0].style)\n```\n\n如果``with``区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。\n\n这就造成一个弊端，就是绑定对象不明确,所以不推荐使用\n\n## 数组\n\n本质上就是对象\n\n由于数组本质上就是一个对象,所以可以为数组添加属性，但是这并不影响 ``length`` 属性的值。因为 ``length`` 属性的值就是最大的数字键加 1,如果这个数组没有数字键，那它的 ``lenth`` 保持为 0\n\n:heavy_exclamation_mark:注意\n\n如果键名是超出范围的数值，也会被转换成字符串\n\n### 空位\n\n当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。\n\n空位不会影响 `length` 属性\n\n```js\nvar arr = [1,,3] //length 3 \nvar arr1 = [1,2,3,] //length 3\n```\n\n数组的空位可以读取，为 ``ndefined``，但是空位用遍历的是读取不到的，而``undefined``是可以读取出来的\n\n使用``delete``删除一个数组成员，会形成空位，不会影响``length``\n\n### 类数组对象\n\n如果一个对象的所有键名都是正整数或零，并且有 `length` 属性，那么这个对象就很像数组，语法上称为 “类似数组的对象”（array-like object）\n\n典型的类数组对象\n\n```js\n// arguments对象\nfunction args() { return arguments }\nvar arrayLike = args('a', 'b')\n\narrayLike[0] // 'a'\narrayLike.length // 2\narrayLike instanceof Array // false\n\n// DOM元素集\nvar elts = document.getElementsByTagName('h3')\nelts.length // 3\nelts instanceof Array // false\n\n// 字符串\n'abc'[1] // 'b'\n'abc'.length // 3\n'abc' instanceof Array // false\n```\n\n用数组的``slice``方法可以转换成真正的数组\n\n```js\nvar arr = Array.prototype.slice.call(arrayLike)\n```\n\n`slice` 为什么可以转换成数组呢，`slice` 内部可能执行了如下的代码\n\n```js\nArray.prototype.slice = function(start,end){\n     var result = new Array()\n     start = start || 0\n     end = end || this.length //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键\n     for(var i = start; i < end; i++){\n          result.push(this[i])\n     }\n     return result\n}\n```\n\n还可以使用``call``方法使类数组使用数组的方法\n\n```js\nArray.prototype.forEach.call(arrayLike,funtion(){..})\n```\n\n但是这种方法要比原生的 ``forEach`` 要慢，因此还是推荐先转换成数组再用``forEach``\n\n## 函数\n\n### 第一等公民\n\nJavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。**凡是可以使用值的地方，就能使用函数**。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。\n\n由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。\n\n```js\nfunction add(x,y){\n  return x+y\n}\n```\n\n### 函数名的提升\n\n```js\nvar f = function(){\n  console.log(1)\n}\nfunction f(){\n  console.log(2)\n}\nf()//1\n```\n由于存在函数名的提升，其实会变成以下样子\n\n```js\nvar f\n\nfunction f(){\n  console.log(2)\n}\nf = function(){\n  console.log(1)\n}\nf()\n```\n\n函数声明形式等同于赋值语句声明同一个函数，所以后面执行的会**覆盖**先前相同的函数.\n\n\n### 不能在条件语句中声明函数\n\n根据 ES5 的规范，不得在非函数的代码块中声明函数，最常见的情况就是if和try语句。\n\n要达到在条件语句中定义函数的目的，只有使用函数表达式。\n\n```js\nif (false) {\n  var f = function () {}\n}\n\nf() // undefined\n```\n\n### name\n\n函数``name``属性返回紧跟在``function``关键字之后的那个函数名\n\n```js\nfunction f1() {}\nf1.name // 'f1'\n\nvar f2 = function () {}\nf2.name // ''\n\nvar f3 = function myName() {}\nf3.name // 'myName'\n```\n\n上面代码中，函数的``name``属性总是返回紧跟在``function``关键字之后的那个函数名。对于f2来说，返回空字符串，匿名函数的``name``属性总是为空字符串；对于f3来说，返回函数表达式的名字（**真正的函数名还是f3，myName这个名字只在函数体内部可用**）。\n\n### length\n\n函数的``length``属性返回函数预期传入的参数个数，即**函数定义之中的参数个数**。在之后调用的话，无论输入多少个参数,``length``属性始终返回函数定义时的参数个数\n\n```js\nfunction len(a,b){\n  len.length //2\n}\n```\n\n``length``属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的「重载」（overload）。\n\n### toString\n\n函数的 `toString` 方法返回一个字符串，内容是函数的源码,注释也可以返回.\n\n[函数基础](https://blog.haoqinzz.cn/2017/08/17/js%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80/)\n\n### 函数作用域\n\n:heavy_exclamation_mark: 注意\n\n函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其**声明时所在的作用域，与其运行时所在的作用域无关**。\n\n对于 `var` 命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。\n\n```js\nvar a = 1\nvar x = function () {\n  console.log(a)\n}\n\nfunction f() {\n  var a = 2\n  x()\n}\n\nf() // 1\n```\n\nx 函数定义的时候就是全局作用域,x 函数内部的 a 不会到 f 函数中取 a 的值。\n\n```js\nvar x = function () {\n  console.log(a)\n}\n\nfunction y(f) {\n  var a = 2\n  f()\n}\n\ny(x)\n// ReferenceError: a is not defined\n```\n\n上面代码将函数 x 作为参数，传入函数 y。但是，函数 x 是在函数 y 体外声明的，作用域绑定外层，因此找不到函数 y 的内部变量 a，导致报错。\n\n```js\nfunction foo() {\n  var x = 1\n  function bar() {\n    console.log(x)\n  }\n  return bar\n}\n\nvar x = 2\nvar f = foo()\nf() // 1\n```\n\n上面代码中，函数``foo``内部声明了一个函数`bar`，`bar`的作用域绑定`foo`。当我们在`foo`外部取出`bar`执行时，变量`x`指向的是`foo`内部的`x`，而不是`foo`外部的`x`。正是这种机制，构成了下文要讲解的「闭包」现象。\n\n### 传递方式\n\n```js\nvar a = 2\nfunction b(a){\n  a = 3\n}\nb()\na//2\n```\n\n```js\nvar a = 2\nfunction b(){\n  a = 3\n}\nb()\na//3\n```\n\n上面代码中，变量`a`是一个原始类型的值，传入函数`b`的方式是传值传递。因此，在函数内部，`a`的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。\n\n但是，如果函数参数是**复合类型的值（数组、对象、其他函数）**，传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数**内部修改参数**，将会影响到原始值。\n\n### 同名参数\n\n如果有同名参数,则取最后那个值\n```js\nfunction f(a, a) {\n  console.log(a)\n}\n\nf(1, 2) // 2\n```\n上面代码中，函数f有两个参数，且参数名都是a。取值的时候，以后面的a为准，即使后面的a没有值或被省略，也是以其为准。\n\n```js\nfunction f(a, a) {\n  console.log(a)\n}\n\nf(1) // undefined\n```\n\n调用函数f的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。\n\n```js\nfunction f(a, a) {\n  console.log(arguments[0])\n}\n\nf(1) // 1\n```\n\n\n### arguments\n\n函数体内是严格模式，这时修改``arguments``对象就是无效的。\n\n``arguments``为类数组对象,要转换成真正的数组\n\n```js\nvar args = Array.prototype.slice.call(arguments)\n\n// 或者\nvar args = []\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i])\n}\n\n```\n\n``arguments``对象带有一个`callee`属性，返回它所对应的原函数。调用自身函数，不常用。\n\n### 闭包\n\n闭包就是将函数内部和函数外部连接起来的一座桥梁\n\n:heavy_exclamation_mark: 注意\n\n外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题\n\n\n### 立即调用的函数表达式（IIFE）\n\n在 Javascript 中，圆括号``()``是一种运算符，跟在函数名之后，表示调用该函数。比如，``print()``就表示调用``print``函数。\n\n有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。\n\n```js\nfunction(){ /* code */ }()\n// SyntaxError: Unexpected token (\n```\n\n产生这个错误的原因是，``function``这个关键字即可以当作语句，也可以当作表达式。\n\n```js\n// 语句\nfunction f() {}\n\n// 表达式\nvar f = function f() {}\n```\n\n为了避免解析上的歧义，JavaScript 引擎规定，如果``function``关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是`function`关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n\n解决方法就是**不要让`function`出现在行首**，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n\n```js\n(function(){ /* code */ }())\n// 或者\n(function(){ /* code */ })()\n```\n\n上面两种写法都是以圆括号开头，(不一定非要是圆括号)引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做「立即调用的函数表达式」（Immediately-Invoked Function Expression），简称 IIFE。\n\n注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错\n\n```js\n// 报错\n(function(){ /* code */ }())\n(function(){ /* code */ }())\n```\n\n上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，**将第二行解释为第一行的参数**。\n\n### eval\n\n`eval`命令的作用是，将字符串当作语句执行。\n\n放在`eval`中的字符串，应该有独自存在的意义，不能用来与`eval`以外的命令配合使用\n\n`eval`没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\n\n```js\nvar a = 2\neval('a=3')\na//3\n```\n\n如果使用严格模式，`eval`内部声明的变量，不会影响到外部作用域。但是还是会修改当前作用域下的变量\n\n```js\n'use strict'\nvar a = 2\neval('a=3')\na//3\n\n'use strict'\neval('var b = 4')\nb//Uncaught ReferenceError: b is not defined\n```\n\n此外，`eval`的命令字符串不会得到 JavaScript 引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。\n\n常情况下，`eval`最常见的场合是解析 JSON 数据字符串，不过正确的做法应该是使用浏览器提供的`JSON.parse`方法。\n\nJavaScript 引擎内部，`eval`实际上是一个引用，默认调用一个内部方法。这使得`eval`的使用分成两种情况，一种是像上面这样的调用`eval(expression)`，这叫做「直接使用」，这种情况下`eval`的作用域就是当前作用域。除此之外的调用方法，都叫「间接调用」，此时`eval`的作用域总是**全局作用域**。\n\n```js\nvar a = 1\n\nfunction f() {\n  var a = 2\n  var e = eval\n  e('console.log(a)')\n}\n\nf() // 1\n```\n上面代码中，`eval`是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的`a`为全局变量。\n\n`eval`的间接调用的形式五花八门，**只要不是直接调用，都属于间接调用**\n\n[图解作用域和闭包](https://blog.haoqinzz.cn/2017/08/20/%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85/#more)\n\n## 运算符\n\n### 加法运算符\n\n```js\n3+5+'6' //86\n'6'+3+5 //635\n```\n\n从左到右的运算顺序，字符串或字符出现的顺序将导致结果的不同,减法除法乘法运算符都会先将字符串转换成数字再进行运算。\n\n如果运算是对象，必须先转换成原始类型，然后再进行相加\n\n```js\nvar obj = { p: 1 }\nobj + 2 // \"[object Object]2\"\n```\n\n`obj`转换成原始类型为`[object Object]`\n\n对象转换成原始类型，规则如下\n\n首先，自动调用`valueOf`方法,一般来说`valueOf`方法会返回对象本身，然后再调用`toString()`方法将其转换为字符串\n\n```js\nvar obj = {p:1}\nobj.valueOf().toString()//[object Object]\n```\n\n当知道了这个规则之后，就可以自己定义`valueOf`和`toString`方法来得到自己想要的结果\n\n```js\nvar obj = {\n  valueOf: function () {\n    return 1\n  }\n}\n\nobj + 2 // 3\n```\n\n上面代码中，我们定义`obj`对象的`valueOf`方法返回1，于是`obj` + 2就得到了3。这个例子中，由于`valueOf`方法直接返回一个原始类型的值，所以不再调用`toString`方法。\n\n下面是自定义`toString`方法的例子。\n```js\nvar obj = {\n  toString: function () {\n    return 'hello'\n  }\n}\n\nobj + 2 // \"hello2\"\n```\n\n上面代码中，对象`obj`的`toString`方法返回字符串`hello`。前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串。\n\n:heavy_exclamation_mark: 注意\n\n这里有一个特例，如果运算子是一个`Date`对象的实例，那么会优先执行`toString`方法\n。\n```js\nvar obj = new Date()\nobj.valueOf = function () { return 1 }\nobj.toString = function () { return 'hello' }\n\nobj + 2 // \"hello2\"\n```\n\n上面代码中，对象`obj`是一个`Date`对象的实例，并且自定义了`valueOf`方法和`toString`方法，结果`toString`方法优先执行。\n\n\n### 比较运算符\n\n字符串比较是按照字典顺序，如果第一个相等就比较下一个\n\n与原始类型比较的话，如果不是数字，都是先用`Number` 转成数字再进行比较。其中和`NaN`比较都返回`false`\n\n与非原始类型比较就先转换成原始类型，规则还是复合类型先调用`valueOf`再调用`toString`，`Date`还是一样特殊\n\n### === && == \n\n`===`先会比较两个值的类型，如果类型不相同，则直接返回`false`,`==`也是先比较类型，如果类型不相同，他会先转换成同一类型的值然后再进行`===`比较\n\n#### ===\n\n不同类型直接返回`false`\n\n都是原始类型值相等返回`true`,`NaN`不严格等于任何值也不和自己严格相等\n\n都是复合类型不是判断他们的值是否相等，而是判断他们指向的地址是否相等\n\n`undefined`和`null`只与自己严格相等\n\n`!==`是对`===`的取反\n\n#### == \n\n相同类型的话和`===`判断算法相同\n\n原始类型的数据会转换成数值来比较，调用`Number`方法\n\n复合类型和原始类型进行比较，复合类型先转换成原始类型\n\n```js\n//与数字比较\n[1] == 1 // true\n// 等同于 Number([1]) == 1\n\n//与字符串比较\n[1] == '1' // true\n// 等同于 String([1]) == '1'\n\n//与布尔值比较\n[1] == true // true\n// 等同于 Number([1]) == Number(true)\n```\n\n`undefined`和`null`与其它类型比较时都为`false`,**相互比较时为`true`**\n\n`!=`是对`==`结果的取反\n\n### 取反\n\n任何类型的数值经过`!`后都变成了布尔值，`!!x`相当于`Boolean(x)`\n\n### 位运算\n\n位运算符只对整数起作用，如果一个运算子不是整数，**会自动转为整数后再执行**。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。\n\n```js\ni = i | 0 //就是将i转为32位的整数\n~~i //对i取整 方法最快\ni^0//对i取整\n```\n\n#### 异或\n\n异或运算（^）在两个二进制位不同时返回1，相同时返回0。\n\n```js\n//用来交换\nvar a = 1\nvar b = 2\na ^=b,b^=a,a^=b\na//2\nb//1\n```\n\n#### 左移右移\n\n```js\n4 << 1\n```\n\n左移1为 4的二进制为100，左移为1000，结果就为8，所以`x`左移`n`位相当于`x`乘`2`的`n`次方\n\n### void\n\n`void`运算符的作用是执行一个表达式，然后不返回任何值，或者说返回`undefined`。\n\n\n```js\n<a href=\"javascript: void(document.form.submit())\">\n  提交\n</a>\n```\n\n`void`执行速度快，执行提交后不返回任何值所以也阻止了`a`标签的默认跳转\n\n### 逗号运算符\n\n```js\n'a', 'b' // \"b\"\n\nvar x = 0\nvar y = (x++, 10)\nx // 1\ny // 10\n```\n\n### 优先级\n\n根据语言规格，这五个运算符的优先级从高到低依次为：小于等于`<=`、严格相等`===`、或`||`、三元`?:`、等号`=`。因此上面的表达式，实际的运算顺序如下。\n\n### 圆括号\n\n圆括号不是运算符，而是一种**语法结构**。它一共有两种用法：一种是把表达式放在圆括号之中，提升运算的优先级；另一种是跟在函数的后面，作用是调用函数。\n\n圆括号中只能放置表达式，不能放置语句，如果将语句放置在圆括号中会报错\n\n\n## 数据类型的转换\n\n### Number\n\n`Number`转换对象时，将返回`NaN`，除非是有单个数值的数组\n\n`Number`转换的规则\n\n第一步，调用对象自身的`valueOf`方法。如果返回原始类型的值，则直接对该值使用`Number`函数，不再进行后续步骤。\n\n第二步，如果`valueOf`方法返回的还是对象，则改为调用对象自身的`toString`方法。如果`toString`方法返回原始类型的值，则对该值使用`Number`函数，不再进行后续步骤。\n\n第三步，如果`toString`方法返回的是对象，就报错。\n\n### String\n\n`String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\n\n`String`方法背后的转换规则，与`Number`方法基本相同，只是互换了`valueOf`方法和`toString`方法的执行顺序。\n\n### Boolean\n\n`Boolean`函数可以将任意类型的值转为布尔值。\n\n除了以下为`false`，其余都为`true`\n\n```\nundefined\nnull\n''\n+0 -0\nNaN\n```\n\n:heavy_exclamation_mark:注意\n\n`undefined`转换成数字为`NaN` `null`为0\n\n## 错误(Error)\n\n### SyntaxError\n\n``SyntaxError``对象是解析代码时发生的语法错误。\n\n```js\n// 变量名错误\nvar 1a\n// Uncaught SyntaxError: Invalid or unexpected token\n\n// 缺少括号\nconsole.log 'hello')\n// Uncaught SyntaxError: Unexpected string      \n```\n\n### ReferenceError\n\n``ReferenceError``对象是引用一个不存在的变量时发生的错误。\n\n```js\n// 使用一个不存在的变量\nunknownVariable\n// Uncaught ReferenceError: unknownVariable is not defined\n```\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者`this`赋值。\n\n```js\n// 等号左侧不是变量\nconsole.log() = 1\n// Uncaught ReferenceError: Invalid left-hand side in assignment\n\n// this 对象不能手动赋值\nthis = 1\n// ReferenceError: Invalid left-hand side in assignment\n```\n\n### RangeError\n\n`RangeError`对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是`Number`对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n### TypeError \n\n`TypeError`对象是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用`new`命令，就会抛出这种错误，因为`new`命令的参数应该是一个构造函数。  \n\n### URIError\n\n`URIError`对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及`encodeURI()`、`decodeURI()`、`encodeURIComponent()`、`decodeURIComponent()`、`escape()`和`unescape()`这六个函数。\n\n### EvalError\n\n`eval`函数没有被正确执行时，会抛出`EvalError`错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留。\n\n### try .. catch .. finally\n\n一旦发生错误，程序就中止执行了。JavaScript 提供了`try...catch`结构，允许对错误进行处理，选择是否往下执行。\n\n```js\ntry{\n  \n}catch(err){//接受错误类型\n  //处理错误\n}finally{\n  //不管出现任何错误都执行\n}\n```\n\n\n","tags":["ES5"],"categories":["Note"]},{"title":"prop 和 attr 的一些理解","url":"%2F2017%2F11%2F24%2Fprop%E5%92%8Cattr%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F","content":"\n> 前几天做一个迷你京东小项目的时候涉及到一个全选的小功能，一开始用的是 `attr`，但是效果完全不是自己想要的，当商品按钮点击过一次后，`attr` 就无法对其状态进行更改，最后谷歌了一番发现需要用 `prop` 来代替。虽然效果问题解决了，但是自己还是想弄懂 `prop` 和 `attr` 的区别.\n\n<!--more-->\n\n## 版本使用不同\n\n遇到问题我一般先会去查相关的官方文档，可在 jq 的 api 中文文档中没有发现有价值的东西，只是发现适用的版本和概念有所轻微的不同。\n\n`attr` : 设置或返回被选元素的属性值.版本：1.0\n\n`prop` : 获取在匹配的元素集中的第一个元素的属性值。版本：1.6+\n\n从概念中发现操作的对象和使用也好像基本相同，然后带着疑惑去进行了一番实验并去查阅了一些相关资料\n\n示例代码\n\n```HTML\n<table>\n        <thead>\n            <tr><input type=\"checkbox\" class=\"checkAll\">全选</tr>\n        </thead>\n        <tbody>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n        </tbody>\n    </table>\n```\n\n```js\n$('.checkAll').click(function() {\n  $('.item').attr('checked', this.checked)\n})\n```\n\n## 问题描述\n\n当全选按钮选中时单选按钮全部选中，当全选按钮不选中时单选按钮全部不选中，只点全选按钮时，反复几次都没问题，但是要是点击了其中一个单选按钮，那这个单选按钮就不会在像其它单选按钮一样跟随全选按钮的状态的改变而改变。\n\n## attr 和 prop 的本质\n\n`attr` 是 `attribute` 的缩写,`prop` 是 `property` 的缩写，都有属性的意思，只不过 `attr` 是操作 html 文档节点属性，`prop` 是操作 js 对象属性. `attr` 在 js 中使用的是 `setAttribute` 和 `getAttribute` 而 `prop` 直接使用原生 js 的 `element[value]` 和 `element[value]=key`。\n\n## attr 和 prop 的区别\n\n`attr` 设置的属性值只能是**字符串类型**,如果不是字符串类型，也会调用其 `toString()` 方法，将其转换成字符串类型。\n\n`prop` 设置的属性值可以包括数组和对象在内的任意类型\n\n### 有关布尔值的属性\n\n1.6 之后, `attr` 返回的也是**字符串类型**, 选中或禁用直接返回 `checked`,`selected`,`disabled`。否则返回`undefined`。解决我问题的关键就是后面一句话\n\n> jQuery 认为：attribute 的 checked、selected、disabled 就是表示该属性初始状态的值，property 的 checked、selected、disabled 才表示该属性实时状态的值(值为 true 或 false)。\n\n当涉及到 boolean 值时，比如 `checkbox` 这样的，有 `true` 和 `false` 这样的布尔值的元素属性，`attributes` 在页面加载的时候就被设置，并且一直保持初始值，而 `properties` 则存储着元素属性的当前值。\n\n所以当我没有点击单选按钮的时候，它就是没被用户点击过的浏览器刚加载出来的初始状态，此时可以通过 `attr` 去设置并操控，当有用户点击的时候，当前按钮就不是初始状态，`attr`自然也就无法操控。\n","tags":["JQ"],"categories":["Explore"]},{"title":"简易扫雷小游戏","url":"%2F2017%2F09%2F07%2F%E7%AE%80%E6%98%93%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F%2F","content":"\n> 前阵子无聊，LOL 也不是很想玩，发现了电脑中自带的扫雷, 当时在一个神奇的地方，用的是一个 windows2000 的系统界面但是扫雷确是 win7 的样式, \n\n<!--more-->\n\n![pic1](简易扫雷小游戏/pic1.jpg)\n\n这种情况，就是考验运气的时候了，但是果不其然。。。\n\n![pic2](简易扫雷小游戏/pic2.jpg)\n\n我成功选择了有炸弹的那一个，从这里面我明白了一个道理，那就是：**成功需要 99% 的努力再加上 1% 的运气**。。。。。。\n\n## 原理(思路)\n\n### 布局\n\n玩了几句搞清了游戏规则，就想自己动手做一个，因为以前做过 2048，所以首先想到的就是用二维数组布局\n\n添加三个难度的按钮\n\n```html\n<a class=\"type\" href=\"#\" data-width=\"9\" data-height=\"9\" data-mine=\"10\">简单</a>\n<a class=\"type\" href=\"#\" data-width=\"16\" data-height=\"16\" data-mine=\"40\">中级</a>\n<a class=\"type\" href=\"#\" data-width=\"30\" data-height=\"16\" data-mine=\"99\">高级</a>\n```\n\n点击相应按钮通过 js 获取对应的 `data` 属性,然后动态的生成相应的方格,然后动态计算包裹所有小方格的宽度和高度,为了以后方便操作每一个小方格,给每一个小方格按行列添加独有的 `id`。\n\n### 盒子对象\n\n#### 属性\n\n因为扫雷是对每个格子进行操作，因此我把每个格子都看成一个独立的个体，这个个体具有属性和方法，就相当于一个小对象。定义了两个数组\n\n```js\n// 代表盒子身份的数组\nvar boxArr = []\n// 用于存储周围八个格子中雷的个数\nvar MineArr = []\n```\n\n通过这两个数组,我可以知道每个格子是否是炸弹,还有每个格子周围对应八个格子中有多少个炸弹，这属于格子对象的属性。\n\n#### 方法\n\n盒子对象还有鼠标按下和抬起的方法，这里要注意，不要给每个盒子都添加事件。假设有 100 个盒子的话，就要添加 100 个事件，事实上高级难度下的盒子话还有更多，这样就不如在 `container` 上绑定事件，利用冒泡。也可以实现相同的效果，并且只需要绑定一个事件\n\n```js\ncontainer.on('mousedown', '.box', function (e) {\n  $(e.target)//获取点击到的class为box的元素\n}\n```\n\n有的时候格子的 `MineArr` 里面存的可能是 0 ,这就代表他周围 8 个方格不存在炸弹,像这种的话就直接将其周围的八个格子直接自动点开就好了,下面这幅图，我只点了一下,就是点到了 `MineArr[i][j]==0` 的格子,然后让他周围八个直接显示 `MineArr` 中的数值,如果周围八个格子还有 `MineArr[i][j]==0` 的情况，就继续打开去显示。\n\n![pic3](简易扫雷小游戏/pic3.png)\n\n扫雷中还有一个一定要有的方法就是左右键一起按一个点开的格子，会自动判断周围格子中你标记雷的个数和你点击的这个格子的数值。如果你标记雷的个数等于左右键点击的格子中的数值，他会自动帮你点开剩下的还没点击过的格子，这些格子中可能有雷也可能没雷，这要看你自己标记的雷是不是对的。\n\n这个也蛮好实现,右键按下的时候将周围没点击过也没被标记过雷的方格添加带有别的颜色的 `class`，然后记录周围八个方格标记的雷的个数，然后在右键松开的时候移除此 `class`,并判断刚记录的标记的雷的个数和当前点击的格子的数值是否相等，然后去做下一步处理。\n\n### 成功失败判断\n\n失败很好判断，点中了 `boxArr` 为 1 的格子就判失败，就是点中了雷。\n\n成功的话我是通过点击出来的格子的数量来判断的，成功显现的格子只要等于总格子减去雷的格子就判断为游戏胜利\n\n## 总结\n\n虽然是一个比较简单的游戏，但是自己在做的时候还是碰到过不少的 bug,也学到了蛮多的,这里列一下。\n\n### 清空问题\n\n* 每次创建新的格子都要清空上次创建的所有格子\n\n* 我是采用冒泡的方式给盒子添加的点击事件，是添加在 `container` 上的，然后 `container` 是不消失的，所以每次创建新格子前还要将 `container` 上的事件解绑\n\n### 右键\n\n右键在网页上是有默认行为的，在这个游戏中要禁掉\n\n```js\n//去掉默认的contextmenu事件，否则会和默认右键事件同时出现。\ndocument.oncontextmenu = function(e) {\n  e.preventDefault()\n}\n```\n\n### each()\n\njquery 中的 `each` 是不能用 `break` 跳出的。是用 `return false` 代替的 `break`, `return true` 或 `return` 代替的 `continue`\n\n### 最后\n\n还有一些我思路上或者说写法中存在的小 bug,我用相应的方法去解决掉了。大家可以看[源码](https://github.com/MLuminary/subentry/tree/master/cleanMine),因为花的时间比较短,可能里面还存在一些问题,还请大佬们多多包涵,也欢迎大佬们来指正。本小白感激不尽，喜欢的话还请点个 :star:\n\n[小游戏试玩](https://www.haoqinzz.cn/cleanMine)\n","tags":["Idea"],"categories":["Fun"]},{"title":"对象类型的辨别","url":"%2F2017%2F08%2F24%2F%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BE%A8%E5%88%AB%2F","content":"\n> 对象类型的判别不同于基础类型的判别，js 中又有一句话叫万物皆对象，\b因此对象的判别工作要比基础数据类型要稍微麻烦一点\n\n<!--more -->\n\n## 判断一个对象是不是数组类型\n\n### typeof\n\n少部分人可能首先会想到 `typeof`\n\n```js\nvar n = 3,\n  b = true,\n  s = 'Hello',\n  x = null,\n  y,\n  obj1 = function() {},\n  obj2 = {},\n  obj3 = [],\n  obj4 = new Date();\nconsole.log(\n  typeof n, //number\n  typeof b, //boolean\n  typeof s, //string\n  typeof x, //object\n  typeof y, //undefined\n  typeof obj1, //function\n  typeof obj2, //object\n  typeof obj3, //object\n  typeof obj4 //object\n)\n```\n\n可以看出 `typeof` 是可以判断出基本数据类型的，函数也能判断出来，但是对象、数组、日期都会返回 `object` ,这样就根本无法判断一个对象是不是数组类型。所以 `typeof` 宣告无能为力\n\n### 判断其父级原型对象\n\n```js\nvar obj1 = {},\n  obj2 = [1, 2, 3],\n  obj3 = new Date()\n\nconsole.log(obj1.__proto__ === Array.prototype) //false\nconsole.log(obj2.__proto__ === Array.prototype) //true\nconsole.log(obj3.__proto__ === Array.prototype) //false\n```\n\n但是 `__proto__` 是内部属性，本不应该被访问到，我们可以用 `Object.getPrototypeOf(obj)` 方法来代替他，虽然这个方法其实内部原理也是他，但是还是有不同的。\n\n```js\nconsole.log(Object.getPrototypeOf(obj1) === Array.prototype) //false\nconsole.log(Object.getPrototypeOf(obj2) === Array.prototype) //true\nconsole.log(Object.getPrototypeOf(obj3) === Array.prototype) //false\n```\n\n### 判断其构造函数\n\n`obj instanceof Array` 判断 `obj` 是不是被构造函数 `Array` 创造出来的\n\n```js\nconsole.log(obj1 instanceof Array) //false\nconsole.log(obj2 instanceof Array) //true\nconsole.log(obj3 instanceof Array)\t//false\n```\n\n但 `instanceof` 不仅判断直接父类型，而是所有在原型链上的类型，都返回 `true` ,所以如果你创建一个对象但是把他的 `__proto__` 指向 `Array` 的原型，然后判断其类型，也会返回 `true`。\n\n```js\nobj1.__proto__ = Array.prototype\nconsole.log(obj1 instanceof Array) //true\n```\n\n\n### 判断对象内部的 class 属性\n\n每个对象内部，都有一个隐藏的 `class` 属性，记录该对象创建时的数据类型 `class` 属性不会随继承关系的改变而改变。（就相当于查人的 DNA，小样还想伪装）\n\n这里有一个问题：内置类型的原型对象中几乎都重写了新的 `toString()`，只有最顶层的 `toString()` 才能输出对象的 `class` 属性值，\n\n因此我们可以用 `call` 来使用最牛皮的身份鉴别\n\n```js\nconsole.log(\n  Object.prototype.toString.call(obj1) === /*[object Object]*/ '[object Array]'\n) //false\nconsole.log(\n  Object.prototype.toString.call(obj2) === /*[object Array]*/ '[object Array]'\n) //true\nconsole.log(\n  Object.prototype.toString.call(obj3) === /*[object Date]*/ '[object Array]'\n) //false\n```\n\n### Array.isArray\n\n`Array.isArray` 也可以弥补 `typeof` 的不足\n\n```js\nArray.isArray(obj1) //false\nArray.isArray(obj2) //true\nArray.isArray(obj3) //false\n```\n\n但其实 `isArray` 的原理就是判别其内部的 `class` \n\n```js\nif (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]'\n  }\n}\n// -- 来自 MDN\n```\n\n\n","tags":["Base"],"categories":["Explore"]},{"title":"图解作用域及闭包","url":"%2F2017%2F08%2F20%2F%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85%2F","content":"\n> 网络上关于作用域及闭包的文章很多，自己对于纯理论知识并不能很快的理解，但自己对于图画有很强的记忆能力，因此决定将此知识点以图画的知识表现出来，加深自身理解的同时如果能帮到正在学习的童鞋就再好不过了, <br> 下面我以函数的整个生命周期来诉说此部分知识\n\n<!--more-->\n\n## 函数生命周期\n\n先写一下示例代码\n\n```js\nvar a = 10 \nfunction func(a) {\n  var a = 20 \n  a++ \n  console.log(a) \n}\nfunc() \nconsole.log(a) \n```\n\n### 开始执行程序前\n\n![pic2](图解作用域及闭包/pic2.jpg)\n\n1.  先创建 ECS，ECS 其实就是专门保存正在调用的函数的执行环境的数组，也可以说对象，其实关联数组也就相当于对象。\n\n2.  然后在 ECS 中添加浏览器主程序的执行环境 main\n\n3.  创建全局作用域对象 window\n\n4.  main 执行环境引用 window\n\n### 定义函数时\n\n![pic3](图解作用域及闭包/pic3.jpg)\n\n1.  原始类型的全局变量会直接存入 window 环境当中，因为函数是引用类型，所以首先用函数名声明全局变量\n\n2.  然后创建函数对象，封装函数定义\n\n3.  函数对象的 scope 属性，指回函数创建时的作用域，意思是，函数执行时如果函数本身提供的变量不能让函数执行完全，那它便会去回它创建时的那个作用域去寻找变量。\n\n4.  函数名后面存入指向函数对象的地址\n\n引用类型在其中只能存储地址，这个在此笔记[谈谈值传递](https://github.com/MLuminary/Blog/issues/1)中有详细说明\n\n### 函数调用时\n\n![pic4](图解作用域及闭包/pic4.jpg)\n\n1.  向 ECS 中压入本次函数调用的执行环境元素\n\n2.  创建本次函数调用时使用的函数作用域对象（AO），也就是临时作用域\n\n3.  在 AO 中创建储存所有的局部变量，包括形参变量和函数内用 var 声明的变量\n\n4.  设置 AO 的 parent 属性和引用函数的 scope 属性指向父级作用域对象\n\n5.  函数的执行环境引用 AO\n\n6.  顺着那个箭头，先在 AO 中找变量，也就是局部变量，如果 AO 中没有，再顺着箭头去父级作用域中找\n\n### 函数调用后\n\n![pic5](图解作用域及闭包/pic5.jpg)\n\n函数的执行环境出栈，AO 释放，AO 中的局部变量一同被释放掉。\n\n我们得知整个结果之后，自然而然那两个 `console` 的结果也显然意见。\n\n## 闭包\n\n前面我们提到过，全局变量是可重用但是污染全局，局部变量不会污染全局但是不可重用。\n\n我自己认为闭包就是重用变量又保护变量不被污染的机制，就是为了解决这一情况而生的。\n\n### 特点\n\n**包裹受保护的变量和操作变量的内层函数的外层函数**\n\n**外层函数要返回内层函数的对象**\n\n* `return function(){..}`\n* 直接给全局变量赋值一个内部 `function`\n* 将内部函数保存在一个对象的属性或数组元素中 `return [function function function]` 或 `return {fun:function(){...}}`\n\n**调用外层函数，用外部变量接住返回的内层函数对象,形成闭包。**\n\n### 原理\n\n先贴出示例代码\n\n```js\nfunction outer() {\n  var num = 1 \n  return function() {\n    console.log(num++) \n  } \n}\n\nvar getNum = outer() \ngetNum() \ngetNum() \nnum = 1 \ngetNum() \n```\n\n下面我把闭包形成的原理用画图工具画出来\n\n![pic6](图解作用域及闭包/pic6.jpg)\n\nwindow 中存入 outer 名并指向 outer 函数对象，`getNum` 因为声明提前也先将变量名存在 window 中。\n\n`getNum = outer()` 其实包含 outer 的创建和 `getNum` 的赋值。\n\n上面的图画的是 outer 函数进行到 `var num = 1 ` ,前面都有说过，不过多重复。\n\n![pic7](图解作用域及闭包/pic7.jpg)\n\n创建了匿名函数，`getNum` 指向了匿名函数对象，匿名对象的 scope 指向它的父级作用域，也就是 outer 的作用域，那这样就形成了图中的三角关系，此时 outer 执行完毕，离开 ECS 执行环境，outer 的 AO 本也应该随着离开，**但是因为这强大的三角关系，强行拉住不让其释放**，也就形成了所谓的闭包。\n\n**那其实闭包的原因就是**:外层函数的作用域对象无法释放\n\n![pic8](图解作用域及闭包/pic8.jpg)\n\n`getNum=outer()`getNum 其实就是一个函数\n\n![pic9](图解作用域及闭包/pic9.png)\n\n调用`getNum()`,会生成 `getNum` 的临时作用域,图中可看出,`getNum` 其实就是在 outer 中的匿名函数，所以他的 parent 就指向 outer 留下的作用域。当他执行 `console.log(num++)` 的时候，在他的作用域中没有 `num` 变量他就会顺着作用域链去寻找，最终在 outer 中的作用域中找到 `num` 并对其进行自加操作。**所以当下次调用 getNum 的时候 num 会从 2 开始，不会是一开始的 1**。\n\nnum 不是全局变量，还实现了 num 变量的重复调用。就达到了闭包的目的。\n\n![pic10](图解作用域及闭包/pic10.jpg)\n\n设置 `num = 1` 只是在 `window` 对象上添加存储 `num` 的值，当下次调用 `getNum` 的时候 js 引擎还会从 `getNum` 作用域开始顺着作用域链寻找 `num`,在 outerAO 就会寻找到 `num`,所以根本不会影响到 window 中的 `num`,也不会受其影响。因此此段代码输出的结果为 `1 2 3`。\n\n### 缺点\n\n当然闭包也有其缺点\n\n* 比普通函数占用更多内存，因为外层函数的作用域对象（AO）始终存在\n\n* 容易造成内存泄漏\n\n### 解决办法\n\n将引用内存函数对象的外部变量重置为 null\n\n```js\ngetNum = null \n```\n\n![pic11](图解作用域及闭包/pic11.jpg)\n\ngetNum 指向 outer 函数对象的那根线就会断掉，三角关系破裂，那函数对象和 outerAO 也会相继被销毁。\n\n","tags":["Deep"],"categories":["Explore"]},{"title":"Js 函数基础","url":"%2F2017%2F08%2F17%2Fjs%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F","content":"\n> 每天都在和函数打交道，到底函数是个啥，还有啥隐藏的秘密吗\n\n<!--more -->\n\n## 函数的定义\n\n**函数其实就是一个封装一段代码段的对象，函数名其实仅是用来引用函数对象的一个普通变量**,写代码的时候我们避免不了要重复用一些代码，一直重复写很耗时，而且不美观也不利于维护，因此函数的出现就是来让代码重用，便于维护。一段可能被反复使用的代码，就可以定义为函数，然后调用函数来使用这段代码。\n\n## 函数的创建\n\n**function 声明**\n\n```js\nfunction 函数名(参数列表) {\n  函数体\n  return 返回值\n}\n```\n\n**直接量声明**\n\n```js\nvar 函数名 = function(参数列表) {\n  函数体\n  return 返回值\n};\n```\n\n**用 new 创建**\n\n因为 Function 是内置类型，本身有一个 Function 的构造函数，所以是可以 `new` 的\n\n```js\nvar 函数名 = new Function(\"参数名1\",\"参数名2\",...,\"函数体; return 返回值\")\n```\n\n这里注意，参数和函数体都要用引号引起来，但是一般函数的创建都不会这样创建，以前面的两种为主，那其实前面两种的创建是存在一定的差别的，下面会提到\n\n## 函数的参数\n\n函数执行时必须的数据变量，它分为「 显示参数 」(Parameters)与「 隐式参数 」(Arguments)\n\n### 显示参数\n\n```js\nfunction fun(name, id) {\n  //函数体\n}\n```\n\n这种直接传进来的 `name` 和 `id` 就是显示参数，也就是你能看到的。其实函数传递的参数就相当于**在函数体内又声明了一个局部变量**\n\n```js\nvar i = 10\nfunction fun(i) {\n  i++\n  console.log(i)\n}\nfun(i)\n```\n\n上面的代码，就相当于下面的代码\n\n```js\nvar i = 10\nfunction fun() {\n  var i = 10 //这个值就是传进来的参数的值\n  i++\n  console.log(i)\n}\nfun(i) //在此处传入i\n```\n\n### 隐式参数\n\n每个 JavaScript 函数内部都有一个对象 `arguments` 对象,其实是一个类数组的对象,它会自动接受所有传入函数的参数值。\n\n```js\nfunction func(          ) {\n  //arguments[          ]\n}\n```\n\n值得一说的是, `arguments` 有下标有长度，可以通过下标来获得传入的参数，比如 `arguments[0]` 就是第一个参数, `length` 就可以遍历这个类数组对象，但是，毕竟他不是数组，所以不能进行一些数组特有的操作，比如 `sort`\n\n## 声明提前\n\n在开始执行程序前,js 引擎会首先查找 `var` 声明的变量和 `function` 声明的函数，**将其提前到当前作用域的顶部集中创建，而将赋值操作保留在原地**,这里特别说一下, **未用 `var` 声明的变量不会声明提前**.\n\n```js\nconsole.log(a) //a is not defined\na = 10\n```\n\n```js\nconsole.log(a) //undefined\nvar a = 10\nconsole.log(a) //10\n```\n\n因为声明提前,其实代码会变成下面这个样子\n\n```js\nvar a\nconsole.log(a)\na = 10\nconsole.log(a)\n```\n\n这样看，一切都变得很合理。。\n\n函数也是一样\n\n```js\nfunction fun() {\n  console.log(1)\n}\nfun() //2\nfunction fun() {\n  console.log(2)\n}\nfun() //2\n```\n\n控制台会输出两个 `2`,因为 `function` 声明的函数也会声明提前,代码其实是下面这个样子\n\n```js\nfunction fun() {\n  console.log(1)\n}\nfunction fun() {\n  console.log(2)\n}\nfun() //2\nfun() //2\n```\n\n第二次声明因为与第一次声明方法名字一样，后者覆盖了前者，所以再调用的时候就会调用最后这个\n\n但是声明提前会增加程序解读的难度，因此我们在写程序时，尽量避免声明提前所带来的危害\n\n### 声明提前的解决方法\n\n那我们既然知道会有声明提前这种操作，就在变量和函数的声明时都放在当前作用域的顶部。\n\n在 ES6 中 可以用 `let` 代替 `var`,不过要求在当前作用域中 `let` 变量之前不允许出现声明的变量, 也可以用直接量声明变量的方法\n\n```js\nvar fun = function() {\n  console.log(1)\n}\nfun() //1\nvar fun = function() {\n  console.log(2)\n}\nfun() //2\n```\n\n这种当然也会声明提前，那我们看一下声明提前后的代码\n\n```js\nvar fun\nvar fun\nfun = function() {\n  console.log(1)\n}\nfun() //1\nfun = function() {\n  console.log(2)\n}\nfun() //2\n```\n\n声明提前但是赋值还是留在原地，所以虽然有声明提前，但是并不会改变我们原本想要的结果。也就解决了声明提前带来的危害。\n\n## 匿名函数\n\n函数创建时没有指定函数名,匿名函数使用后自动释放,会节约内存,他会划分临时作用域，避免全局变量污染全局。\n\n### 用处\n\n**callback**\n\n将一个函数作为参数传入另一个函数内，被其他函数调用\n\n举个:chestnut:\n\n```js\narr.sort(function(a, b) {\n  return a - b\n})\n```\n\n```js\nstr.replace(/reg/g, function(kw,$1,$2,...){return 替换值})\n```\n\n**自调**\n\n定义函数后自己调用自己，调用结束后，立刻释放，不占内存\n\n举个:chestnut:\n\n```js\n(function(参数列表) {\n  函数体\n  return 返回值\n})(参数值列表)\n```\n\n会定义一个临时的作用域，减少使用全局变量，避免全局污染。\n\n## 重载\n\n相同函数名，不同参数列表的多个函数。在调用时，根据传入参数的不同，自动选择匹配的函数执行。这样可以减少 api 的数量，减轻调用者的负担。\n\n听起来很诱人，但是 Js 语法不支持重载，原因是 Js 不允许多个同名函数同时存在，后声明的函数会覆盖前面声明的,但是可以通过某些方法实现，这个方法就是利用 `arguments`\n\n```js\nfunction test() {\n  if (arguments.length == 0) {\n    //不传值的操作\n  } else if (arguments.length == 1) {\n    //传一个值进行的操作\n  } else {\n    //....等等\n  }\n}\n```\n\n其实也不是真正意义上的重载，因为并没有创建同名的多个函数，但是实现的效果是和重载差不多的。\n","tags":["Base"],"categories":["Explore"]},{"title":"你好！BFC!","url":"%2F2017%2F08%2F09%2F%E4%BD%A0%E5%A5%BD%EF%BC%81BFC%2F","content":"\n> BFC 这个名字听过很多次了，文章中总是说触发 BFC 然后怎样怎样，开始的时候觉得 BFC 很神秘，应该很难，当时只为解决眼前问题的我，就没有选择去了解一下 BFC，只是知道有 BFC 的存在，但并不认识他，今天终于鼓起勇气想他打个招呼，认识认识这位看似神秘的朋友.\n\n<!--more-->\n\n## 文档流\n\n我们常说的文档流分为三种，普通流，浮动流和定位流。在这里简单的介绍一下。  \n\n在「普通流」中，元素按照在 HTML 中的先后位置至上而下布局，块级元素从上到下依次排列，框之间的垂直距离由框的垂直 `margin` 计算得到。行内元素在一行中水平布置，直到占满一行则换行  \n\n「浮动流」就是元素被设置了浮动属性，一开始还是按照普通流布局，但是会根据浮动的方向移动。\n\n「定位流」就是设置了定位属性，元素完全脱离普通流。\n\n## BFC 定义\n\nBFC(Block Formating Context),直译过来就是「 块级格式化上下文 」(在 CSS3 中，BFC 叫做 Flow Root)。FC 就是其实就是普通流的意思，是一块渲染区域，有他的渲染规则。那 B 就是 block 就是块级元素。**简单的理解来说，有一块独立的渲染区域，只有 block 元素，这些 block 元素按照此渲染区域的规则布局，并且不受这个区域外部的其它元素影响。**\n\n## BFC 的触发\n\n* 根元素\n* 浮动元素\n* 绝对定位和固定定位\n* display 为 inline-block||table-cell||table-caption||flex||inline-flex\n* overflow 不是 visible\n\n满足以上任意一个条件都可以触发 BFC，这里注意一下，触发 BFC 不是元素本身变成了 BFC，而是这个元素带有了 BFC 的规则。\n\n## BFC 的规则\n\n为什么要触发 BFC，那 BFC 到底有什么规则，有什么好处呢？\n\n* Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n\n* BFC 的区域不会与 float box 重叠。\n\n* 计算 BFC 的高度时，浮动元素也参与计算\n\n## 作用\n\n其实 BFC 完全贯彻的一点就是，**BFC 是一个独立的不受外部影响的一个渲染区域，他也不会去影响别的元素。**，记住并理解这句话也就是理解了 BFC ，因为 BFC 的作用都是根据这一规则产生的\n\n### margin 重叠\n\n```css\n.box {\n  background-color: red;\n  margin: 100px;\n  width: 100px;\n  height: 100px;\n}\n```\n\n```html\n<div class=\"box\">box1</div>\n<div class=\"box\">box2</div>\n```\n\n我们知道两个 `box1` 和 `box2` 的中间间距会发生 `margin` 重叠并只有 `100px`,那是因为他们同在 html 下的一个大的 BFC 中的一个渲染区域中，我们只要让他们两个的 BFC 区域不同，他们两个就不会发生 `margin` 重叠.\n\n在 `box2` 添加 div 包裹层,然后在此包裹层中添加任意规则属性，就会发现 `margin` 重叠问题已经解决.因为此时 `box2` 身处的 `BFC` 和 `box1` 就不相同了。\n\n### 清除浮动\n\n剩下两个规则都与浮动有关，其实我听说 BFC 这个名词也是因为清除浮动，因为 BFC 不能影响外部的布局，所以计算高度时，浮动也参加运算，因此就解决了高度塌陷这个问题。\n\n## 总结\n\n前端之路还在继续，认识了 BFC 以后也会去多多了解磨合。总之现在严格记住的一点就是**他是一个独立的不影响外部也不受外部影响的区域，那其他的特性都是建立在此基础上的。**\n","tags":["Base"],"categories":["Explore"]},{"title":"谈谈值传递","url":"%2F2017%2F07%2F25%2F%E8%B0%88%E8%B0%88%E5%80%BC%E4%BC%A0%E9%80%92%2F","content":"\n> ECMAScript 变量可能包含两种不同的数据类型：「基本数据类型」和「引用数据类型」，这两种类型的**值传递**是存在不同的.在我们谈这两种数据类型的值传递前，为了便于理解，我想首先谈一下这两种数据类型有关**复制**操作存在的不同\n\n<!--more -->\n\n## 数据类型的复制\n\n### 基本类型\n\n```javascript\nvar num1 = 10 \nvar num2 = num1 \nnum2 = 11 \nconsole.log(num1)  //10\nconsole.log(num2)  //11\n```\n\n基本数据类型从一个复制到另一个，会在变量对象上**创建**一个新值，然后把该值复制到新变量分配的位置上，**改变其中一个不会影响另一个**。\n\n本小白用拙劣的画功演示一下\n\n![pic1](谈谈值传递/pic1.jpg)\n\n一开始声明变量 `num1` 并赋值为 `10`,它便以图中的形式存放在栈内存中，当用 `num1` 的值来初始化 `num2` 的时候，此时就相当于声明变量 `num2` 并赋值为 `num1` 中的值，**该值只是 `num1` 中的一个副本**，赋值结束，这两个变量便再无瓜葛，进行后面的操作也不会相互影响\n\n### 引用类型\n\n引用类型我们采用数组来讲解，数组的声明有两种方式，一种为 `var 数组名 = []` 另一种为 `var 数组名 = new array()`\n\n```javascript\nvar arr1 = [1, 2, 3, 4] \nvar arr2 = arr1 \narr2[0] = 10 \nconsole.log(arr1)  //[10,2,3,4]\nconsole.log(arr2)  //[10,2,3,4]\n```\n\n可以看出输出的结果都为 `[10,2,3,4]`， 和基本数据类型完全不同。数组的存储方式如下图所示\n\n![pic2](谈谈值传递/pic2.jpg)\n\n当声明数组变量并赋值的时候，同样也会存入一个栈结构当中，但是这个栈结构不能存 `[1,2,3,4]` 这种引用类型的数据，要存到堆内存中去，就是图片右边那个圆形的区域，但是存入的数据还是要找到它，因为每个存储位置都有其相应的地址，所以它在栈内存中存入的是一个指向数组对象数据的这样的一个地址。\n\n![pic3](谈谈值传递/pic3.jpg)\n\n因此当复制引用类型变量的时候，同样也会将**存储在栈内存中的地址值复制一份放到为新变量分配的空间中去，只不过因为这个值的副本是一个指向堆中原数组对象数据的地址，两个变量名就相当于引用了同一个地址中的内容。因此，改变其中的一个，就相当于改变了另一个**。\n\n再看下面这个:chestnut:\n\n```javascript\nvar arr3 = [1, 2, 3, 4] \nvar arr4 = arr3 \narr4 = [5, 6, 7, 8] \nconsole.log(arr3)  //[1,2,3,4]\nconsole.log(arr4)  //[5,6,7,8]\n```\n\n这个相比于前面那个，只是在第三行代码中出现了不同，`arr4 = []` 这样也是创建数组的一种方式，因此 `arr4 = [5,6,7,8]` 其实是将一个新创建的数组对象赋给变量 `arr4` ,这时 `arr4` 后的地址就改变了,也就指向了新的数组对象，这两个变量也就完全不相同了.\n\n![pic4](谈谈值传递/pic4.jpg)\n\n方便理解可以看下下面的代码\n\n```js\nconsole.log(new Array(1,2) === new Array(1,2)) //false\n```\n\n那好，现在有了这些铺垫，我们再来谈我们今天的主要内容.\n\n## 数据类型的值传递\n\n### 基本类型\n\n```javascript\nvar num = 10 \n\nfunction change(num) {\n  num = 11 \n  console.log(num)  //11\n}\n\nchange(num) \nconsole.log(num)  //10\n```\n\n在向参数传递基本类型的值时，**被传递的值会被先复制给一个局部变量**，其实就可以理解为基本数据类型的赋值。以上的代码也可以写为这样\n\n```javascript\nvar num = 10 \n\nfunction change() {\n  var num = 10  //look\n  num = 11 \n  console.log(num)  //11\n}\n\nchange(num) \nconsole.log(num)  //10\n```\n\n在 look 处，函数会将参数先声明并赋值，值就为下面传入的参数的值，`num` 的值为 `10`,因此赋得值也为 `10`。但此时函数中的 `num` 和函数外部的 `num` 其实是毫不相关的，因此并不会相互影响\n\n### 引用类型\n\n```javascript\nvar arr = [1, 2, 3, 4] \n\nfunction change(arr) {\n  arr[0] = 10 \n  console.log(arr)  //[10,2,3,4]\n}\n\nchange(arr) \nconsole.log(arr)  //[10,2,3,4]\n```\n\n引用类型也如此，也可以理解为引用类型的复制操作，在函数的开头就会将 `arr` 赋值为传来的数值，虽然也是一开始声明的引用类型的副本，**但是因为引用类型传来的数值是地址，因此函数中的 `arr` 和函数外面的 `arr` 都将引用同一个地址中的数组对象**，因为 `arr` 指向的数组对象在堆中只有一个，又是全局变量，因此这两个 `arr` 是相同的，同样我们再看那一种声明数组并赋值的.\n\n```javascript\nvar arr = [1, 2, 3, 4] \n\nfunction change(arr) {\n  arr = [4, 5, 6, 7] \n  console.log(arr)  //[4,5,6,7]\n}\n\nchange(arr) \nconsole.log(arr)  //[1,2,3,4]\n```\n\n那这个也就应该可以理解了，虽然在传参的时候传入的确实是一开始声明的数组对象的地址的副本，但是因为在函数内部又**声明了一个新的数组对象**，在这里 `arr` 引用的就是一个局部的数组对象了，而这个局部对象就会在函数结束后立即被销毁，不会影响函数外部的数组对象\n\n","tags":["Base"],"categories":["Explore"]},{"title":"关于css实现div居中问题","url":"%2F2017%2F07%2F18%2F%E5%85%B3%E4%BA%8Ecss%E5%AE%9E%E7%8E%B0div%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%2F","content":"\n> 自己最近在做有关 css 居中时发现自己不能准确的找到居中的解决方案，虽然最后也能试出解决方案，但是感觉必须深入其中，了解各个居中方案的适用场景，才能准确的写出不多余又正确的 css 代码\n\n<!--more -->\n\n## 示例代码\n\n```html\n<div class=\"header\">\n  <div class=\"nav\"></div>\n</div>\n```\n\n```css\n* {\n  margin: 0;\n  padding: 0;\n}\n.header {\n  height: 70px;\n}\n.nav {\n  height: 70px;\n  background: red;\n}\n```\n\n## 当需要居中的 div 设置了固定宽度\n\n### margin\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  width: 300px;\n  margin: 0 atuo;\n}\n```\n\n`auto` 可以理解为一样的意思，如果左右都设置 `auto`，意思就是这个 `div` 离左面的距离和右面的距离是一样的,但是此方法只适用于设置了宽度的块级元素。\n\n\b但是如果你设置了以下几种属性时，其居中效果便会消失\n\n- `postion: absolute`\n- `float`\n- `display:inline`\n\n块级元素始终独占一行，无论是否设置了宽度，未设置宽度时他会自动充满，设置了宽度时，虽然他看起来这一行并不都是他的「地盘」，但是你如果在他后面添加元素的时候，你会发现元素会被挤到下一行去。\n\n```html\n<div class=\"header\">\n  <div class=\"nav\"></div>\n  咋回事啊\n</div>\n```\n\n![pic2](关于css实现div居中问题/pic2.png)\n\n怎么肥四，为森么会发生这种情况呢，看一下下面一张图\n\n![pic3](关于css实现div居中问题/pic3.png)\n\n可以看到，虽然 `div` 设置了宽度，但是他有一种**无形的力量占据了他所在的行的剩下的空间，以至于其它元素无法与其在一行**。而这一块橙色区域也就是 `margin: 0 auto` 可调控区域，**`auto` 会根据这一部分的大小及时分配左右的距离，达到居中的效果**，当设置了绝对定位、浮动或将其设置为行内元素的时候，他这种「威慑力」便会消失，`auto` 可分配的区域便会消失\n\n![pic4](关于css实现div居中问题/pic4.png)\n\n可以看到，此时那块黄色的区域已经消失，`margin: 0 atuo` 也就随之失效了\n\n不过也有一种例外\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  width: 300px;\n  position: absolute;\n  left: 0;\n  right: 0;\n  margin: 0 atuo;\n}\n```\n\n此时虽然已经设置绝对定位，`div` 也已经脱离了标准文档流，但是 `left:0 right:0` 又让其具有了那种「威慑力」，\b`margin: 0 auto` 也就又拥有了可调控的区域\n\n![pic5](关于css实现div居中问题/pic5.png)\n\n### 绝对定位\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  width: 300px;\n  position: absolute;\n  left: 50%;\n  margin-left: -150px;\n}\n```\n\n设置绝对定位让其 `left` 属性起作用，然后设定 `left:50%`，但是因为此 `div` 本身还有宽度，因此还要添加 `margin-left:-此div宽度的一半px;` 让其真正的居中\n\n## 需要居中的 div 没有宽度\n\n很多状况下我们要居中的元素是不知道宽度的，有时候可能宽度也不是固定的，因为里面的内容有可能以后要增加，或者随着浏览器的变化此宽度可能也要跟随变化，下面将示例代码的 css 改为如下形式\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n}\n```\n\n![pic6](关于css实现div居中问题/pic6.png)\n\n可以看到，当不设置宽度的时候，此 `div` 默认是充满整个浏览器的，这样的话就无所谓居中或不居中了，通常我们要居中这个 div，是想让这个 div 中的一些信息居中，为了便于演示，我在 html 和 css 中多添加了几行代码\n\n```html\n<div class=\"header\">\n  <div class=\"nav\">\n      <ul>\n        <li>热爱前端</li>\n        <li>热爱编程</li>\n        <li>热爱生活</li>\n        <li>渴望知识</li>\n      </ul>\n  </div>\n</div>\n```\n\n```css\n* {\n  margin: 0;\n  padding: 0;\n}\n.header {\n  height: 70px;\n}\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n}\nul {\n  list-style: none;\n}\nli {\n  float: left;\n  margin-left: 30px;\n}\n```\n\n**效果图**\n\n![pic7](关于css实现div居中问题/pic7.png)\n\n此时我们应该想办法让 `div` 的宽度不是充满整个浏览器，让它的宽度仅仅就是里面内容的宽度，这样我们才能让它居中。在块状元素下，如果不设置宽度，它始终是要充满整个屏幕的。\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n  display: inline-block;\n}\n```\n\n当设置 `nav` 为行内元素，或者 `table` 元素的时候他的宽度就默认不是最大化，而是根据包裹的内容改变，也就是最小化。设置为 `position` 或者 `display:table` 也一样。\n\n![pic8](关于css实现div居中问题/pic8.png)\n\n### text-align:center\n\n用 `text-align:center` 实现元素居中，这个属性不是只能让文本元素居中，它可以让**行内元素居中**，所以只要把要居中的元素设置为行内元素，然后向其父元素添加 `text-align:center` 属性，就可以实现居中\n\n```css\n.header {\n  height: 70px;\n  text-align: center;\n}\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n  display: inline-block;\n}\n```\n\n### display:table\n\n设置 `nav` 为 `display:table` ,`nav` 就相当于说就具有了 `table` 的属性，那我们都知道 `table` 的宽度是根据其内容的多少而变化的，也就是宽度最小化，而此时 `nav` 便也可以使用 `margin:0 auto` 来居中\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n  display: table;\n  margin: 0 auto;\n}\n```\n","tags":["Base"],"categories":["Explore"]}]