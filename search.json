[{"title":"基于 mpvue 的圆形进度条组件","url":"%2F2018%2F09%2F28%2F%E5%9F%BA%E4%BA%8Empvue%E7%9A%84%E5%9C%86%E5%BD%A2%E8%BF%9B%E5%BA%A6%E6%9D%A1%2F","content":"\n> 自己本身是一个小程序小白，前几天刚开始学习。碰到一个需求是要实现多个圆形带缺口的进度条，在网上没有找到相关插件后决定自己编写一个，如果能帮到需要的人那真是太好了, 下面会介绍一下自己的实现过程，如果只关心如何用的话可以传送到下面的页面\n\n[mini-circleprogress 源码](https://github.com/MLuminary/subentry/tree/master/mini-circleProgress)\n\n<!--more-->\n\n\n## 外观\n\n![基于 mpvue 的圆形进度条](基于mpvue的圆形进度条/default.jpg)\n\n![基于 mpvue 的圆形进度条](基于mpvue的圆形进度条/gap.jpg)\n\n## 过程\n\n一开始的思路是用 svg， 自己编写完毕后，发现小程序不支持直接引入 svg， 因此最终实现是使用的小程序自带的 canvas\n\n如何画圆已经有大佬讲解过了，我就不重复劳动了，下面是链接\n\nhttps://segmentfault.com/a/1190000013219501\n\n在此说明一下此组件实现的功能和一些注意点\n\n## 完全响应式\n\n### 适应包裹元素的宽度和高度\n\n一开始的思路是设置 canvas 的宽高为 100%，发现并没有什么用，然后想获取 canvas 动态改变其宽高，发现小程序不能操作 dom, `ref` 也都不能使用。因此只能设置一个 `props`,麻烦使用者告知一下父元素的宽高，在这里因为此图形是一个正方形，所以只需要传递一个值就可以了。\n\n### 适应设备的宽度和高度\n\ncanvas 中的画布单位默认都是 px，画出来的图形是不能很好的适应宽度不同的设备的，因此自己在内部实现了一个 rpx，具体实现思路如下\n\n```js\ngetRpx () {\n  let rpx = 1 // 相对单位\n  return new Promise(resolve => {\n    wx.getSystemInfo({\n      success: function (res) {\n        rpx = res.windowWidth / 375\n        resolve(rpx)\n      }\n    })\n  })\n}\n```\n\n然后与之前的画布的数值相乘即可，想具体看怎么实现的可以去看下源码\n\n## 有关 canvas-id\n\ncanvas 在一个页面中 id 是不能相同的，就算出现相同的也只会渲染第一个，因此需要多个 canvas 只能让其 id 各不相同。使用者想使用多个圆形进度条组件的时候，请传递 `canvasId` 值。\n\n","tags":["Idea"],"categories":["Fun"]},{"title":"根据 url 获取图标及 title","url":"%2F2018%2F09%2F07%2F%E6%A0%B9%E6%8D%AEurl%E8%8E%B7%E5%8F%96%E5%9B%BE%E6%A0%87%E5%8F%8Atitle%2F","content":"\n> 最近在做一个小项目有一个类似添加书签的功能，用户点击添加后，弹出输入模块，用户只需要将需要收录的链接添加进去，便可以自动生成带有此网站图标和此网站标题的卡片\n\n<!--more-->\n\n## 设置 icon\n\n想要知道如何获取肯定要知道网站的 icon 是如何设置的，设置 icon 的方式据我了解的有两种\n\n- 一般都是在 `html` 代码的 `head` 标签中设置一个 `link` 标签，将其 `rel` 属性设置为 \"icon\" 或者 \"shortcut icon\",  `href` 就是图标的位置。\n- 大部分网站会在其根目录下放置一个`favicon.ico` 文件，也就是网站的图标。\n\n![pg1](根据url获取图标及title/pg1.png)\n\n## 获取 icon\n\n两条途径设置 icon，明显解析 html 要相对麻烦一点，因此我们先去网站根目录下去获取 favicon.ico, 如果不存在此文件，再解析 html，当然如果网站本身就没有 icon ，那就自己设置一个默认的图标就好了。\n\n我的思路是拿到需要收录的链接，然后用 `node` 的 `url` 模块去解析，再用 `get` 方法去抓取此网页，如果不是 `200` 就代表根目录下没有此文件。\n\n```js\nconst express = require('express')\nconst url = require('url')\nconst axios = require('axios')\n\nlet app = express()\n\n\napp.get('/',function(req, res) {\n  let targetUrl = 'https://github.com/MLuminary'\n  let urlString = url.parse(targetUrl)\n  let iconUrl = `${urlString.protocol}//${urlString.host}/favicon.ico`\n  isHasRootIcon(iconUrl)\n})\n\n// 判断网站根目录下是否有 favicon.ico 文件\nfunction isHasRootIcon(url) {\n   axios.get(url).then(response=>{\n     console.log(1)\n   }).catch(error=>{\n     console.log(0)\n   })\n}\n```\n\n**以上思路大部分网站还是可以的**，但是有一些网站会遇到重定向的问题，会跳到 404 页面或者 error 页面，**此时返回的 `status` 也是 `200` **，上面的方法就也会认为已找到 icon, 但实际上链接是 `html` 页面，因此我就想能不能获取到重定向后的链接，判断其类型，如果重定向的类型不是 ico、png等图片类型，就也判断为没找到。找来找去发现了 `request` 包可以实现, 下面是具体实现\n\n```js\napp.get('/',function(req, res) {\n  let targetUrl = 'http://www.12306.cn/mormhweb/'\n  let urlString = url.parse(targetUrl)\n  let iconUrl = `${urlString.protocol}//${urlString.host}/favicon.ico`\n  isHasRootIcon(iconUrl).then(res=>{console.log(res)})\n})\n\n// 判断网站根目录下是否有 favicon.ico 文件\nfunction isHasRootIcon(url) {\n  let pattern = ['ico','png', 'svg', 'jpg']\n\n  return new Promise((resolve)=>{\n    let returnValue = false\n    request.get(url,function(err, res) {\n      if(res.statusCode === 200) {\n        let redirectPath = res.request.uri.path // 重定向的页面路径\n        pattern.forEach(item=>{\n          if(redirectPath.split('.')[1]===item) {\n            // 如果结尾是 pattern 数组中的一种 则返回 true\n            returnValue = true\n            resolve(returnValue)\n          }\n        })\n      }\n      resolve(returnValue)\n    })\n  })\n}\n```\n\n如果根目录下不存在 favicon.ico 文件，则需要解析其链接的 html ，然后提取出 icon 的路径，但是这其中还有一些问题，**icon 的路径有可能是绝对路径或者是相对路径**，因此在此还需要在判断一下，下面是具体代码\n\n```js\nfunction resolveHtml(targetUrl) {\n  return new Promise(resolve=>{\n    let defaultUrl = ''// 自己默认的图片链接\n    superagent.get(targetUrl).end(function (err, content) {\n      let $ = cheerio.load(content.text)\n      let iconUrl = $(\"link[rel*='icon']\").eq(0).attr('href') // 获得 icon 的链接\n      // 如果 iconUrl 存在 还需要判断其是否是相对位置\n      if(iconUrl) {\n        // 如果不存在 'http'\n        if(iconUrl.indexOf('http') === -1 ) {\n          // 判断是否为相对路径或根路径\n          if(iconUrl.charAt(0) === '/') {\n            let urlString = url.parse(targetUrl)\n            iconUrl = `${urlString.protocol}//${urlString.host}${iconUrl}`\n          }else {\n            iconUrl = targetUrl + \"/\" + iconUrl\n          }\n        }\n        resolve(iconUrl)\n      }else {\n        resolve(defaultUrl)\n      }\n    })\n  })\n}\n```\n\n获取 icon 连接时为什么我加了一个 `eq(0)` 呢，是因为我发现有些网站有两种类型的 `link` 可以添加图标，一种是`shortcunt icon` 一种是 `icon`，因此我们只要获取其中一个就可以了，两个都获取到可能会报错。\n\n## 获取title\n\n获取 title 就相当于解析 Html 获取 icon, 还是比较简单的，在此就不放代码了。\n\n## 成果\n\n下面就是传入掘金首页抓取到的信息\n\n![pg2](根据url获取图标及title/pg2.png)","tags":["Idea"],"categories":["Fun"]},{"title":"获取百度搜索提示结果","url":"%2F2018%2F08%2F15%2F%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E6%90%9C%E7%B4%A2%E6%8F%90%E7%A4%BA%E7%BB%93%E6%9E%9C%2F","content":"\n> 最近自己想做的项目需要一个搜索框，并想实现如下搜索提示的功能\n\n![pg1](获取百度搜索提示结果/pg1.jpg)\n\n本来觉得查查 network 随便抓取一下就可以获得到数据，但事情却不是这么简单\n\n<!--more-->\n\n### 过程\n\n在百度在随便输入字符，查看 network，找到此时请求的链接\n\n![pg2](获取百度搜索提示结果/pg2.png)\n\n会发现使用 get 方式传了四个值,其中 `p` 和 `cb` 都是可以固定的，剩下的就是关键字 `wd` 和此时的时间戳 `t`，自己因为本身是 vue 的项目，就用 `axios` 对此进行请求，结果报错为 **跨域** 并且 **中文乱码**\n\n#### gzip\n\n因为发生了跨域，因此就想用 `node` 去修改请求头去请求，「后来发现用 `node` 去请求不需要修改请求头也不会跨域」，但是还有一个问题返回的中文都是乱码。然后我就去关注了一下响应头，如上面的图片，其中 `content-encoding: gzip` 引起了我的注意。\n\ngzip 是什么在此我就不做过多的解释，去网上查只是说想要**获取 gzip 格式的网页信息需要解压，要不然获得到的信息会是乱码**，其中用到了 `zlib` 和 `request` 两个包\n\n```js\n  zlib = require('zlib');\n\nfunction response (err, res, body) {\n//check res header it is gzip\n console.log(res.headers['content-encoding'])\n//now body it is gzip stream buffer\n      zlib.unzip(body, function(err, buffer) {\n             console.log(buffer.toString())\n       }\n\n}\n    request.get({\n        url : apiUrl,\n        headers: {\n            'Accept-Encoding' : 'gzip',\n          },\n        encoding : null  // it is very import!!\n    }, response)\n```\n\n但是我满怀期待的将其解压提取信息后获得的结果依然是乱码，make my heart cold cold\n\n**gbk**\n\n最后又把目光转向响应头，感觉 `charset=gbk` 好像有点东西, 其中用到了 `iconv-lite` ，是一个转编码的工具，`iconv.decode` 接受到第一个参数必须是 `buffer`, 而 `request` 获取到的信息返回的也是 `buffer` 我就感觉冥冥之中放佛预示着什么\n\n```js\nrequest({\n        url,\n        encoding : null\n    }, function(err, response, body) {\n        res.setHeader('Content-Type', 'application/json; charset=utf-8')\n        res.end(iconv.decode(body, 'gbk'))\n    })\n```\n\n因此将响应头设置为 utf-8 并将其 gbk 编码转换为 utf-8 后成功的获得到了需要的信息, 下面就是将此 api 部署到我自己的服务器上，关于部署碰到的一些问题基本都在我另一篇文章中有谈到 [记一次oneinstack配置服务器](https://github.com/MLuminary/Blog/issues/15)\n\n[阅读原文](https://github.com/MLuminary/Blog/issues/16)\n\n","tags":["Idea"],"categories":["Fun"]},{"title":"让服务器带点绿","url":"%2F2018%2F07%2F28%2F%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B8%A6%E7%82%B9%E7%BB%BF%2F","content":"\n> 这段时间终于感觉自己步入正轨，也相对稳定了下来。便想搞点事情，想做一个网站，包含自己一些平时想要的工具和一些自己想关注的咨询。然后发现自己的服务器竟然一点都不绿，所以就花了一些时间绿化了自己的服务器。\n\n<!--more-->\n\n## nginx 上 https\n\n### 申请证书\n\n我自己用的是腾讯云服务器，因此证书就去腾讯云官方网站去申请，当然不是腾讯云的话还有几个比较权威的颁发证书的网站，例如 [StartSSL](https://www.startcomca.com),当然如果你的服务器是 Linux 的话，你也可以用默认安装的 OpenSSL\n\n但是 OpenSSL 的方法我没有试过，具体可以参考 \n\nhttps://www.cnblogs.com/chjbbs/p/5748369.html\n\n腾讯云的申请证书还是比较简单，打开下述链接\n\nhttps://console.cloud.tencent.com/ssl\n\n点击申请证书，然后根据其提示一步步填写，审核成功后下载证书，下载证书后里面的文件如下\n\n![pg1](让服务器带点绿/pg1.png)\n\n打开 Nginx，里面包含着一个证书文件和一个 .key 文件。\n\n### 配置 nginx\n\n打开服务器中的 nginx/conf 文件夹，在其中创建一个文件夹为 ssl，再创建一个文件夹为域名，这个完全看自己的习惯，在后面的配置项中只要路径对就可以。我的证书和 .key 文件的位置就在 nginx/conf/ssl/www.haoqinzz.cn/ 下\n\n然后找到 nginx.conf 文件，将其中如下代码解开封印并修改为如下代码\n\n```conf\n# HTTPS server\n    \n    server {\n       listen       443;\n       server_name  localhost;\n\n       ssl                  on;\n       ssl_certificate      ssl/www.haoqinzz.cn/1_www.haoqinzz.cn_bundle.crt;\n       ssl_certificate_key  ssl/www.haoqinzz.cn/2_www.haoqinzz.cn.key;\n\n       ssl_session_timeout  5m;\n\n       ssl_protocols  SSLv2 SSLv3 TLSv1;\n       ssl_prefer_server_ciphers   on;\n       \n       ssl_dhparam ssl/certs/dhparam.pem;\n       ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\";\n       keepalive_timeout 70;\n       ssl_session_cache shared:SSL:10m;\n\n       add_header Strict-Transport-Security max-age=63072000;\n       add_header X-Frame-Options DENY;\n       add_header X-Content-Type-Options nosniff;\n\n\n       location / {\n           root   html;\n           index  index.html index.htm;\n       }\n    }\n```\n\n然后再重启一下 nginx 服务即可，然后输入 https://haoqinzz.cn 就可以看到 nginx 的欢迎页，但此时你输入 http://haoqinzz.cn 还是可以访问的，所以如果想要全站都上 https ，还需要修改 http 的服务，将 http 重定向到 https 中\n\n```conf\nserver {\n    listen       80;\n    server_name  haoqinzz.cn www.haoqinzz.cn;\n    return 301 https://haoqinzz.cn$request_uri;\n}\n```\n\n这样你输入 http://haoqinzz.cn 会跳到 https://haoqinzz.cn 中，但是现在还存在一个很大的问题，就是我以前的项目也无法访问到了。。\n\n## 让服务器中的项目重新运行\n\n### 基本项目\n\n服务器上 https 后，首页改变了，所有项目都没了，我就去看了一下 nginx 的配置文件\n\n```conf\n# HTTPS server\n    \n    server {\n       listen       443;\n       server_name  localhost;\n\n       ssl                  on;\n       ssl_certificate      ssl/www.haoqinzz.cn/1_www.haoqinzz.cn_bundle.crt;\n       ssl_certificate_key  ssl/www.haoqinzz.cn/2_www.haoqinzz.cn.key;\n\n       ssl_session_timeout  5m;\n\n       ssl_protocols  SSLv2 SSLv3 TLSv1;\n       ssl_prefer_server_ciphers   on;\n       \n       ssl_dhparam ssl/certs/dhparam.pem;\n       ssl_ciphers \"EECDH+ECDSA+AESGCM EECDH+aRSA+AESGCM EECDH+ECDSA+SHA384 EECDH+ECDSA+SHA256 EECDH+aRSA+SHA384 EECDH+aRSA+SHA256 EECDH+aRSA+RC4 EECDH EDH+aRSA !aNULL !eNULL !LOW !3DES !MD5 !EXP !PSK !SRP !DSS !RC4\";\n       keepalive_timeout 70;\n       ssl_session_cache shared:SSL:10m;\n\n       add_header Strict-Transport-Security max-age=63072000;\n       add_header X-Frame-Options DENY;\n       add_header X-Content-Type-Options nosniff;\n\n\n       location / {\n           root   html;\n           index  index.html index.htm;\n       }\n    }\n```\n\n发现 https 的 root 文件夹为 html，因此我将原本的文件迁过来就可以访问了。:fist:\n\n### nginx 反向代理项目\n\n在服务器上我还有过一个用 nginx 实现反向代理的项目，升 https 后毫无疑问 api 全部都是 404 了\n\n找到 nginx 反向代理的配置文件，将 Listen 端口 80 改为 443 ，并将以前的 http 协议都改为 https，然后此时再打开就可以找到 url ，但是会报 502 错误，经过仔细排查后发现这是因为我当时用 http 起的服务，要改为 https 并配置证书文件\n\n```js\nvar https = require('https');\nconst fs = require('fs');\n\nconst options = {\n  key: fs.readFileSync('key文件'),\n  cert: fs.readFileSync('crt文件')\n};\n\nvar server = https.createServer(options,app);\n```\n\n这样数据便又可以获取到了\n\n### oneinstack 一键配置\n\n你也可以使用 Oneinstack 傻瓜式上 https ，\b\b也就是 `~/oneinstack/vhost.sh`, 具体可以看 oneinstack 官网的[教程](https://oneinstack.com/install/)","tags":["Server"],"categories":["Explore"]},{"title":"记一次 oneinstack 配置服务器","url":"%2F2018%2F06%2F25%2F%E8%AE%B0%E4%B8%80%E6%AC%A1oneinstack%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8%2F","content":"\n> 因为自己是大学生，所以一直都是用的腾讯云学生机，但是前几天腾讯突然告诉我腾讯云学生认证到期了，可能是当时填错了，没办法我就又申请了学生认证😂，谁让我还是学生呢，但是以前老的学生优惠的学生机就不能再按照学生优惠的方式续费了，所以我又买了一个新的服务器。买完服务器准备手动开始各种配置的时候便发现了一个神器，也就是接下来要介绍给大家的。就是 [oneinstack](https://oneinstack.com/) ,可以傻瓜式「一键」安装，想看碰到的 bug 及一些解决方案可以直接跳过配置服务器部分。<a href=\"#遇到的问题\">jump</a>\n\n<!--more-->\n\n## 配置服务器环境\n\n我写此博客时 oneinstack 的版本为 2018-04-24, 其使用方式如下\n\n### 基本安装\n\n```shell\nyum -y install wget screen curl python #for CentOS/Redhat\n# apt-get -y install wget screen curl python #for Debian/Ubuntu\n\n# 下载源码与脚本\nwget http://mirrors.linuxeye.com/oneinstack-full.tar.gz #包含源码，国内外均可下载\n\n# 解压\ntar xzf oneinstack-full.tar.gz\n\n# 如果需要修改目录(安装、数据存储、Nginx日志)，请修改options.conf文件\ncd oneinstack \n\n# 如果网路出现中断，可以执行命令`screen -R oneinstack`重新连接安装窗口\nscreen -S oneinstack \n\n# 注：请勿sh install.sh或者bash install.sh这样执行\n./install.sh \n\n# 接下来根据其指示和自己喜好安装需要的软件即可\n```\n\n### node 安装\n\noneinstack 不支持 node 环境的安装，作为一个前端er, node 还是不可获取的，以前我配置 node 都是去官网下载然后解压然后建立全局软链接的形式，这次也是换了一个更简单的方式\n\n#### node.js v.8x 安装命令\n\n```shell\n#curl --silent --location https://rpm.nodesource.com/setup_8.x | bash -\n```\n\n#### 安装node\n\n```shell\nyum install -y nodejs\n```\n\n#### 查看 nodejs 安装版本\n\n```shell\nnode -v\n```\n\n至此 node 就已经安装完成，也是全局变量，相比以前也省了很多时间和力气，如果需要也可以安装 nodejs 的版本管理工具，但是在这里我没有安装，正确与否我没有尝试\n\n### node.js版本管理器n\n\n#### 安装n\n\n```\nnpm install -g n1\n```\n\n#### 安装指定版本\n\n```\n#n <version>1\n```\n\n#### 安装最新版本\n\n```\n# n latest1\n```\n\n#### 安装稳定版本\n\n```\n#n stable1\n```\n\n#### 删除某个版本\n\n```\n#n rm <version> 1\n```\n\n#### 查看所有版本\n\n```\n#n list\n```\n\n## 其他配置\n\n### 添加附加组件\n\n```shell\n./addons.sh\n```\n\n### 创建 FTP 虚拟用户账户\n\n```shell\n./pureftpd_vhost.sh\n```\n\n### 增删虚拟主机\n\n```shell\n# 增加虚拟主机./vhost.sh# 删除虚拟主机\n./vhost.sh\n```\n\n### 备份和自动备份\n\n```shell\n# Set backup options ./backup_setup.sh # Start backup, You can add cron jobs./backup.sh # crontab -l # Examples 0 1 * * * cd ~/oneinstack;./backup.sh  > /dev/null 2>&1 &\n```\n\n### 更新版本\n\n```shell\n./upgrade.sh\n```\n\n### 卸载\n\n```shell\n./uninstall.sh\n```\n\n## 管理服务\n\nNginx/Tengine/OpenResty:\n\n```\nservice nginx {start|stop|status|restart|reload|configtest}\n```\n\nMySQL/MariaDB/Percona:\n\n```\nservice mysqld {start|stop|restart|reload|status}\n```\n\nPostgreSQL:\n\n```\nservice postgresql {start|stop|restart|status}\n```\n\nMongoDB:\n\n```\nservice mongod {start|stop|status|restart|reload}\n```\n\nPHP:\n\n```\nservice php-fpm {start|stop|restart|reload|status}\n```\n\nHHVM:\n\n```\nservice supervisord {start|stop|status|restart|reload}\n```\n\n**注**：hhvm进程交给supervisord管理，了解更多请访问《[Supervisor管理hhvm进程](https://blog.linuxeye.com/408.html)》\nApache:\n\n```\nservice httpd {start|restart|stop}\n```\n\nTomcat:\n\n```\nservice tomcat {start|stop|status|restart}\n```\n\nPure-Ftpd:\n\n```\nservice pureftpd {start|stop|restart|status}\n```\n\nRedis:\n\n```\nservice redis-server {start|stop|status|restart}\n```\n\nMemcached:\n\n```\nservice memcached {start|stop|status|restart|reload}\n```\n\n## 启用 mysql 服务\n\noneinstack 默认仅允许主机本机链接数据库，需要远程连接数据库的话，需要打开对应端口\n\n### 打开 3306 端口\n\nCentOS 系统\n\n```shell\niptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT # 允许访问 3306\nservice iptables save #保存 iptables 规则\niptables -nvl # 查看 iptables 规则\n```\n\nUbuntu/Debian \n\n```shell\niptables -I INPUT 4 -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT # 允许访问 3306\niptables-save > /etc/iptables.up.rules #保存 iptables 规则\n```\n\n### 数据库授权\n\n#### MySQL8.0版本\n\n```shell\n# mysql -uroot -p\n MySQL [(none)]> create user db_user@'%' identified by 'db_pass'; #创建用户\n MySQL [(none)]> grant all privileges on db_name.* to db_user@'%' with grant option; #授权\n MySQL [(none)]> exit; #退出数据库控制台，特别注意有分号\n```\n\n#### 其余MySQL版本\n\n```shell\n# mysql -uroot -p\n MySQL [(none)]> grant all privileges on db_name.* to db_user@'%' identified by 'db_pass'; #授权语句，特别注意有分号\n MySQL [(none)]> flush privileges;\n MySQL [(none)]> exit; #退出数据库控制台，特别注意有分号\n```\n\n## 服务器https\n\n以前的服务器 https 都是自己上的，使用 oneinstack 可以一键让自己的服务器带点绿 :green_apple: \n\n运行`./vhost.sh` 就会跳到配置虚拟环境界面，oneinstack 采用 Let's Encrypt https 证书，免费使用为 90 天，到期后 oneinstack 会自动帮你续费，配置完毕后在默认文件夹里添加项目就可以输入网址以 https 的方式访问\n\n## 遇到的问题\n\n### 无法访问带端口域名\n\n我自己创建了一个二级域名 api.×××× 来作为我一些 api 接口的提供网址，然后想用 oneinstack 为其上https，向服务器中上传 node 文件用 pm2 跑起来后，本来在本地 localhost:3000 可以访问的文件，到了服务器后无法通过 api.××××:3000 来访问，最开始想到了类似阿里云安全组的问题，然后我去后台看了下我的服务器的安全组，并没有禁用 3000 端口。后来脑子里自己冒出来了一个想法，用 nginx 反向代理，在这里我就不具体给出反向代理的代码了，格式很简单，就是访问 api.××××/getApi 相当于访问 api.××××:3000/getApi ,然后竟然就成功访问到了 :zap:\n\n2018/9/10: oneinstack 默认端口都是不开放的，因此我感觉是未将 3000 端口开放的原因\n\n### 引用 api 碰到的跨域问题\n\n主域名下的项目引用 api.×××× 下的 api 是要跨域的，谷歌搜索到的解决方案基本是如下代码\n\n```js\napp.all('*', function(req, res, next) {\n    res.header(\"Access-Control-Allow-Origin\", \"*\")\n    res.header(\"Access-Control-Allow-Headers\", \"Content-Type,Content-Length, Authorization, Accept,X-Requested-With\")\n    res.header(\"Access-Control-Allow-Methods\",\"PUT,POST,GET,DELETE,OPTIONS\")\n    res.header(\"X-Powered-By\",' 3.2.1')\n    if(req.method==\"OPTIONS\") res.send(200)/*让options请求快速返回*/\n    else  next()\n})\n```\n\n但是并没有解决我的跨域问题，我是在 nginx 反向代理时加入如下代码实现的\n\n```conf\nlocation / {  \n    add_header Access-Control-Allow-Origin *;\n\t...\n} \n```\n\n### https 引用 http 下的接口报错\n\n我的 api.×××× 域名在开始的时候上 https 并没有成功，我就使用的是 http 协议，但是解决了跨域问题后又报错，报错的内容大致就是 https 下无法引用 http 中的接口，最后我其实换了一个域名又上了 https ... :joy_cat:\n\n## 最后\n\n最后基本项目都已部署到了服务器上，访问项目也有耀眼的小绿标，还是 hin 开心的","tags":["Oneinstack"],"categories":["Explore"]},{"title":"前端安全","url":"%2F2018%2F05%2F30%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%2F","content":"\n> 最近一直在准备面试，被问到了解 XSS 时答出不了解还是很惭愧的，作为前端开发人员，安全这方面是必须要非常重视的，因此决定拿出了一段时间来重点了解一下关于前端的安全问题，在这里以 XSS 和 CSRF 为主\n\n<!--more-->\n\n## XSS\n\nXSS(Cross-site script)因为与 CSS 简写重合所以改为 XSS\n\n其原理是**向网站中插入恶意的 HTML 代码**。当其他用户浏览该网站的时候，该段 HTML 代码会自动执行，从而达到攻击的目的。如盗取用户的 Cookie，页面重定向，破坏页面结构\n\n**举个**:chestnut:\n\n网站的评论系统没有过滤 XSS 攻击，当有用户添加评论为\n\n```js\n<script>\n  while(true) {\n    alert(\"1\")\n  }\n</script>\n```\n\n这段代码就会插入到此网站的 DOM 结构中，因为没有过滤掉或进行处理，此段代码也会执行。\n\n### XSS 分类\n\nXSS 分为两种类型：「持久型 XSS」 和 「非持久型 XSS」\n\n**持久型 XSS**「存储型」\n\n持久型 XSS 就是对客户端攻击的脚本直接植入到服务器上，从而导致每个用户访问此网站都会遭到 XSS 的攻击\n\n**非持久型 XSS**「反射型」\n\n非持久型 XSS 是对一个页面的某个参数做文章，把精心构造好的恶意脚本包装在 URL 参数中，再讲 URL 发布到网上，骗取用户访问\n\n手段主要有\n\n* HTML 节点内容的注入 例如 添加评论\n* HTML 属性 例如 通过 url 传值动态修改 `img` 的 `src`\n* javascript 代码 例如 传递的变量添加双引号并在双引号后面添加要注入的脚本\n\n### 防御 XSS\n\n对于非持久型 XSS\n\n* 现代浏览器都对 xss 有了一定的防范作用，但也仅限于 html 节点和属性的注入。\n* Web 页面渲染的所有内容和数据必须来自于服务器\n* 尽量不使用 `eval`, `new Function()`,`window.setTimeout()`,`innerHTML`等可执行字符串的方法\n* 前端渲染的时候要对任何字段都需要做转义\n* 对于用户输入的要添加限制，比如用户名和密码只允许字符和数字，email 必须为 email 格式\n* 对于富文本采用**过滤**，可以通过国人写的 [xss](https://github.com/leizongmin/js-xss)\n\n对于持久型 XSS\n\n* 后端在入库的时候不相信任何前端的数据，将所有的字段统一进行转义处理\n* 后端在传递给前端数据的时候统一做转义处理\n* 前端不相信后端传来的数据，任何字段也都需要做转义处理\n\n**举个栗子**:chestnut:\n\n先看一下后台的代码「node.js」\n\n```js\napp.get('/api/xss', function(req, res) {\n  res.setHeader('X-XSS-Protection', 0) //关闭浏览器 XSS\n\n  res.json('hutchins <script>console.log(1)</script>') //模拟XSS攻击，后台返回了带脚本的字符串\n})\n```\n\n前台代码\n\n```js\n$.ajax({\n  type:'get',\n  url:\"http://localhost:3003/api/xss\",\n  dataType:'json',\n  success:function(data){\n    $('#uname').html(data) //这样在前台就会插入 script 标签\n  }\n})\n```\n\n这样便会在前台插入脚本代码并在控制台打印 `1`，那么对于此类代码就需要将其转义，让其无法运行，在 `success` 方法中改为如下代码\n\n```js\n//进行HTML转义后便会插入正常的内容\nvar str = data\nstr = str.replace(/</g,'&lt')\nstr = str.replace(/>/g,'&gt')\n$('#uname').html(str)\n\n//但其实这样也可以完美插入\n$('#uname').text(data) \n```\n\n## CSRF\n\nCSRF 「Cross-site request forgery」中文名称为跨站请求伪造\n\n攻击者盗用了你的登录信息，以你的身份模拟发送各种请求。\n\n完成 CSRF 攻击有**三个条件**\n\n* 用户已经登录了站点 A，并且在本地保留了 cookie\n* 在用户没有登出站点的情况下**也就是 cookie 还在生效的情况下**访问了攻击者提供的危险站点 B\n* 站点 A 没有任何 CSRF 防御\n\n### CSRF 手段\n\n拿发表评论为例，就是用户登录后编写评论点击发表这种操作，如果发表评论是 `get` 请求\n\n那 CSRF 攻击者可以通过在自制的 B 危险网站上面写一个 `a` 标签，然后由 `a` 标签模拟你点击评论发起的 `get` 请求，当你点击时，就会在 A 网站添加一个评论，这也是为什么 CSRF 叫 「one click attack 一点就爆炸」，当然也可以直接写一个图片在你不知情时发送 `get` 请求\n\n那你此刻会想，那把添加评论改成 `post` 请求应该就安全了吧\n\n改成 `post` 请求，攻击者可以在 B 网站用 js 动态生成表单，然后发送 `post` 请求，更高级点可以再生成一个隐藏的 `iframe` 让表单 `target` 指向其 `name`，让你在完全没有察觉的情况下以你的名义干一些羞羞的事情\n\n### CSRF 防御\n\n**从 cookie 方面下手**\n\n* 禁止止第三方网站使用 cookie，使用 `sameSite:Strict` 目前仅有 chrome 支持\n\n**从绕过前端页面下手**\n\n* 在前端页面加入验证信息，可以使用 [ccap](https://github.com/DoubleSpout/ccap)\n* 加入 token，token 在前端页面 `cookie` 和 后端必须保持一致，如果是 `ajax` 请求的话可以在前端页面 `meta` 处添加一个 `token` 属性，然后用 `js` 动态获取\n\n**referer 为 B 网站**\n\n验证 referer `/^域名/`，这里注意一下，如果你是用本地文件测试的话，`file` 协议是没有 referer 的\n","tags":["Safe"],"categories":["Explore"]},{"title":"跨域问题总结","url":"%2F2018%2F05%2F28%2F%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93%2F","content":"\n> 跨域问题是日常中必须要面对的，每次面试必考跨域也体现了跨域技术的重要性，跨域的文章也多的数不过来，今天这篇文章主要是用来总结自己每种跨域技术的尝试，如果有幸能帮到别人那就再好不过了\n\n<!--more-->\n\n## 大概\n\n自己用 node 搭了两个服务器，前台设置的端口为 3002，模拟的服务端设置的端口为 3001\n\n跨域问题的出现是由于「同源策略」引起的，「同源」就指的是三个相同，即「协议相同」、「域名相同」、「端口相同」，「同源策略」使得以下三种行为受到限制\n\n* Cookie、LocalStorage 和 IndexDB 无法获取\n* DOM 无法获取\n* Ajax 请求无法发送\n\n具体情况还请移步[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)\n\n自己在这还是稍微总(jie)结(jian)一下，写一遍加深一下印象\n\n## 对于 Cookie 和 iframe\n\n对于 Cookie 和 iframe ，如果两个网页一级域名相同，只是二级域名不同，比如 `a.hutchins.com` 和 `b.hutchins.com` ，浏览器可通过设置相同的 `document.domain`\n\n```js\ndocument.domain = 'hutchins.com'\n```\n\n服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如\n\n```js\nSet-Cookie: key=value; domain=hutchins.com; path=/\n```\n\n这样的话二级域名和三级域名不做任何设置就可以读取这个 Cookie\n\n## window.postMessage\n\nH5 引入了全新的 API :「跨文档通信 API」\n\n```js \notherWindow.postMessage(message, tragetOrigin);\n```\n\n* `otherWindow` 窗口\n* `message` 要发送的信息\n* `targetOrigin` 指定哪些窗口可以接受到信息，`*` 表示无限制\n\n接收窗口通过 `message` 方法接收\n\n```js\nwindow.addEventListener('message' function(e) {\n\n})\n```\n\n`message` 的事件对象有以下三个属性\n\n* event.source 发送消息的窗口\n* event.origin 消息发向的网址\n* event.data 发送的消息\n\n## AJAX 跨域\n\n### jsonp 跨域\n\njsonp 的原理就是动态创建 `script` 标签，然后用 `script` 的 `src` 属性引用外部跨域链接，通过**回调函数参数**接受后台传递的信息\n\n```js\n//原生js\nvar script = document.createElement('script')\nscript.type = 'text/javascript'\n\n//传参并指定回调函数执行函数为onBack\nscript.src = 'http://localhost:3001/api/jsonp?uname=hutchins&callback=onBack'\ndocument.body.appendChild(script)\n\n//回调执行函数\nfunction onBack(res) {\n  console.log(JSON.stringify(res))\n}\n```\n\n```js\n//利用jquery ajax\n$.ajax({\n  url: 'http://localhost:3001/api/jsonp?uname=hutchins',\n  type: 'get',\n  dataType: 'jsonp', // 请求方式为jsonp\n  jsonpCallback: 'onBack', // 自定义回调函数名\n  data: {},\n  success: function(data) {\n    console.log(data)\n  }\n})\n```\n\n```js\n//node 后台处理前端请求的函数\nmodule.exports = {\n  //jsonp\n  jsonpf: function(req, res) {\n    var params = req.query\n    var fn = req.query.callback\n\n    res.writeHead(200, { 'Content-Type': 'text/javascript' })\n    res.write(fn + '(' + JSON.stringify(params) + ')')\n    res.end()\n  }\n}\n```\n\n但是 jsonp 只能支持 Get 请求\n\n### 跨域资源共享 「CORS」\n\n请求分为「简单请求」和「非简单请求」，而处理这两种请求的方式很不同，这里只说一下「简单请求」\n\n请求方式为以下几种\n\n* HEAD\n* GET\n* POST\n\nHTTP 的消息头不超出以下几种字段\n\n* Accept\n* Accept-Language\n* Content-Language\n* Last-Event-ID\n* Content-Type 只限于 application/x-www-form-ulrencoded、multipart/form-data、text/plain\n\n```js\n// 原生js\nvar xhr\nif (window.XMLHttpRequest) {\n  xhr = new XMLHttpRequest()\n} else {\n  xhr = new XDomainRequest() //兼容 IE8/9\n}\n\n//前端设置 cookie\nxhr.withCredentials = true\n\nxhr.open('post', 'http://localhost:3001/api/cors', true)\nxhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')\nxhr.send('uname=hutchins')\n\nxhr.onreadystatechange = function() {\n  if (xhr.readyState == 4 && xhr.status == 200) {\n    console.log(xhr.responseText)\n  }\n}\n```\n\n```js\n//跨域后台设置\nres.writeHead(200, {\n  'Access-Control-Allow-Credentials': 'true', //后端允许发送 cookie\n  'Access-Control-Allow-Origin': 'http://localhost:3002'\n  // 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly'  // HttpOnly的作用是让js无法读取cookie\n})\n\nres.write(JSON.stringify(postData))\nres.end()\n```\n","tags":["CrossDomain"],"categories":["Explore"]},{"title":"FlexDisplayRoom","url":"%2F2018%2F05%2F25%2FFlexDisplayRoom%2F","content":"\n> 前段时间面试发现有很多都问 flex 布局，就觉得灰常有必要去学习一下，浏览了一遍[阮一峰大神写的教程](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?^%$)后掌握了基本理论，但始终觉得应该实践一下，偶然间看到下面这样一个网站\n\n<!--more-->\n\nhttps://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos/ \n\n**应该要翻墙**才能进去，这个网页在手机端需要不断的上下滑动，个人感觉有必要修改一下，就萌生了也做一个类似的想法，当然自己手机端做的也不是那么好，但是在做的过程中也学到了一些适应手机端的一些知识\n\n[项目展示地址](http://www.haoqinzz.cn/FlexDisplayRoom/)\n\n[项目源码地址](https://github.com/MLuminary/subentry/tree/master/FlexDisplayRoom)\n\n## Flex 布局的基础知识\n\n采用 flex 布局的元素，称为 Flex 容器，它的所有子元素自动成为容器成员，成为 Flex 项目\n\n### 容器的属性\n\n以下属性第一个取值为默认值\n\n**flex-direction**\n\n- row : 主轴为水平方向，起点在左端\n- row-reverse : 主轴为水平方向，起点在右侧\n- column : 主轴为垂直方向，起点在上沿\n- column-reverse : 主轴为垂直方向，起点在下沿\n\n**flex-wrap**\n\n- nowrap : 不换行\n- wrap : 换行，第一行在上方\n- wrap-reverse: 换行，第一行在下方\n\n**flex-flow**\n\n`flex-flow` 是 `flex-direction` 和 `flex-wrap` 的简写形式，默认值为 `row nowrap`\n\n**justify-content**\n\n- flex-start :  左对齐\n- flex-end : 右对齐\n- center : 居中\n- space-between : 两端对齐，项目之间间隔都相等\n- space-around : 每个项目两侧的间隔相等\n\n**align-items**\n\n- stretch : 如果项目未设置高度或设为 auto ，将占满整个容器的高度\n- flex-start : 交叉轴的起点对齐\n- flex-end : 交叉轴的终点对齐\n- center : 交叉轴的中点对齐\n- baseline : 项目的第一行文字的基线对齐\n\n**align-content**\n\n- stretch : 轴线占满整个交叉轴\n- flex-start : 与交叉轴的起点对齐。\n- flex-end : 与交叉轴的终点对齐。\n- center : 与交叉轴的中点对齐。\n- space-between : 与交叉轴两端对齐，轴线之间的间隔平均分布。\n- space-around : 每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n\n### 项目的属性\n\n**order**\n\n定义项目的排列顺序，属性值越小，排列越靠前，默认为 0\n\n**flex-grow**\n\n定义项目的放大比例，默认为 0 ，即如果存在剩余空间也不放大\n\n**flex-shrink**\n\n定义项目的缩小比例，默认为 1 ，即如果空间不足，项目将自动缩小，负值对该属性无效\n\n**flex-basis**\n\n定义了在分配多余空间之前，项目占据的主轴空间。默认值为 `auto` 即项目本来的大小\n\n**flex**\n\n`flex` 是 `flex-grow`、`flex-shrink` 和 `flex-basis` 的简写，默认值为 `0 1 auto` \n\n该属性有两个快捷值 : `auto`(`1 1 auto`) 和 `none`(`0 0 auto`)\n\n**align-self**\n\n`align-self` 允许单个项目与其它项目有不一样的对其方式，可覆盖 `align-items`。默认值为 `auto`，表示继承父元素的 `align-items` 属性\n","tags":["Css"],"categories":["Fun"]},{"title":"性感慕课-在线被爬","url":"%2F2018%2F05%2F20%2F%E6%80%A7%E6%84%9F%E6%85%95%E8%AF%BE-%E5%9C%A8%E7%BA%BF%E8%A2%AB%E7%88%AC%2F","content":"\n> 在学习了 alsotang 大神的 《Node.js包教不包会》后的一个爬虫小练习，期间也碰到挺多小问题，也学到了很多小东西。「 单押×3 」:trollface: <br> 这里是大神的教程地址 https://github.com/alsotang/node-lessons，\n\n<!--more-->\n\n下面是自己的爬取效果图\n\n![spider2](性感慕课-在线被爬/spider2.png)\n\n[imoocSpider练习源码](https://github.com/MLuminary/subentry/blob/master/easySpider/imoocSpider/app.js)\n\n\n## 搭建服务器\n\n首先，搭建一个 http 服务\n\n```js\nvar http = require('http')\nvar express = require('express')\n\nvar app = express()\n\nhttp.createServer(app).listen(8080)\n\napp.get('/', function(req, res) {\n  //code here...\n})\n```\n\n用的是 `express` 搭建的，当然也可以用原生的，在这里自己比较习惯用 [express](http://www.expressjs.com.cn/)\n\n## 在线爬虫\n\n在这里用到的是 `superagent` 和 `cheerio` 来爬取页面，这里有相关文档可以参考: [superagent中文文档](https://cnodejs.org/topic/5378720ed6e2d16149fa16bd)、[cheerio](https://cnodejs.org/topic/5203a71844e76d216a727d2e)，都是来自 cnode 社区，当然英语能力较好的也可以参考原文档。在这里就只贴出这两个\n\n爬取页面链接 https://www.imooc.com/course/list?c=fe\n\n我们是要爬取慕课网前端开发八个页面的课程中的一些信息，但是打开此链接发现每个页面只有课程的名称，并没有老师的名称和一些课程的主要信息。因此我们还需要获取并根据每个课程的 url 进行爬取。\n\n**获取课程详情页链接**\n\n那我们先来爬取八个页面的所有课程详情页的 `url`\n\n通过点击对应页面的按钮，发现每次都会发送一个新的 get 请求，请求的链接就是对应的页面，而这里的链接只有 `page` 属性是不同的，因此我们通过动态改变 `page` 就可以模拟点击对应页来获取对应页的信息\n\n```js\nvar pages = 1\nvar baseUrl = 'https://www.imooc.com/course/list/'\n\nvar params = {\n  c: 'fe',\n  page: page\n}\n\nsuperagent\n  .get(baseUrl)\n  .query(params)\n  .end(function(err, content) {\n    var topicUrls = []\n    var $ = cheerio.load(content.text)\n    var courseCard = $('.course-card-container')\n    courseCard.each(function(index, element) {\n      var $element = $(element)\n      var href = url.resolve(\n        homeUrl,\n        $element.find('.course-card').attr('href')\n      )\n\n      topicUrls.push(href)\n    })\n    console.log(topicUrls)\n  })\n```\n\n这样就可以获取到了第一个页面的 25 个课程的详情页的 url，那要如何获取八个页面呢。\n\n**async**\n\n因为有些网站通常都会有安全限制，不会允许同一个域名有过大的高并发数，因此需要限制并发数，在这里用我们用到了 `async` 这个库。这里是其 [github](https://github.com/caolan/async)\n\n我们首先把前面代码封装成一个函数\n\n```js\nvar baseUrl = 'https://www.imooc.com/course/list/'\nvar fetchUrl = function(page, callback) {\n    count++\n    console.log('当前并发数', count)\n\n    var params = {\n      c: 'fe',\n      page: page\n    }\n\n    superagent\n      .get(baseUrl)\n      .query(params)\n      .end(function(err, content) {\n        var topicUrls = []\n        var $ = cheerio.load(content.text)\n        var courseCard = $('.course-card-container')\n        courseCard.each(function(index, element) {\n          var $element = $(element)\n          var href = url.resolve(\n            homeUrl,\n            $element.find('.course-card').attr('href')\n          )\n\n          topicUrls.push(href)\n        })\n\n        callback(err, topicUrls)\n        count--\n        console.log('释放并发数后当前并发数', count)\n        \n      })\n  }\n```\n\n然后用 `async` 控制并发数和八个页面的抓取\n\n```js\nvar pages = [1, 2, 3, 4, 5, 6, 7, 8]\nasync.mapLimit(\n    pages, \n    5,\n    function(page, callback) {\n      fetchUrl(page, callback)\n    },\n    function(err, result) {\n      if (err) console.log(err)\n\n      console.log(result)\n    }\n  )\n})\n```\n\n这样所有的 url 就被打印出来，这里要注意一下，`async` 会自动把第三个函数参数的返回值合并成一个数组给第四个函数参数的 `result` 参数。刚开始写的时候我把 `topicUrls` 声明在了全局，以至于返回成下面这组数据\n\n![spider1](性感慕课-在线被爬/spider1.png)\n\n**爬取课程详情页的信息**\n\n在我们有了所有课程详情页的 url 后，我们开始爬取里面的内容。首先定义一个函数\n\n```js\nvar fetchMsg = function(topicUrl, callback) {\n    console.log('开启新一轮抓取')\n    superagent\n      .get(topicUrl)\n      .end(function(err, content){\n        var Item = []\n        var $ = cheerio.load(content.text)\n        var title = $('.hd .l').text().trim()//课程名字\n        var teacher = $('.tit a').text().trim()//老师名字\n        var level = $('.meta-value').eq(0).text().trim()//难度\n        var time = $('.meta-value').eq(1).text().trim()//时长\n        var number = $('.meta-value').eq(2).text().trim()//学习人数\n        var grade = $('.meta-value').eq(3).text().trim()//评分\n\n        Item.push({\n          title: title,\n          teacher: teacher,\n          level: level,\n          time: time,\n          number: number,\n          grade: grade,\n          href: topicUrl\n        })\n\n\n        callback(null, Item)\n      })\n  }\n```\n\n然后用 `async` 控制并发爬取\n\n```js\n//result 为上文中的 result，下面的代码也都是在上文中的第四个参数中\n\nvar topicUrls = result //获取所有 url ，但是大数组里面有 8 个小数组\n\nvar Urls = []\n//将大数组合并\nfor(let i=0,l=topicUrls.lengthi<li++){\n  Urls = Urls.concat(topicUrls[i])\n}\n\nasync.mapLimit(\n  Urls,\n  5,\n  function(url,callback){\n    fetchMsg(url, callback)\n  },\n  function(err, result) {\n    //避免乱码\n    res.writeHead(200, {'Content-Type': 'text/plaincharset=utf8'})\n    res.end(JSON.stringify(result))\n  }\n```\n\n这里要注意一个小问题，就是 `result` 获取到的 url 结构是一个大数组里面包含八个小数组，因此需要将其小数组先合并成一个大数组。\n\n## 最后\n\n附上[项目源码](https://github.com/MLuminary/subentry/blob/master/easySpider/imoocSpider/app.js)\n","tags":["Node"],"categories":["Fun"]},{"title":"今天这个仇先记下来了","url":"%2F2018%2F05%2F17%2F%E4%BB%8A%E5%A4%A9%E8%BF%99%E4%B8%AA%E4%BB%87%E5%85%88%E8%AE%B0%E4%B8%8B%E6%9D%A5%2F","content":"\n![jichou](今天这个仇先记下来/jichou.jpg)\n\n<!--more-->\n\n最近这个记仇图片在我的一些群里出现次数相当高，朋友们都会去用修图软件去改下面的文字，作为一个前端党就在想能不能更加便利一点，一开始想用 `canvas` 去画文字，后来就偶然搜到了 [html2canvas](http://html2canvas.hertzen.com/)，是一款截图工具，那这样就方便多了。\n\n## 实现\n\n![anpai](今天这个仇先记下来/anpai.jpg)\n\n具体实现方式就是利用 html2canvas 对一个 Div 进行截图，在这个 Div 里有记仇的图片和可编辑的文本框，然后再在下面展示并下载下来就阔以了，这部分涉及到了 base64 图片的下载，也是借用了 segmentFault 上[大神的代码](https://segmentfault.com/q/1010000005816241) \n\n[体验地址](http://www.haoqinzz.cn/jichou/)\n[项目地址](https://github.com/MLuminary/subentry/tree/master/%E4%BB%8A%E5%A4%A9%E8%BF%99%E4%B8%AA%E4%BB%87%E5%85%88%E8%AE%B0%E4%B8%8B%E6%9D%A5)\n[更多](https://www.v2ex.com/t/455984#reply42)","tags":["Canvas"],"categories":["Fun"]},{"title":"prop 和 attr 的一些理解","url":"%2F2017%2F11%2F24%2Fprop%E5%92%8Cattr%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F","content":"\n> 前几天做一个迷你京东小项目的时候涉及到一个全选的小功能，一开始用的是 `attr`，但是效果完全不是自己想要的，当商品按钮点击过一次后，`attr` 就无法对其状态进行更改，最后谷歌了一番发现需要用 `prop` 来代替。虽然效果问题解决了，但是自己还是想弄懂 `prop` 和 `attr` 的区别.\n\n<!--more-->\n\n## 版本使用不同\n\n遇到问题我一般先会去查相关的官方文档，可在 jq 的 api 中文文档中没有发现有价值的东西，只是发现适用的版本和概念有所轻微的不同。\n\n`attr` : 设置或返回被选元素的属性值.版本：1.0\n\n`prop` : 获取在匹配的元素集中的第一个元素的属性值。版本：1.6+\n\n从概念中发现操作的对象和使用也好像基本相同，然后带着疑惑去进行了一番实验并去查阅了一些相关资料\n\n示例代码\n\n```HTML\n<table>\n        <thead>\n            <tr><input type=\"checkbox\" class=\"checkAll\">全选</tr>\n        </thead>\n        <tbody>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n            <tr><input class=\"item\" type=\"checkbox\">单选</tr>\n        </tbody>\n    </table>\n```\n\n```js\n$('.checkAll').click(function() {\n  $('.item').attr('checked', this.checked)\n})\n```\n\n## 问题描述\n\n当全选按钮选中时单选按钮全部选中，当全选按钮不选中时单选按钮全部不选中，只点全选按钮时，反复几次都没问题，但是要是点击了其中一个单选按钮，那这个单选按钮就不会在像其它单选按钮一样跟随全选按钮的状态的改变而改变。\n\n## attr 和 prop 的本质\n\n`attr` 是 `attribute` 的缩写,`prop` 是 `property` 的缩写，都有属性的意思，只不过 `attr` 是操作 html 文档节点属性，`prop` 是操作 js 对象属性. `attr` 在 js 中使用的是 `setAttribute` 和 `getAttribute` 而 `prop` 直接使用原生 js 的 `element[value]` 和 `element[value]=key`。\n\n## attr 和 prop 的区别\n\n`attr` 设置的属性值只能是**字符串类型**,如果不是字符串类型，也会调用其 `toString()` 方法，将其转换成字符串类型。\n\n`prop` 设置的属性值可以包括数组和对象在内的任意类型\n\n### 有关布尔值的属性\n\n1.6 之后, `attr` 返回的也是**字符串类型**, 选中或禁用直接返回 `checked`,`selected`,`disabled`。否则返回`undefined`。解决我问题的关键就是后面一句话\n\n> jQuery 认为：attribute 的 checked、selected、disabled 就是表示该属性初始状态的值，property 的 checked、selected、disabled 才表示该属性实时状态的值(值为 true 或 false)。\n\n当涉及到 boolean 值时，比如 `checkbox` 这样的，有 `true` 和 `false` 这样的布尔值的元素属性，`attributes` 在页面加载的时候就被设置，并且一直保持初始值，而 `properties` 则存储着元素属性的当前值。\n\n所以当我没有点击单选按钮的时候，它就是没被用户点击过的浏览器刚加载出来的初始状态，此时可以通过 `attr` 去设置并操控，当有用户点击的时候，当前按钮就不是初始状态，`attr`自然也就无法操控。\n","tags":["JQ"],"categories":["Explore"]},{"title":"简易扫雷小游戏","url":"%2F2017%2F09%2F07%2F%E7%AE%80%E6%98%93%E6%89%AB%E9%9B%B7%E5%B0%8F%E6%B8%B8%E6%88%8F%2F","content":"\n> 前阵子无聊，LOL 也不是很想玩，发现了电脑中自带的扫雷, 当时在一个神奇的地方，用的是一个 windows2000 的系统界面但是扫雷确是 win7 的样式, \n\n<!--more-->\n\n![pic1](简易扫雷小游戏/pic1.jpg)\n\n这种情况，就是考验运气的时候了，但是果不其然。。。\n\n![pic2](简易扫雷小游戏/pic2.jpg)\n\n我成功选择了有炸弹的那一个，从这里面我明白了一个道理，那就是：**成功需要 99% 的努力再加上 1% 的运气**。。。。。。\n\n## 原理(思路)\n\n### 布局\n\n玩了几句搞清了游戏规则，就想自己动手做一个，因为以前做过 2048，所以首先想到的就是用二维数组布局\n\n添加三个难度的按钮\n\n```html\n<a class=\"type\" href=\"#\" data-width=\"9\" data-height=\"9\" data-mine=\"10\">简单</a>\n<a class=\"type\" href=\"#\" data-width=\"16\" data-height=\"16\" data-mine=\"40\">中级</a>\n<a class=\"type\" href=\"#\" data-width=\"30\" data-height=\"16\" data-mine=\"99\">高级</a>\n```\n\n点击相应按钮通过 js 获取对应的 `data` 属性,然后动态的生成相应的方格,然后动态计算包裹所有小方格的宽度和高度,为了以后方便操作每一个小方格,给每一个小方格按行列添加独有的 `id`。\n\n### 盒子对象\n\n#### 属性\n\n因为扫雷是对每个格子进行操作，因此我把每个格子都看成一个独立的个体，这个个体具有属性和方法，就相当于一个小对象。定义了两个数组\n\n```js\n// 代表盒子身份的数组\nvar boxArr = []\n// 用于存储周围八个格子中雷的个数\nvar MineArr = []\n```\n\n通过这两个数组,我可以知道每个格子是否是炸弹,还有每个格子周围对应八个格子中有多少个炸弹，这属于格子对象的属性。\n\n#### 方法\n\n盒子对象还有鼠标按下和抬起的方法，这里要注意，不要给每个盒子都添加事件。假设有 100 个盒子的话，就要添加 100 个事件，事实上高级难度下的盒子话还有更多，这样就不如在 `container` 上绑定事件，利用冒泡。也可以实现相同的效果，并且只需要绑定一个事件\n\n```js\ncontainer.on('mousedown', '.box', function (e) {\n  $(e.target)//获取点击到的class为box的元素\n}\n```\n\n有的时候格子的 `MineArr` 里面存的可能是 0 ,这就代表他周围 8 个方格不存在炸弹,像这种的话就直接将其周围的八个格子直接自动点开就好了,下面这幅图，我只点了一下,就是点到了 `MineArr[i][j]==0` 的格子,然后让他周围八个直接显示 `MineArr` 中的数值,如果周围八个格子还有 `MineArr[i][j]==0` 的情况，就继续打开去显示。\n\n![pic3](简易扫雷小游戏/pic3.png)\n\n扫雷中还有一个一定要有的方法就是左右键一起按一个点开的格子，会自动判断周围格子中你标记雷的个数和你点击的这个格子的数值。如果你标记雷的个数等于左右键点击的格子中的数值，他会自动帮你点开剩下的还没点击过的格子，这些格子中可能有雷也可能没雷，这要看你自己标记的雷是不是对的。\n\n这个也蛮好实现,右键按下的时候将周围没点击过也没被标记过雷的方格添加带有别的颜色的 `class`，然后记录周围八个方格标记的雷的个数，然后在右键松开的时候移除此 `class`,并判断刚记录的标记的雷的个数和当前点击的格子的数值是否相等，然后去做下一步处理。\n\n### 成功失败判断\n\n失败很好判断，点中了 `boxArr` 为 1 的格子就判失败，就是点中了雷。\n\n成功的话我是通过点击出来的格子的数量来判断的，成功显现的格子只要等于总格子减去雷的格子就判断为游戏胜利\n\n## 总结\n\n虽然是一个比较简单的游戏，但是自己在做的时候还是碰到过不少的 bug,也学到了蛮多的,这里列一下。\n\n### 清空问题\n\n* 每次创建新的格子都要清空上次创建的所有格子\n\n* 我是采用冒泡的方式给盒子添加的点击事件，是添加在 `container` 上的，然后 `container` 是不消失的，所以每次创建新格子前还要将 `container` 上的事件解绑\n\n### 右键\n\n右键在网页上是有默认行为的，在这个游戏中要禁掉\n\n```js\n//去掉默认的contextmenu事件，否则会和默认右键事件同时出现。\ndocument.oncontextmenu = function(e) {\n  e.preventDefault()\n}\n```\n\n### each()\n\njquery 中的 `each` 是不能用 `break` 跳出的。是用 `return false` 代替的 `break`, `return true` 或 `return` 代替的 `continue`\n\n### 最后\n\n还有一些我思路上或者说写法中存在的小 bug,我用相应的方法去解决掉了。大家可以看[源码](https://github.com/MLuminary/subentry/tree/master/cleanMine),因为花的时间比较短,可能里面还存在一些问题,还请大佬们多多包涵,也欢迎大佬们来指正。本小白感激不尽，喜欢的话还请点个 :star:\n\n[小游戏试玩](https://www.haoqinzz.cn/cleanMine)\n","tags":["Idea"],"categories":["Fun"]},{"title":"对象类型的辨别","url":"%2F2017%2F08%2F24%2F%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BE%A8%E5%88%AB%2F","content":"\n> 对象类型的判别不同于基础类型的判别，js 中又有一句话叫万物皆对象，\b因此对象的判别工作要比基础数据类型要稍微麻烦一点\n\n<!--more -->\n\n## 判断一个对象是不是数组类型\n\n### typeof\n\n少部分人可能首先会想到 `typeof`\n\n```js\nvar n = 3,\n  b = true,\n  s = 'Hello',\n  x = null,\n  y,\n  obj1 = function() {},\n  obj2 = {},\n  obj3 = [],\n  obj4 = new Date();\nconsole.log(\n  typeof n, //number\n  typeof b, //boolean\n  typeof s, //string\n  typeof x, //object\n  typeof y, //undefined\n  typeof obj1, //function\n  typeof obj2, //object\n  typeof obj3, //object\n  typeof obj4 //object\n)\n```\n\n可以看出 `typeof` 是可以判断出基本数据类型的，函数也能判断出来，但是对象、数组、日期都会返回 `object` ,这样就根本无法判断一个对象是不是数组类型。所以 `typeof` 宣告无能为力\n\n### 判断其父级原型对象\n\n```js\nvar obj1 = {},\n  obj2 = [1, 2, 3],\n  obj3 = new Date()\n\nconsole.log(obj1.__proto__ === Array.prototype) //false\nconsole.log(obj2.__proto__ === Array.prototype) //true\nconsole.log(obj3.__proto__ === Array.prototype) //false\n```\n\n但是 `__proto__` 是内部属性，本不应该被访问到，我们可以用 `Object.getPrototypeOf(obj)` 方法来代替他，虽然这个方法其实内部原理也是他，但是还是有不同的。\n\n```js\nconsole.log(Object.getPrototypeOf(obj1) === Array.prototype) //false\nconsole.log(Object.getPrototypeOf(obj2) === Array.prototype) //true\nconsole.log(Object.getPrototypeOf(obj3) === Array.prototype) //false\n```\n\n### 判断其构造函数\n\n`obj instanceof Array` 判断 `obj` 是不是被构造函数 `Array` 创造出来的\n\n```js\nconsole.log(obj1 instanceof Array) //false\nconsole.log(obj2 instanceof Array) //true\nconsole.log(obj3 instanceof Array)\t//false\n```\n\n但 `instanceof` 不仅判断直接父类型，而是所有在原型链上的类型，都返回 `true` ,所以如果你创建一个对象但是把他的 `__proto__` 指向 `Array` 的原型，然后判断其类型，也会返回 `true`。\n\n```js\nobj1.__proto__ = Array.prototype\nconsole.log(obj1 instanceof Array) //true\n```\n\n\n### 判断对象内部的 class 属性\n\n每个对象内部，都有一个隐藏的 `class` 属性，记录该对象创建时的数据类型 `class` 属性不会随继承关系的改变而改变。（就相当于查人的 DNA，小样还想伪装）\n\n这里有一个问题：内置类型的原型对象中几乎都重写了新的 `toString()`，只有最顶层的 `toString()` 才能输出对象的 `class` 属性值，\n\n因此我们可以用 `call` 来使用最牛皮的身份鉴别\n\n```js\nconsole.log(\n  Object.prototype.toString.call(obj1) === /*[object Object]*/ '[object Array]'\n) //false\nconsole.log(\n  Object.prototype.toString.call(obj2) === /*[object Array]*/ '[object Array]'\n) //true\nconsole.log(\n  Object.prototype.toString.call(obj3) === /*[object Date]*/ '[object Array]'\n) //false\n```\n\n### Array.isArray\n\n`Array.isArray` 也可以弥补 `typeof` 的不足\n\n```js\nArray.isArray(obj1) //false\nArray.isArray(obj2) //true\nArray.isArray(obj3) //false\n```\n\n但其实 `isArray` 的原理就是判别其内部的 `class` \n\n```js\nif (!Array.isArray) {\n  Array.isArray = function(arg) {\n    return Object.prototype.toString.call(arg) === '[object Array]'\n  }\n}\n// -- 来自 MDN\n```\n\n\n","tags":["Base"],"categories":["Explore"]},{"title":"图解作用域及闭包","url":"%2F2017%2F08%2F20%2F%E5%9B%BE%E8%A7%A3%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%8F%8A%E9%97%AD%E5%8C%85%2F","content":"\n> 网络上关于作用域及闭包的文章很多，自己对于纯理论知识并不能很快的理解，但自己对于图画有很强的记忆能力，因此决定将此知识点以图画的知识表现出来，加深自身理解的同时如果能帮到正在学习的童鞋就再好不过了, <br> 下面我以函数的整个生命周期来诉说此部分知识\n\n<!--more-->\n\n## 函数生命周期\n\n先写一下示例代码\n\n```js\nvar a = 10 \nfunction func(a) {\n  var a = 20 \n  a++ \n  console.log(a) \n}\nfunc() \nconsole.log(a) \n```\n\n### 开始执行程序前\n\n![pic2](图解作用域及闭包/pic2.jpg)\n\n1.  先创建 ECS，ECS 其实就是专门保存正在调用的函数的执行环境的数组，也可以说对象，其实关联数组也就相当于对象。\n\n2.  然后在 ECS 中添加浏览器主程序的执行环境 main\n\n3.  创建全局作用域对象 window\n\n4.  main 执行环境引用 window\n\n### 定义函数时\n\n![pic3](图解作用域及闭包/pic3.jpg)\n\n1.  原始类型的全局变量会直接存入 window 环境当中，因为函数是引用类型，所以首先用函数名声明全局变量\n\n2.  然后创建函数对象，封装函数定义\n\n3.  函数对象的 scope 属性，指回函数创建时的作用域，意思是，函数执行时如果函数本身提供的变量不能让函数执行完全，那它便会去回它创建时的那个作用域去寻找变量。\n\n4.  函数名后面存入指向函数对象的地址\n\n引用类型在其中只能存储地址，这个在此笔记[谈谈值传递](https://github.com/MLuminary/Blog/issues/1)中有详细说明\n\n### 函数调用时\n\n![pic4](图解作用域及闭包/pic4.jpg)\n\n1.  向 ECS 中压入本次函数调用的执行环境元素\n\n2.  创建本次函数调用时使用的函数作用域对象（AO），也就是临时作用域\n\n3.  在 AO 中创建储存所有的局部变量，包括形参变量和函数内用 var 声明的变量\n\n4.  设置 AO 的 parent 属性和引用函数的 scope 属性指向父级作用域对象\n\n5.  函数的执行环境引用 AO\n\n6.  顺着那个箭头，先在 AO 中找变量，也就是局部变量，如果 AO 中没有，再顺着箭头去父级作用域中找\n\n### 函数调用后\n\n![pic5](图解作用域及闭包/pic5.jpg)\n\n函数的执行环境出栈，AO 释放，AO 中的局部变量一同被释放掉。\n\n我们得知整个结果之后，自然而然那两个 `console` 的结果也显然意见。\n\n## 闭包\n\n前面我们提到过，全局变量是可重用但是污染全局，局部变量不会污染全局但是不可重用。\n\n我自己认为闭包就是重用变量又保护变量不被污染的机制，就是为了解决这一情况而生的。\n\n### 特点\n\n**包裹受保护的变量和操作变量的内层函数的外层函数**\n\n**外层函数要返回内层函数的对象**\n\n* `return function(){..}`\n* 直接给全局变量赋值一个内部 `function`\n* 将内部函数保存在一个对象的属性或数组元素中 `return [function function function]` 或 `return {fun:function(){...}}`\n\n**调用外层函数，用外部变量接住返回的内层函数对象,形成闭包。**\n\n### 原理\n\n先贴出示例代码\n\n```js\nfunction outer() {\n  var num = 1 \n  return function() {\n    console.log(num++) \n  } \n}\n\nvar getNum = outer() \ngetNum() \ngetNum() \nnum = 1 \ngetNum() \n```\n\n下面我把闭包形成的原理用画图工具画出来\n\n![pic6](图解作用域及闭包/pic6.jpg)\n\nwindow 中存入 outer 名并指向 outer 函数对象，`getNum` 因为声明提前也先将变量名存在 window 中。\n\n`getNum = outer()` 其实包含 outer 的创建和 `getNum` 的赋值。\n\n上面的图画的是 outer 函数进行到 `var num = 1 ` ,前面都有说过，不过多重复。\n\n![pic7](图解作用域及闭包/pic7.jpg)\n\n创建了匿名函数，`getNum` 指向了匿名函数对象，匿名对象的 scope 指向它的父级作用域，也就是 outer 的作用域，那这样就形成了图中的三角关系，此时 outer 执行完毕，离开 ECS 执行环境，outer 的 AO 本也应该随着离开，**但是因为这强大的三角关系，强行拉住不让其释放**，也就形成了所谓的闭包。\n\n**那其实闭包的原因就是**:外层函数的作用域对象无法释放\n\n![pic8](图解作用域及闭包/pic8.jpg)\n\n`getNum=outer()`getNum 其实就是一个函数\n\n![pic9](图解作用域及闭包/pic9.png)\n\n调用`getNum()`,会生成 `getNum` 的临时作用域,图中可看出,`getNum` 其实就是在 outer 中的匿名函数，所以他的 parent 就指向 outer 留下的作用域。当他执行 `console.log(num++)` 的时候，在他的作用域中没有 `num` 变量他就会顺着作用域链去寻找，最终在 outer 中的作用域中找到 `num` 并对其进行自加操作。**所以当下次调用 getNum 的时候 num 会从 2 开始，不会是一开始的 1**。\n\nnum 不是全局变量，还实现了 num 变量的重复调用。就达到了闭包的目的。\n\n![pic10](图解作用域及闭包/pic10.jpg)\n\n设置 `num = 1` 只是在 `window` 对象上添加存储 `num` 的值，当下次调用 `getNum` 的时候 js 引擎还会从 `getNum` 作用域开始顺着作用域链寻找 `num`,在 outerAO 就会寻找到 `num`,所以根本不会影响到 window 中的 `num`,也不会受其影响。因此此段代码输出的结果为 `1 2 3`。\n\n### 缺点\n\n当然闭包也有其缺点\n\n* 比普通函数占用更多内存，因为外层函数的作用域对象（AO）始终存在\n\n* 容易造成内存泄漏\n\n### 解决办法\n\n将引用内存函数对象的外部变量重置为 null\n\n```js\ngetNum = null \n```\n\n![pic11](图解作用域及闭包/pic11.jpg)\n\ngetNum 指向 outer 函数对象的那根线就会断掉，三角关系破裂，那函数对象和 outerAO 也会相继被销毁。\n\n","tags":["Deep"],"categories":["Explore"]},{"title":"Js 函数基础","url":"%2F2017%2F08%2F17%2Fjs%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%2F","content":"\n> 每天都在和函数打交道，到底函数是个啥，还有啥隐藏的秘密吗\n\n<!--more -->\n\n## 函数的定义\n\n**函数其实就是一个封装一段代码段的对象，函数名其实仅是用来引用函数对象的一个普通变量**,写代码的时候我们避免不了要重复用一些代码，一直重复写很耗时，而且不美观也不利于维护，因此函数的出现就是来让代码重用，便于维护。一段可能被反复使用的代码，就可以定义为函数，然后调用函数来使用这段代码。\n\n## 函数的创建\n\n**function 声明**\n\n```js\nfunction 函数名(参数列表) {\n  函数体\n  return 返回值\n}\n```\n\n**直接量声明**\n\n```js\nvar 函数名 = function(参数列表) {\n  函数体\n  return 返回值\n};\n```\n\n**用 new 创建**\n\n因为 Function 是内置类型，本身有一个 Function 的构造函数，所以是可以 `new` 的\n\n```js\nvar 函数名 = new Function(\"参数名1\",\"参数名2\",...,\"函数体; return 返回值\")\n```\n\n这里注意，参数和函数体都要用引号引起来，但是一般函数的创建都不会这样创建，以前面的两种为主，那其实前面两种的创建是存在一定的差别的，下面会提到\n\n## 函数的参数\n\n函数执行时必须的数据变量，它分为「 显示参数 」(Parameters)与「 隐式参数 」(Arguments)\n\n### 显示参数\n\n```js\nfunction fun(name, id) {\n  //函数体\n}\n```\n\n这种直接传进来的 `name` 和 `id` 就是显示参数，也就是你能看到的。其实函数传递的参数就相当于**在函数体内又声明了一个局部变量**\n\n```js\nvar i = 10\nfunction fun(i) {\n  i++\n  console.log(i)\n}\nfun(i)\n```\n\n上面的代码，就相当于下面的代码\n\n```js\nvar i = 10\nfunction fun() {\n  var i = 10 //这个值就是传进来的参数的值\n  i++\n  console.log(i)\n}\nfun(i) //在此处传入i\n```\n\n### 隐式参数\n\n每个 JavaScript 函数内部都有一个对象 `arguments` 对象,其实是一个类数组的对象,它会自动接受所有传入函数的参数值。\n\n```js\nfunction func(          ) {\n  //arguments[          ]\n}\n```\n\n值得一说的是, `arguments` 有下标有长度，可以通过下标来获得传入的参数，比如 `arguments[0]` 就是第一个参数, `length` 就可以遍历这个类数组对象，但是，毕竟他不是数组，所以不能进行一些数组特有的操作，比如 `sort`\n\n## 声明提前\n\n在开始执行程序前,js 引擎会首先查找 `var` 声明的变量和 `function` 声明的函数，**将其提前到当前作用域的顶部集中创建，而将赋值操作保留在原地**,这里特别说一下, **未用 `var` 声明的变量不会声明提前**.\n\n```js\nconsole.log(a) //a is not defined\na = 10\n```\n\n```js\nconsole.log(a) //undefined\nvar a = 10\nconsole.log(a) //10\n```\n\n因为声明提前,其实代码会变成下面这个样子\n\n```js\nvar a\nconsole.log(a)\na = 10\nconsole.log(a)\n```\n\n这样看，一切都变得很合理。。\n\n函数也是一样\n\n```js\nfunction fun() {\n  console.log(1)\n}\nfun() //2\nfunction fun() {\n  console.log(2)\n}\nfun() //2\n```\n\n控制台会输出两个 `2`,因为 `function` 声明的函数也会声明提前,代码其实是下面这个样子\n\n```js\nfunction fun() {\n  console.log(1)\n}\nfunction fun() {\n  console.log(2)\n}\nfun() //2\nfun() //2\n```\n\n第二次声明因为与第一次声明方法名字一样，后者覆盖了前者，所以再调用的时候就会调用最后这个\n\n但是声明提前会增加程序解读的难度，因此我们在写程序时，尽量避免声明提前所带来的危害\n\n### 声明提前的解决方法\n\n那我们既然知道会有声明提前这种操作，就在变量和函数的声明时都放在当前作用域的顶部。\n\n在 ES6 中 可以用 `let` 代替 `var`,不过要求在当前作用域中 `let` 变量之前不允许出现声明的变量, 也可以用直接量声明变量的方法\n\n```js\nvar fun = function() {\n  console.log(1)\n}\nfun() //1\nvar fun = function() {\n  console.log(2)\n}\nfun() //2\n```\n\n这种当然也会声明提前，那我们看一下声明提前后的代码\n\n```js\nvar fun\nvar fun\nfun = function() {\n  console.log(1)\n}\nfun() //1\nfun = function() {\n  console.log(2)\n}\nfun() //2\n```\n\n声明提前但是赋值还是留在原地，所以虽然有声明提前，但是并不会改变我们原本想要的结果。也就解决了声明提前带来的危害。\n\n## 匿名函数\n\n函数创建时没有指定函数名,匿名函数使用后自动释放,会节约内存,他会划分临时作用域，避免全局变量污染全局。\n\n### 用处\n\n**callback**\n\n将一个函数作为参数传入另一个函数内，被其他函数调用\n\n举个:chestnut:\n\n```js\narr.sort(function(a, b) {\n  return a - b\n})\n```\n\n```js\nstr.replace(/reg/g, function(kw,$1,$2,...){return 替换值})\n```\n\n**自调**\n\n定义函数后自己调用自己，调用结束后，立刻释放，不占内存\n\n举个:chestnut:\n\n```js\n(function(参数列表) {\n  函数体\n  return 返回值\n})(参数值列表)\n```\n\n会定义一个临时的作用域，减少使用全局变量，避免全局污染。\n\n## 重载\n\n相同函数名，不同参数列表的多个函数。在调用时，根据传入参数的不同，自动选择匹配的函数执行。这样可以减少 api 的数量，减轻调用者的负担。\n\n听起来很诱人，但是 Js 语法不支持重载，原因是 Js 不允许多个同名函数同时存在，后声明的函数会覆盖前面声明的,但是可以通过某些方法实现，这个方法就是利用 `arguments`\n\n```js\nfunction test() {\n  if (arguments.length == 0) {\n    //不传值的操作\n  } else if (arguments.length == 1) {\n    //传一个值进行的操作\n  } else {\n    //....等等\n  }\n}\n```\n\n其实也不是真正意义上的重载，因为并没有创建同名的多个函数，但是实现的效果是和重载差不多的。\n","tags":["Base"],"categories":["Explore"]},{"title":"你好！BFC!","url":"%2F2017%2F08%2F09%2F%E4%BD%A0%E5%A5%BD%EF%BC%81BFC%2F","content":"\n> BFC 这个名字听过很多次了，文章中总是说触发 BFC 然后怎样怎样，开始的时候觉得 BFC 很神秘，应该很难，当时只为解决眼前问题的我，就没有选择去了解一下 BFC，只是知道有 BFC 的存在，但并不认识他，今天终于鼓起勇气想他打个招呼，认识认识这位看似神秘的朋友.\n\n<!--more-->\n\n## 文档流\n\n我们常说的文档流分为三种，普通流，浮动流和定位流。在这里简单的介绍一下。  \n\n在「普通流」中，元素按照在 HTML 中的先后位置至上而下布局，块级元素从上到下依次排列，框之间的垂直距离由框的垂直 `margin` 计算得到。行内元素在一行中水平布置，直到占满一行则换行  \n\n「浮动流」就是元素被设置了浮动属性，一开始还是按照普通流布局，但是会根据浮动的方向移动。\n\n「定位流」就是设置了定位属性，元素完全脱离普通流。\n\n## BFC 定义\n\nBFC(Block Formating Context),直译过来就是「 块级格式化上下文 」(在 CSS3 中，BFC 叫做 Flow Root)。FC 就是其实就是普通流的意思，是一块渲染区域，有他的渲染规则。那 B 就是 block 就是块级元素。**简单的理解来说，有一块独立的渲染区域，只有 block 元素，这些 block 元素按照此渲染区域的规则布局，并且不受这个区域外部的其它元素影响。**\n\n## BFC 的触发\n\n* 根元素\n* 浮动元素\n* 绝对定位和固定定位\n* display 为 inline-block||table-cell||table-caption||flex||inline-flex\n* overflow 不是 visible\n\n满足以上任意一个条件都可以触发 BFC，这里注意一下，触发 BFC 不是元素本身变成了 BFC，而是这个元素带有了 BFC 的规则。\n\n## BFC 的规则\n\n为什么要触发 BFC，那 BFC 到底有什么规则，有什么好处呢？\n\n* Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n\n* BFC 的区域不会与 float box 重叠。\n\n* 计算 BFC 的高度时，浮动元素也参与计算\n\n## 作用\n\n其实 BFC 完全贯彻的一点就是，**BFC 是一个独立的不受外部影响的一个渲染区域，他也不会去影响别的元素。**，记住并理解这句话也就是理解了 BFC ，因为 BFC 的作用都是根据这一规则产生的\n\n### margin 重叠\n\n```css\n.box {\n  background-color: red;\n  margin: 100px;\n  width: 100px;\n  height: 100px;\n}\n```\n\n```html\n<div class=\"box\">box1</div>\n<div class=\"box\">box2</div>\n```\n\n我们知道两个 `box1` 和 `box2` 的中间间距会发生 `margin` 重叠并只有 `100px`,那是因为他们同在 html 下的一个大的 BFC 中的一个渲染区域中，我们只要让他们两个的 BFC 区域不同，他们两个就不会发生 `margin` 重叠.\n\n在 `box2` 添加 div 包裹层,然后在此包裹层中添加任意规则属性，就会发现 `margin` 重叠问题已经解决.因为此时 `box2` 身处的 `BFC` 和 `box1` 就不相同了。\n\n### 清除浮动\n\n剩下两个规则都与浮动有关，其实我听说 BFC 这个名词也是因为清除浮动，因为 BFC 不能影响外部的布局，所以计算高度时，浮动也参加运算，因此就解决了高度塌陷这个问题。\n\n## 总结\n\n前端之路还在继续，认识了 BFC 以后也会去多多了解磨合。总之现在严格记住的一点就是**他是一个独立的不影响外部也不受外部影响的区域，那其他的特性都是建立在此基础上的。**\n","tags":["Base"],"categories":["Explore"]},{"title":"谈谈值传递","url":"%2F2017%2F07%2F25%2F%E8%B0%88%E8%B0%88%E5%80%BC%E4%BC%A0%E9%80%92%2F","content":"\n> ECMAScript 变量可能包含两种不同的数据类型：「基本数据类型」和「引用数据类型」，这两种类型的**值传递**是存在不同的.在我们谈这两种数据类型的值传递前，为了便于理解，我想首先谈一下这两种数据类型有关**复制**操作存在的不同\n\n<!--more -->\n\n## 数据类型的复制\n\n### 基本类型\n\n```javascript\nvar num1 = 10 \nvar num2 = num1 \nnum2 = 11 \nconsole.log(num1)  //10\nconsole.log(num2)  //11\n```\n\n基本数据类型从一个复制到另一个，会在变量对象上**创建**一个新值，然后把该值复制到新变量分配的位置上，**改变其中一个不会影响另一个**。\n\n本小白用拙劣的画功演示一下\n\n![pic1](谈谈值传递/pic1.jpg)\n\n一开始声明变量 `num1` 并赋值为 `10`,它便以图中的形式存放在栈内存中，当用 `num1` 的值来初始化 `num2` 的时候，此时就相当于声明变量 `num2` 并赋值为 `num1` 中的值，**该值只是 `num1` 中的一个副本**，赋值结束，这两个变量便再无瓜葛，进行后面的操作也不会相互影响\n\n### 引用类型\n\n引用类型我们采用数组来讲解，数组的声明有两种方式，一种为 `var 数组名 = []` 另一种为 `var 数组名 = new array()`\n\n```javascript\nvar arr1 = [1, 2, 3, 4] \nvar arr2 = arr1 \narr2[0] = 10 \nconsole.log(arr1)  //[10,2,3,4]\nconsole.log(arr2)  //[10,2,3,4]\n```\n\n可以看出输出的结果都为 `[10,2,3,4]`， 和基本数据类型完全不同。数组的存储方式如下图所示\n\n![pic2](谈谈值传递/pic2.jpg)\n\n当声明数组变量并赋值的时候，同样也会存入一个栈结构当中，但是这个栈结构不能存 `[1,2,3,4]` 这种引用类型的数据，要存到堆内存中去，就是图片右边那个圆形的区域，但是存入的数据还是要找到它，因为每个存储位置都有其相应的地址，所以它在栈内存中存入的是一个指向数组对象数据的这样的一个地址。\n\n![pic3](谈谈值传递/pic3.jpg)\n\n因此当复制引用类型变量的时候，同样也会将**存储在栈内存中的地址值复制一份放到为新变量分配的空间中去，只不过因为这个值的副本是一个指向堆中原数组对象数据的地址，两个变量名就相当于引用了同一个地址中的内容。因此，改变其中的一个，就相当于改变了另一个**。\n\n再看下面这个:chestnut:\n\n```javascript\nvar arr3 = [1, 2, 3, 4] \nvar arr4 = arr3 \narr4 = [5, 6, 7, 8] \nconsole.log(arr3)  //[1,2,3,4]\nconsole.log(arr4)  //[5,6,7,8]\n```\n\n这个相比于前面那个，只是在第三行代码中出现了不同，`arr4 = []` 这样也是创建数组的一种方式，因此 `arr4 = [5,6,7,8]` 其实是将一个新创建的数组对象赋给变量 `arr4` ,这时 `arr4` 后的地址就改变了,也就指向了新的数组对象，这两个变量也就完全不相同了.\n\n![pic4](谈谈值传递/pic4.jpg)\n\n方便理解可以看下下面的代码\n\n```js\nconsole.log(new Array(1,2) === new Array(1,2)) //false\n```\n\n那好，现在有了这些铺垫，我们再来谈我们今天的主要内容.\n\n## 数据类型的值传递\n\n### 基本类型\n\n```javascript\nvar num = 10 \n\nfunction change(num) {\n  num = 11 \n  console.log(num)  //11\n}\n\nchange(num) \nconsole.log(num)  //10\n```\n\n在向参数传递基本类型的值时，**被传递的值会被先复制给一个局部变量**，其实就可以理解为基本数据类型的赋值。以上的代码也可以写为这样\n\n```javascript\nvar num = 10 \n\nfunction change() {\n  var num = 10  //look\n  num = 11 \n  console.log(num)  //11\n}\n\nchange(num) \nconsole.log(num)  //10\n```\n\n在 look 处，函数会将参数先声明并赋值，值就为下面传入的参数的值，`num` 的值为 `10`,因此赋得值也为 `10`。但此时函数中的 `num` 和函数外部的 `num` 其实是毫不相关的，因此并不会相互影响\n\n### 引用类型\n\n```javascript\nvar arr = [1, 2, 3, 4] \n\nfunction change(arr) {\n  arr[0] = 10 \n  console.log(arr)  //[10,2,3,4]\n}\n\nchange(arr) \nconsole.log(arr)  //[10,2,3,4]\n```\n\n引用类型也如此，也可以理解为引用类型的复制操作，在函数的开头就会将 `arr` 赋值为传来的数值，虽然也是一开始声明的引用类型的副本，**但是因为引用类型传来的数值是地址，因此函数中的 `arr` 和函数外面的 `arr` 都将引用同一个地址中的数组对象**，因为 `arr` 指向的数组对象在堆中只有一个，又是全局变量，因此这两个 `arr` 是相同的，同样我们再看那一种声明数组并赋值的.\n\n```javascript\nvar arr = [1, 2, 3, 4] \n\nfunction change(arr) {\n  arr = [4, 5, 6, 7] \n  console.log(arr)  //[4,5,6,7]\n}\n\nchange(arr) \nconsole.log(arr)  //[1,2,3,4]\n```\n\n那这个也就应该可以理解了，虽然在传参的时候传入的确实是一开始声明的数组对象的地址的副本，但是因为在函数内部又**声明了一个新的数组对象**，在这里 `arr` 引用的就是一个局部的数组对象了，而这个局部对象就会在函数结束后立即被销毁，不会影响函数外部的数组对象\n\n","tags":["Base"],"categories":["Explore"]},{"title":"关于css实现div居中问题","url":"%2F2017%2F07%2F18%2F%E5%85%B3%E4%BA%8Ecss%E5%AE%9E%E7%8E%B0div%E5%B1%85%E4%B8%AD%E9%97%AE%E9%A2%98%2F","content":"\n> 自己最近在做有关 css 居中时发现自己不能准确的找到居中的解决方案，虽然最后也能试出解决方案，但是感觉必须深入其中，了解各个居中方案的适用场景，才能准确的写出不多余又正确的 css 代码\n\n<!--more -->\n\n## 示例代码\n\n```html\n<div class=\"header\">\n  <div class=\"nav\"></div>\n</div>\n```\n\n```css\n* {\n  margin: 0;\n  padding: 0;\n}\n.header {\n  height: 70px;\n}\n.nav {\n  height: 70px;\n  background: red;\n}\n```\n\n## 当需要居中的 div 设置了固定宽度\n\n### margin\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  width: 300px;\n  margin: 0 atuo;\n}\n```\n\n`auto` 可以理解为一样的意思，如果左右都设置 `auto`，意思就是这个 `div` 离左面的距离和右面的距离是一样的,但是此方法只适用于设置了宽度的块级元素。\n\n\b但是如果你设置了以下几种属性时，其居中效果便会消失\n\n- `postion: absolute`\n- `float`\n- `display:inline`\n\n块级元素始终独占一行，无论是否设置了宽度，未设置宽度时他会自动充满，设置了宽度时，虽然他看起来这一行并不都是他的「地盘」，但是你如果在他后面添加元素的时候，你会发现元素会被挤到下一行去。\n\n```html\n<div class=\"header\">\n  <div class=\"nav\"></div>\n  咋回事啊\n</div>\n```\n\n![pic2](关于css实现div居中问题/pic2.png)\n\n怎么肥四，为森么会发生这种情况呢，看一下下面一张图\n\n![pic3](关于css实现div居中问题/pic3.png)\n\n可以看到，虽然 `div` 设置了宽度，但是他有一种**无形的力量占据了他所在的行的剩下的空间，以至于其它元素无法与其在一行**。而这一块橙色区域也就是 `margin: 0 auto` 可调控区域，**`auto` 会根据这一部分的大小及时分配左右的距离，达到居中的效果**，当设置了绝对定位、浮动或将其设置为行内元素的时候，他这种「威慑力」便会消失，`auto` 可分配的区域便会消失\n\n![pic4](关于css实现div居中问题/pic4.png)\n\n可以看到，此时那块黄色的区域已经消失，`margin: 0 atuo` 也就随之失效了\n\n不过也有一种例外\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  width: 300px;\n  position: absolute;\n  left: 0;\n  right: 0;\n  margin: 0 atuo;\n}\n```\n\n此时虽然已经设置绝对定位，`div` 也已经脱离了标准文档流，但是 `left:0 right:0` 又让其具有了那种「威慑力」，\b`margin: 0 auto` 也就又拥有了可调控的区域\n\n![pic5](关于css实现div居中问题/pic5.png)\n\n### 绝对定位\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  width: 300px;\n  position: absolute;\n  left: 50%;\n  margin-left: -150px;\n}\n```\n\n设置绝对定位让其 `left` 属性起作用，然后设定 `left:50%`，但是因为此 `div` 本身还有宽度，因此还要添加 `margin-left:-此div宽度的一半px;` 让其真正的居中\n\n## 需要居中的 div 没有宽度\n\n很多状况下我们要居中的元素是不知道宽度的，有时候可能宽度也不是固定的，因为里面的内容有可能以后要增加，或者随着浏览器的变化此宽度可能也要跟随变化，下面将示例代码的 css 改为如下形式\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n}\n```\n\n![pic6](关于css实现div居中问题/pic6.png)\n\n可以看到，当不设置宽度的时候，此 `div` 默认是充满整个浏览器的，这样的话就无所谓居中或不居中了，通常我们要居中这个 div，是想让这个 div 中的一些信息居中，为了便于演示，我在 html 和 css 中多添加了几行代码\n\n```html\n<div class=\"header\">\n  <div class=\"nav\">\n      <ul>\n        <li>热爱前端</li>\n        <li>热爱编程</li>\n        <li>热爱生活</li>\n        <li>渴望知识</li>\n      </ul>\n  </div>\n</div>\n```\n\n```css\n* {\n  margin: 0;\n  padding: 0;\n}\n.header {\n  height: 70px;\n}\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n}\nul {\n  list-style: none;\n}\nli {\n  float: left;\n  margin-left: 30px;\n}\n```\n\n**效果图**\n\n![pic7](关于css实现div居中问题/pic7.png)\n\n此时我们应该想办法让 `div` 的宽度不是充满整个浏览器，让它的宽度仅仅就是里面内容的宽度，这样我们才能让它居中。在块状元素下，如果不设置宽度，它始终是要充满整个屏幕的。\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n  display: inline-block;\n}\n```\n\n当设置 `nav` 为行内元素，或者 `table` 元素的时候他的宽度就默认不是最大化，而是根据包裹的内容改变，也就是最小化。设置为 `position` 或者 `display:table` 也一样。\n\n![pic8](关于css实现div居中问题/pic8.png)\n\n### text-align:center\n\n用 `text-align:center` 实现元素居中，这个属性不是只能让文本元素居中，它可以让**行内元素居中**，所以只要把要居中的元素设置为行内元素，然后向其父元素添加 `text-align:center` 属性，就可以实现居中\n\n```css\n.header {\n  height: 70px;\n  text-align: center;\n}\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n  display: inline-block;\n}\n```\n\n### display:table\n\n设置 `nav` 为 `display:table` ,`nav` 就相当于说就具有了 `table` 的属性，那我们都知道 `table` 的宽度是根据其内容的多少而变化的，也就是宽度最小化，而此时 `nav` 便也可以使用 `margin:0 auto` 来居中\n\n```css\n.nav {\n  height: 70px;\n  background: red;\n  line-height: 70px;\n  color: #fff;\n  display: table;\n  margin: 0 auto;\n}\n```\n","tags":["Base"],"categories":["Explore"]}]